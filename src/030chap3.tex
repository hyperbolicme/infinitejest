\xclearpage

\chapter[Tree Path Labeling]{Tree Path Labeling of Path
  Hypergraphs -- New Results}
\label{ch:myresearch}

This chapter documents all the new results obtained by us in the area
of tree path labeling of path hypergraphs which is the problem
addressed in this thesis. The organization of the chapter is as
follows.

Section~\ref{sec:myresearchintro} recalls the idea of tree path
labeling. The necessary preliminaries with definitions etc. are
presented in Section~\ref{ch:prelims}. Section~\ref{sec:feasible}
documents a characterization for feasible path labelings. In
Section~\ref{sec:wallacesol} we demonstrate the algorithm described in
Section~\ref{sec:feasible} by working out the solution to an example.
Section~\ref{sec:spltargettree} describes two special cases where the
target tree is of a particular family of trees. The first one is shown
to be equivalent to COP testing in
Section~\ref{sec:icpplicpia}. Section~\ref{sec:ksubdivstar} discusses
the second special case and presents a polynomial time algorithm to
find the tree path labeling of a given set system from a given
\kstar. Section~\ref{sec:norestraint} discusses the plain vanilla
version where the target tree has no restrictions and the algorithm to
find a feasible TPL, if any, in this case.  Finally, in Section
\ref{sec:tplcomplexity} we discuss the complexity of the algorithms
seen thus far and we conclude by showing that \cop testing, which is a
special case of \TPL, is in \logspace.

\section[Summary of problems]{Summary of Proposed Problems}
\label{sec:myresearchintro}
In Section~\ref{sec:motive} we see that consecutive-ones property and
its equivalent problem of interval labeling of a hypergraph is a
special case of the general problem of tree path labeling of path
hypergraphs. Moreover, Section~\ref{sec:icpiasurvey} describes how the
problem of consecutive-ones property testing can be easily seen as a
simple constraint satisfaction problem involving a hypergraph or a
system of sets from a universe. Every column (row) of the binary
matrix can be converted into a set of non-negative integers which are
the indices of the rows (columns) with {\un}s in that column
(row). When observed in this context, if the matrix has the COP on
columns (rows), a reordering of its rows (columns) will result in sets
that have only consecutive integers. In other words, the sets after
applying the COP row (column) permutation are intervals.  In this
form, one can see that this is indeed the problem of finding interval
assignments to the given set system with a single permutation of the
universe (set of row or column indices for COP of columns or rows,
respectively) which permutes each set to an interval. The result in
\cite{nsnrs09} (see Theorems~\ref{th:icpia2} and \ref{th:icpia1})
characterizes interval assignments to the sets which can be obtained
from a single permutation of the universe. The cardinality of the
interval assigned to it must be same as the cardinality of the set,
and the intersection cardinality of any two sets must be same as the
intersection cardinality of the corresponding intervals. This is a
necessary and sufficient condition.

Intervals are paths from a tree with maximum degree two. Thus the
interval assignment problem can be naturally generalized into path
assignment problem from any tree. We refer to this as the {\em tree
  path labeling problem of path hypergraphs}. This is analogous to the
interval labeling problem in literature \cite{kklv10} to interval
hypergraphs. In brief, the problem is defined as follows -- given a
hypergraph $\cF$ from universe $U$ (\ie hypergraph vertex set) and a
target tree $T$, does there exist a bijection $\phi$ from $U$ to the
vertices of $T$ such that for each hyperedge when $\phi$ is applied to
its elements it gives a path on $T$.  More formally, the problem
definition is given by \CFTPL.

\begin{problemdef}{\CFTPL}{A hypergraph $\cF$ with vertex set $U$ and
    a tree $T$.}
  Does there exist a set of paths $\cP$ from $T$ and a bijection
  $\cl$~$:$~$\cF \rightarrow \cP$, such that {\FTPL} returns {\bf
    true} on $(\cF, T, \cl)$.
\end{problemdef}

To characterize a feasible TPL, we consider the case where a tree path
labeling is also given as input and we are required to test if the
given labeling is feasible. This is defined by the \FTPL problem.

\begin{problemdef}{\FTPL}{A hypergraph $\cF$ with vertex set $U$, a
    tree $T$, a set of paths $\cP$ from $T$ and a bijection
    $\cl$~$:$~$\cF \rightarrow \cP$.}

  Does there exist a bijection $\phi$~$:$~$U \rightarrow V(T)$ such
  that $\phi$ when applied on any hyperedge in $\cF$ will give
  the path mapped to it by the given tree path labeling $\cl$.\\
  { i.e., $\cl(S) = \{\phi(x) \mid x \in S\}$, for every hyperedge $S
    \in \cF$.}
\end{problemdef}

Section~\ref{sec:feasible} discusses \FTPL and presents an algorithmic
characterization for a feasible TPL.

With respect to computing a feasible TPL, as suggested by \CFTPL
problem, we were unable to discover an efficient algorithm for
it. However, we consider two special cases of the same on special
target trees -- namely, \CFTPLINT and \CFTPLKTREE on intervals and
\kstars, respectively.  Section~\ref{sec:spltargettree} discusses
these problems and their polynomial time solutions.  \CFTPLINT is a
demonstrated to be the known problem of \COP testing. The polynomial
time solution to \CFTPLKTREE is a new result by us.

\begin{problemdef}{\CFTPLINT}{ A hypergraph $\cF$ with vertex set $U$
    and a tree $T$ with maximum degree 2.}

  Does there exist a set of paths $\cP$ from $T$ and a bijection
  $\cl$~$:$~$\cF \rightarrow \cP$, such that {\FTPL} returns {\bf
    true} on $(\cF, T, \cl)$.  
\end{problemdef}

\begin{problemdef}{\CFTPLKTREE}{A hypergraph $\cF$ with vertex set $U$
    such that every hyperedge $S \in \cF$ is of cardinality at most
    $k+2$ and a {\kstar} $T$.}

  Does there exist a set of paths $\cP$ from $T$ and a bijection
  $\cl$~$:$~$\cF \rightarrow \cP$, such that {\FTPL} returns {\bf
    true} on $(\cF, T, \cl)$.
\end{problemdef}

% \CFTPLINT is nothing but the consecutive-ones property testing
% problem.

An algorithm for \CFTPL on general trees which is less efficient than
polynomial time is presented in
Section~\ref{sec:norestraint}. 

\section[Preliminaries]{Preliminaries to new results}
\label{ch:prelims}

This section describes ideas and terminologies necessary in this
chapter. Some of these may have been seen earlier in this document,
but is recalled for the sake of completeness of the chapter.  

A note on attribution -- the machinery for labeling of hypergraphs
has been adopted from \cite{kklv10} and adapted to the needs of our
work. Some classic graph definitions are from \cite{mcg04}.

\subsection{Set systems and Hypergraphs}
\label{sec:setsyshypergraph}

Consider a universe $U$ with $|U| = n$.  The set $\F \subseteq (2^{U}
\setminus \emptyset)$ is a {\em set system} with universe $U$.  The
{\em support of set system} $\F$ denoted by $\supt{\cF}$, is the union
of all the sets in $\F$.
\[supp(\F) = \bigcup_{S \in \F}S\]%
By convention, the set system $\cF$ ``covers'' its universe:
$supp(\cF) = U$. If the sets in $\cF$ are intervals or paths of a
tree, then it is called an interval system or a path system,
respectively.
\par
A set system $\cF$ can also be visualized as a {\em hypergraph}
$\cF_H$ whose vertex set is $U$ and hyperedges are the sets in
$\cF$. This is a known representation for interval systems in
literature \cite{bls99,kklv10}.  We extend this definition here to
path systems. Due to the equivalence of set system and hypergraph as
far as this thesis is concerned, we drop the subscript $_H$ in the
notation and refer to both the structures by $\cF$. Thus hypergraphs
and set systems are synonyms. So are hyperedges and sets.
\par
The notion of {\em hypergraph isomorphism} is central to the work of
this thesis. This is defined by Definition~\ref{def:hisomorph}.

\begin{definition}[Hypergraph isomorphism]
  \label{def:hisomorph}
  Let $\cF'$, $\cF''$ be two hypergraphs.  They are said to be {\em
    isomorphic} to each other, denoted by $\cF' \cong \cF''$, \iff
  there exists a bijection $\phi: supp(\cF') \rightarrow supp(\cF'')$
  such that for all sets $A \subseteq supp(\cF')$, $A$ is a hyperedge
  in $\cF'$ \iff $B$ is a hyperedge in $\cF''$ where $B = \{\phi(x)
  \mid x \in A\}$ (this is also written as $B=\phi(A)$).
\end{definition}

Figure~\ref{fig:hypergraphs} shows an example of hypergraphs and
hypergraph isomorphism.

Recall intersection graph and path graph from
Definition~\ref{def:intersectiongraph} and \ref{def:pathgraph}. The
{\em intersection graph} $\bI(\cF)$ of a hypergraph or set system
$\cF$ is a graph such that its vertex set has a bijection to $\cF$ and
there exists an edge between two vertices \iff their corresponding
hyperedges have a non-empty intersection. A graph $G$ is a path graph
if it is isomorphic to the intersection graph of a path system.

\begin{figure}[htb]
  \centering

  \begin{tabular}[h]{l}

    \begin{tabular}[h]{ll}
      \begin{tabular}[t]{l}
        $\cF_1:$ \\
        \hypergraphi%
      \end{tabular} 
      &     
      \begin{tabular}[t]{l}
        $\cF_2:$\\
        \hypergraphii %        
      \end{tabular}
    \end{tabular}
    \\
    \begin{tabular}[h]{ll}
      \begin{tabular}[t]{l}
        \\ \\
        $\cP$:\\
        \pathhypergraphi %       
      \end{tabular}    
      &     
      \begin{tabular}[t]{l}
        $\cF_3:$\\
        \hypergraphiii %        
      \end{tabular}
    \end{tabular}
    \\  
    \begin{tabular}[h]{l}
      $\cI$:\\
      \intervalhypergraphi %
    \end{tabular}
  \end{tabular}

  \caption[\figtabsize Hypergraphs and set systems]{\figtabsize
    Hypergraphs and set systems. $\cF_1$ and $\cF_2$ are isomorphic
    hypergraphs. The subscript of each element is such that if $\phi$
    is the hypergraph isomorphism, $\phi(x_i)=y_i$. $\cI$ and $\cP$
    are an interval system and a path system respectively which are both
    isomorphic to $\cF_1$ (and by transitivity, isomorphic to $\cF_2$). Here too the
    subscript of elements indicate the isomorphism bijection. $\cF_3$
    is a hypergraph that is not isomorphic to any of the other
    hypergraphs -- moreover, it is one that cannot have a feasible
    path labeling to any tree since it does not have the Helly's
    property \cite[Pr.~4.7]{mcg04} anymore due to the addition of hyperedge $\{x_1,
    x_4\}$. }
  \label{fig:hypergraphs}
\end{figure}


\subsection{Path Labeling and Path Hypergraphs}
\label{sec:pathhypergraph}
The graph $T$ represents a {\em target tree} with same number of
vertices as elements in $U$; $|V(T)|=|U|=n$.  A {\em path system}
$\cP$ is a set system of paths from $T$. 
\[\cP \subseteq \{P \mid P \subseteq V, \text{ } T[P] \text{ is a
  path} \}\] 

A special mapping of paths from target tree $T$ to hyperedges in $\cF$
is called a {\em path labeling}. Definition~\ref{def:pathlabel} gives
details. Note that the term ``tree path labeling'' is synonymous
with ``path labeling'' in this document since we only consider trees and
not general graphs as source of paths.

\begin{definition}[Path labeling of a hypergraph]
  \label{def:pathlabel}
  Consider a hypergraph $\cF$ % with universe $U$
  and a path system $\cP$ from tree $T$ such that $\bI(\cF) \cong
  \bI(\cP)$.  Then the associated bijection $\cl: \cF
  \rightarrow \cP$ due to this isomorphism is called a {\em path
    labeling} of $\cF$ from $T$. The path system $\cP$ is
  alternatively denoted as $\cF^\cl$. The path labeling may also be
  denoted by ordered pairs $(\cF,\cl)$ or $(\cF,\cl,T)$.
\end{definition}
% If the intersection graphs of $\cF$ and $\cP$ are isomorphic,
% $\bI(\cF) \cong \bI(\cP)$, then the associated bijection $\cl: \cF
% \rightarrow \cP$ due to this isomorphism is called a {\em path
%   labeling} of the hypergraph $\cF$.
To elaborate on the phrase ``associated bijection'' in
Definition~\ref{def:pathlabel}, let $\cg: V(\bI(\cF)) \rightarrow
V(\bI(\cP))$ be the given intersection graph isomorphism, where
$V(\bI(\cF)) = \{ v_S \mid S \in \cF\}$ and $V(\bI(\cP)) = \{v_P \mid
P \in \cP\}$. Then the associated bijection $\cl: \cF \rightarrow \cP$
is defined as follows. For all $S' \in \cF$ and $P' \in \cP$, $\cl(S')
= P'$ \iff $\cg(v_{S'}) = v_{P'}$.  Thus, it can be seen that a path
labeling preserves the non-empty intersection property between every
pair of hyperedges in $\cF$.

At this point, it is worth comparing Definition~\ref{def:pathlabel}
with Definition~\ref{def:hisomorph} seen in the previous section.  It
may be noted that there are two kinds of isomorphisms here. One is the
isomorphism of intersection graphs of $\cF$ and $\cP$, i.e. $\bI(\cF)$
and $\bI(\cP)$ and second is the isomorphism between the hypergraphs
$\cF$ and $\cP$ themselves. It is easy to verify that given a path
labeling of hypergraph $\cF$, there need not be a hypergraph
isomorphism involved. In fact, checking if an induced hypergraph
isomorphism results from a given path labeling is the problem of
\CFTPL.  However, a hypergraph isomorphism always induces a path
labeling as shown by the following Definition~\ref{def:inducedpl}.  

\begin{definition}[Hypergraph isomorphism induced path labeling]
  \label{def:inducedpl}
  Let $\cF$ be a hypergraph and $\cP$ be a path system \stt $\cF \cong
  \cP$. Let  $\phi: \supt{\cF} \rightarrow \supt{\cP}$ be this hypergraph
  isomorphism function. % described in
  % Definition~\ref{def:pathhypergraph}.
  Then there is an {\em induced path labeling} % denoted by $\cl_\phi:
%   \cF \rightarrow \cP$ 
  denoted by $\cp_\phi: \cF \rightarrow \cP$
  of the hypergraph \stt % $\cl_\phi(S) = \phi(S)$
  $\cp_\phi(S) = \phi(S)$
  (see Definition~\ref{def:hisomorph}) for all $S \in \cF$.  
\end{definition}

Combining the ideas of path labeling, hypergraph isomorphism and its
induced path labeling we now define {\em feasiblity} of a path
labeling in Definition~\ref{def:feasibletpl}.

\begin{definition}[Feasible path labeling]
  \label{def:feasibletpl}
  Let $\cF$ be a hypergraph and $(\cF, \cl)$ be a path
  labeling. $(\cF, \cl)$ is called a {\em feasible path labeling} if
  the following conditions hold.
  \begin{itemize}
  \item $\cF \cong \cF^\cl$
  \item if the above hypergraph isomorphism is $\phi: supp(\cF)
    \rightarrow supp(\cF^\cl)$, then $\cp_\phi = \cl$
  \end{itemize}


  This isomorphism $\phi$ is called the \textbf{feasibility hypergraph
  isomorphism} or feasibility isomorphism.
\end{definition}

One of the problems solved in this thesis \FTPL characterizes
feasibile tree path labeling.

Now we will see the definition of a {\em path hypergraph} which is a
simple idea extended from interval hypergraphs in \cite{kklv10}. 

\begin{definition}[Path hypergraph]
  \label{def:pathhypergraph}
  Let $\cF$ be a set system. $\cF$ is called a {\em path hypergraph}
  if there exists a target tree $T$ and a path system $\cP$ from $T$
  \stt $\cF \cong \cP$. If $\cF$ is thus a path hypergraph, $\cP$ is
  called {\em path representation} of $\cF$.
\end{definition}

In other words, if there exists a feasible tree path labeling for a
given hypergraph, it is a path hypergraph.


%% XXXXXX
% The subset of the path labeling that
%   maps elements of the universe to paths that contain only a leaf the
%   target tree is  known as a {\em leaf labeling}.
%   \ie if the target tree has the set of $k$ leaves $L = \{v_i, i \in
%   [k]\}$, then 
% $\cl': \rightarrow U' \rightarrow L$ is a leaf labeling where $U'
% \subseteq U$, $|U'| = k$.
%   $\cL_0 = \{ (x_i,v_i) \mid x_i \in
%   U, v_i \in T, x_i \ne x_j, v_i \ne v_j, i \ne j, i,j \in [k] \}$
%   where $k$ is the number of leaves in $T$

\subsection{Overlap Graphs and Marginal Hyperedges}
\label{sec:overlapmarginal}
Recall the notion of {\em overlap} from
Definition~\ref{def:setsystem}.  Two hyperedges $S$ and $S'$ are said
to overlap, denoted by $S \overlap S'$, if they have a non-empty
intersection and neither is contained in the other.

An {\em overlap graph}  $\bO(\cF)$ of a hypergraph $\cF$ is a graph
such that its vertex set has a bijection to $\cF$ and there exists an
edge between two of its vertices \iff their corresponding hyperedges
overlap.  Thus $\bO(\cF)$ is a spanning subgraph of $\bI(\cF)$ and not
necessarily connected. Each connected component of $\bO(\cF)$ is
called an {\em overlap component}.

A hyperedge $S \in \cF$ is called {\em marginal} if for all $S'
\overlap S$, the overlaps $S \cap S'$ form a single inclusion chain
\cite{kklv10} (see Definition\ref{def:poset}). Additionally, if $S$ is
such that it is contained in no other marginal hyperedge in $\cF$,
then it is called {\em super-marginal}.

\subsection{Miscellaneous}
\label{sec:miscprelim}
A {\em star} graph is a complete bipartite graph $K_{1,\,p}$ (which is
clearly a tree with $p$ leaves). The vertex with maximum degree in a
star is called its {\em center} and the edges are called {\em
  rays}. This thesis is interested in a star-like graph which is
defined in Definition~\ref{def:ksubstar}

\begin{definition}[$k$-subdivided star]
  \label{def:ksubstar}
  A {\em $k$-subdivided star} is a star with all its rays subdivided
  exactly $k$ times. A {\em ray} of a $k$-subdivided star is the path
  from the center vertex to a leaf. It is clear that all rays of a
  $k$-subdivided star are of length $k+2$.
\end{definition}


% A path assignment $\A$ to $\F$ is defined as a set assignment
% where second universe is the vertex set $V$ of a given tree $T$ and
% every second subset in the ordered pairs is a path in this
% tree. Formally, the definition is as follows. 
% \begin{align*}
%   \A = \{ (S_i,P_i) \mid S_i \in \F, P_i \subseteq V \text{
%     s.t. }T[P_i] \text{ is a path, } i \in I \}
% \end{align*}
% In other words, $P_i$ is the path on the tree $T$ assigned to $S_i$ in
% $\A$. As mentioned before for set systems, the paths cover the whole
% tree, i.e. $\bigcup_{i \in I}P_i = V$ \\

% Generalizing the definition of { feasibility} in cite{nsnrs09} to
% a set assignment, a path assignment $\A$ is defined to be {
%   feasible} if there exists a bijection defined as follows.
% \begin{align}
%   \sigma: U \rightarrow V(T), \text{ such that }\sigma(S_i) = P_i
%   \text{ for all } i \in I, \sigma \text{ is a bijection}
%   \label{eq:stf}
% \end{align}

\begin{definition}[In-tree]
An {\em in-tree} is a directed rooted tree in which all edges are
directed toward to the root.  
\end{definition}
In-trees are used in Section~\ref{sec:norestraint} which describes our
(albeit non-polynomial time) solution to \CFTPL problem.

Finally, note that as a convention in this thesis, the set $I$
represents the index set $[m]$ or $[n]$. If index $i$ is used without further
qualification, it is intended that $i \in I$.

\section[Characterization of FTPL]{Characterization of Feasible Tree
  Path Labeling}
\label{sec:feasible}

In this section we discuss the \FTPL problem introduced in
Section~\ref{sec:myresearchintro} and give a set cardinality based
characterization for it.


For this characterization, we generalize the notion of the ICPIA
\cite{nsnrs09}.  We show that for a given hypergraph $\cF$ with
universe $U$, a target tree $T$, and path labeling from $T$ to $\cF$, there
is a feasible bijection between $U$ and $V(T)$ \iff all intersection
cardinalities among any three sets (not necessarily distinct) is same
as the intersection cardinality of the paths assigned to them.  This
characterization is proved constructively and the algorithm outputs a
feasible bijection between $U$ and $V(T)$.

We now introduce a special kind of path labeling called {\em
  Intersection Cardinality Preserving Path Labeling (ICPPL)} in
Definition~\ref{def:icppl}.

\begin{definition}
  \label{def:icppl}
  Consider a path labeling $(\cF, \cl)$ on the given tree $T$. We call
  $(\cF, \cl)$ an {\em Intersection Cardinality Preserving Path
    Labeling (ICPPL)} if it has the following properties.
  \par
  \parbox{\linewidth}{%
    \hangindent \defindent%
    \begin{enumerate}[i. ] %{(\icpplpr\ }
      \singlespacing
    \item \label{pr:i} $|S| = |\cl(S)|$ for all $S \in \cF$
    \item \label{pr:ii}$|S_1 \cap S_2| = |\cl(S_1) \cap \cl(S_2)|$ for
    all distinct $S_1, S_2 \in \cF$
    \item \label{pr:iii}$|S_1 \cap S_2 \cap S_3| = |\cl(S_1) \cap
    \cl(S_2) \cap \cl(S_3)|$ for all distinct $S_1, S_2, S_3 \in \cF$
    \end{enumerate}
  }
\end{definition}


In the remaining part of this section we show that $(\cF, \cl)$ is
feasible if and only if it is an ICPPL.
Algorithm~\ref{al:icppl-find-isomorph} takes $(\cF, \cl)$ as input and
computes the feasibility bijection if it is feasible or else reports
failure. This algorithm recursively does two levels of filtering of
$(\cF, \cl)$ to make it simpler in terms of set intersections while
retaining a non-empty subset of isomorphisms, if any, between $\cF$
and $\cF^\cl$. These two filters are \filteri in
Algorithm~\ref{al:filterone} and \filterii in
Algorithm~\ref{al:filtertwo}.
% One direction of this claim isclear: that if a path labeling is
% feasible, then all intersection cardinalities are preserved,
% i.e. the path labeling is an ICPPL. Algorithm~\ref{al:filterone}
% \annote{has no premature exit condition hence any input will go
%   through it}{Prove that the filtered sets has ICPPL \iff input PL
%   has ICPPL?}. Algorithm~\ref{al:filtertwo} has an exit condition at
% line~\ref{xempty}. It can be easily verified that $X$ cannot be
% empty if $\cl$ is a feasible path labeling. The reason is that a
% feasible path labeling has an associated bijection between
% $supp(\cF)$ and $V(T)$ \remove{i.e. $supp(\cF^{\cl})$} such that the
% sets map to paths, ``preserving'' the path labeling.  The rest of
% the section is devoted to constructively proving that it is
% sufficient for a path labeling to be an ICPPL and pass the two
% filtering algorithms.  To describe in brief, the constructive
% approaches refine an ICPPL iteratively, such that at the end of each
% iteration we have a ``filtered'' path labeling, and finally we have
% a path labeling that defines a family of bijections from $supp(\cF)$
% to $V(T)$\remove{ i.e. $supp(\cF^{\cl})$}.

First, we present Algorithm~\ref{al:filterone} which describes \filteri, and prove its correctness.  This algorithm refines the
path labeling by processing pairs of paths in $\cF^\cl$ that share a
leaf until no two paths in the new path labeling share any leaf.

\begin{algorithm}[h]
  \caption{Refine ICPPL {\tt \filteri($\cF, \cl, T$)}}
  \label{al:filterone} % {perms}
  \begin{algorithmic}[\lndisplay]
    \STATE $\cF_0 \assign \cF$, $\cl_0(S) \assign \cl(S)$ for all $S \in \cF_0$\\
    \STATE $j \assign 1$\\
    \WHILE {there is $S_1, S_2 \in \cF_{j-1}$ such that
      $\cl_{j-1}(S_1)$ and $\cl_{j-1}(S_2)$ have a common leaf in
      $T$}\label{shareleaf} \STATE $\cF_j \assign (\cF_{j-1} \setminus
    \{S_1, S_2\}) \cup \{S_1 \cap S_2, S_1 \setminus S_2, S_2
    \setminus S_1 \}$ \label{setbreak} \COMMENT {Remove $S_1$, $S_2$
      and add the ``filtered'' sets} \STATE {\bf for} every $S \in
    \cF_{j-1}$ s.t. $S \ne S_1$ and $S \ne
    S_2$ {\bf do} $\cl_j(S) \assign \cl_{j-1}(S)$ {\bf end for}\\

    \STATE $\cl_j(S_1 \cap S_2) \assign \cl_{j-1}(S_1) \cap
    \cl_{j-1}(S_2)$ \COMMENT {Carry forward the path labeling for all
      existing sets other than $S_1$, $S_2$} \STATE $\cl_j(S_1
    \setminus S_2) \assign \cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)$
    \COMMENT {Define path labeling for new sets} \STATE $\cl_j(S_2
    \setminus S_1) \assign \cl_{j-1}(S_2) \setminus \cl_{j-1}(S_1)$

%     \IF{$(\cF_j, \cl_j)$ does not satisfy (\icpplpr~\ref{pr:iii}) of
%       ICPPL}
%     \label{ln:3waycheck}
%     \STATE {\bf exit} \label{ln:exit1} \\
%     \ENDIF

    \STATE $j \assign j+1$\\
    \ENDWHILE
    \STATE $\cF' \assign \cF_j$, $\cl' \assign \cl_j$\\
    \RETURN $(\cF', \cl')$
  \end{algorithmic}
\end{algorithm}

In order to prove the correctness of Algorithm~\ref{al:filterone}, we
present a few lemma which are useful in subsequent arguments.

The first two lemma below are from results in \cite{nsnrs09}.  They
have been reworded to use the terminology adopted in this
thesis. Lemma~\ref{lem:intersection-cardinality} shows that the
preservation of pairwise intersection cardinality in an interval
assignment is sufficient to preserve three way intersection
cardinality. Lemma~\ref{lem:icpia} shows that if a path labeling (i)
has target tree as a path \ie it is an interval labeling, and (ii) it
preserves pairwise intersection cardinalities \ie it is an ICPIA,
then it is a feasible path labeling.

\begin{lemma}[{\cite[Lem.~1]{nsnrs09}}]
  \label{lem:intersection-cardinality} 
  Let $P$ be a path, $S_1, S_2, S_3$ be 3 sets, and $T_1, T_2, T_3$ be
  paths from $P$, such that $|S_i \cap S_j |=|T_i \cap T_j|, 1 \leq
  i,j \leq 3$.  Then, $|S_1 \cap S_2 \cap S_3| = |T_1 \cap T_2 \cap
  T_3|$.
\end{lemma}
\begin{lemma}[{\cite[Th.~2]{nsnrs09}}]
  \label{lem:icpia} 
  A path labeling $(\cF, \cl)$ with target tree $T$ as a path is
  feasible iff it is an ICPIA.
\end{lemma}

Next, we see Lemma~\ref{lem:setminuscard} which is a direct
consequence of Definition~\ref{def:icppl} and is analogous to
\cite[Cor.~1]{nsnrs09}.

\begin{lemma}
  \label{lem:setminuscard}
  If $\cl$ is an \ICPPL, and $S_1, S_2, S_3 \in \cF$, then $|S_1 \cap
  (S_2 \setminus S_3)| = |\cl(S_1) \cap (\cl(S_2) \setminus
  \cl(S_3))|$.
\end{lemma}
\begin{proof}\thesisspacing%[Proof of Lemma~\ref{lem:setminuscard}]
  Let $P_i = \cl(S_i)$, for all $1 \le i \le 3$.  $|S_1 \cap (S_2
  \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| = |S_1 \cap S_2| -
  |S_1 \cap S_2 \cap S_3|$. Due to properties (ii) and (iii) of ICPPL,
  $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| = |P_1 \cap P_2| - |P_1
  \cap P_2 \cap P_3| = |(P_1 \cap P_2) \setminus P_3| = |P_1 \cap (P_2
  \setminus P_3)|$. %\qed
\end{proof}

For interval labeling, \cite{nsnrs09} shows that if it is an ICPIA \ie
pairwise intersection cardinalities are preserved, then $d$-way
intersection cardinalities are preseved for $2 < d < n$. Thus, in a
way, pairwise intersections ``capture'' feasibility of an interval
labeling. In the same vein, the following lemma indicates that
three-way intersection cardinality ``captures'' $d$-way intersection
cardinalities for $3 < d < n$ in a tree path labeling.

\begin{lemma}
  \label{lem:4-way}
  Let $(\cF, \cl)$ be an \ICPPL and $\cl(S_i)=P_i$, $S_i \in \cF$, $1
  \leq i \leq 4$.  Then, $|\cap_{i=1}^4 S_i| = |\cap_{i=1}^4 P_i|$.
\end{lemma}
\begin{proof}
  Consider the sets $S_2 \cap S_1$, $S_3 \cap S_1$, and $S_4 \cap
  S_1$, and their images $P_2 \cap P_1$, $P_3 \cap P_1$, and $P_4 \cap
  P_1$ respectively.  It is clear that this path labeling preserves
  pairwise intersection cardinalities.  In this case, it is clear that
  the 3 sets are assigned paths in the path $P_1$.  Now by applying
  Lemma~\ref{lem:intersection-cardinality}, it follows that
  $|\cap_{i=1}^4 S_i| =| \cap_{i=1}^4 P_i|$.
\end{proof}
\begin{corollary} 
  \label{corr:4-way} 
  Let $(\cF, \cl)$ be an \ICPPL and $\cl(S_i)=P_i$, $S_i \in \cF$, $1
  \leq i \leq 4$. If $P_i$, $1
  \leq i \leq 4$ are such that $P_1 \cap P_2$, $P_1
  \setminus P_2$, $P_2 \setminus P_1$ are also paths, then:
  \begin{align*}
   |(S_1 \setminus S_2) \cap S_3 \cap S_4| &= |(P_1 \setminus P_2) \cap P_3 \cap P_4|\\
   |(S_2 \setminus S_1) \cap S_3 \cap S_4| &= |(P_2 \setminus P_1) \cap P_3 \cap P_4| 
  \end{align*}
\end{corollary}
\begin{proof}
  It is clear that $|(P_1 \setminus P_2) \cap P_3 \cap P_4| =
  |\displaystyle \cap_{i=1}^4 P_i| - | P_2 \cap P_3 \cap P_4|$.  Since
  we have an ICPPL, from Lemma~\ref{lem:4-way}, it follows that the
  intersection cardinalities are preserved.
\end{proof}
\begin{lemma}
  \label{lem:priv-card}
  Let $(\cF, \cl)$ be an \ICPPL and $\cl(S) = P$ for some $S \in \cF$.  If sets
  $S_{priv}$ and $P_{priv}$ contain only those elements of $S$ and $P$
  that occur in no set other than $S$ and $P$, respectively, then
  $|S_{priv}|=|P_{priv}|$.
\end{lemma}
\begin{proof}
  Consider the set system $ \cF' = \{S_i \cap S \mid S_i \in \cF, i
  \in [n]\}$ and path labeling $\cl'(S_i \cap S) = P_i \cap P$.  Since
  $(\cF, \cl)$ is an \ICPPL, it can be easily verified that $(\cF',
  \cl')$ is an ICPIA on path (interval) $P$.  Let $S_{two}$ and
  $P_{two}$ be the elements of $S$ and $P$ which are in one {\em
    other} set and path, respectively \ie $S_{two} = S \cap (\cup_{S_i
    \ne S} S_i)$ and $P_{two}$ is defined analogously. It may be noted
  that $S_{two} = \supt{\cF'}$ and $P_{two} = \supt{\cF'^{\cl'}}$.
  From Lemma~\ref{lem:icpia} it follows that there is a bijection
  $\phi$ from $S_{two}$ to $P_{two}$ such that for each $i$, the image
  of $S_i \cap S$ under $\phi$ is $P_i \cap P$ (definition of
  feasibility).  Moreover, this means $|S_{two}| = |P_{two}|$. By
  definition, $S_{priv} = S \setminus S_{two}$ and $P_{priv} = P \setminus P_{two}$.
  Thus $|S_{priv}| = |S \setminus S_{two}| = |P \setminus
  P_{two}|=|P_{priv}|$.  
\end{proof}


Now we will prove the effectiveness of Algorithm~\ref{al:filterone}.
Lemma~\ref{lem:feasible} proves that \filteri does not destroy
the feasibility of the input, if it is indeed feasible. Following
this, Lemma~\ref{lem:invar1} and Lemma~\ref{lem:noexit1} show that if
the input is an ICPPL the result of \filteri is also an ICPPL
and they both have the same set of feasibility hypergraph
isomorphisms.

\begin{lemma}
  \label{lem:feasible}
  In Algorithm~\ref{al:filterone}, if input $(\cF, \cl)$ is a feasible path
  labeling then at the end of $j$th iteration of the {\bf while}
  loop, $j \ge 0$, $(\cF_j, \cl_j)$ is a feasible path labeling.
\end{lemma}
\begin{proof}\thesisspacing
  We will prove this by mathematical induction on the number of
  iterations. The base case $(\cF_0, \cl_0)$ is feasible since it is
  the input itself which is given to be feasible. Assume the lemma is
  true till $j-1$th iteration \ie every hypergraph isomorphism $\phi:
  supp\left(\cF_{j-1}\right) \rightarrow V\left(T \right)$ that
  defines $(\cF, \cl)$'s feasibility, is such that the induced path
  labeling on $\cF_{j-1}$, say denoted by $\cp_{\phi[{\cF_{j-1}}]}$,
  is equal to $\cl_{j-1}$.
% Note that any hypergraph isomorphism of
% $\cF$ (say, one that defines the feasibility of $(\cF,\cl)$) can be
% ``projected'' to $\cF_{j-1}$ since their supports are equal. If $\phi$
% is a hypergraph isomorphism of to $(\cF, \cl)$, then 
  We will prove that $\phi$ is also the bijection that makes $(\cF_j,
  \cl_j)$ feasible. Note that $supp(\cF_{j-1}) = supp(\cF_{j})$ since
  the new sets in $\cF_j$ are created from basic set operations to the
  sets in $\cF_{j-1}$ adding or removing no elements. For the same
  reason and $\phi$ being a bijection, it is clear that when applying
  the $\phi$-induced path labeling on $\cF_j$, $
  \cp_{\phi[{\cF_{j}}]}(S_1 \setminus S_2) =
  \cp_{\phi[{\cF_{j-1}}]}(S_1) \setminus
  \cp_{\phi[{\cF_{j-1}}]}(S_2)$. Now observe that $ \cl_j(S_1
  \setminus S_2) = \cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2) =
  \cp_{\phi[{\cF_{j-1}}]}(S_1) \setminus
  \cp_{\phi[{\cF_{j-1}}]}(S_2)$. Thus the induced path labeling
  $\cp_{\phi[{\cF_{j}}]} = \cl_{j}$.  %\qed
\end{proof}

\begin{lemma}
  \label{lem:invar1} Given that the input to Algorithm~\ref{al:filterone} is
  an ICPPL, at the end of $j$th iteration, $j \ge 0$, of the {\bf
    while} loop, the following invariants are maintained.
  \begin{enumerate}[I {\ }] %\vspace{\topshrink}
    \singlespacing
  \item $\cl_j(R)$ is a path in $T$, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \ \ \ for all $R \in \cF_j$%\vspace{\topshrink}
  \item $|R| = |\cl_j(R)|$, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for all $R \in
    \cF_j$%\vspace{\topshrink}
  \item $|R \cap R'| = |\cl_j(R) \cap \cl_j(R')|$, \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \ \ \ for all $R, R' \in \cF_j$%\vspace{\topshrink}
  \item $|R \cap R' \cap R''|=|\cl_j(R) \cap \cl_j(R') \cap
    \cl_j(R'')|$, \ \ \ for all $R, R', R'' \in \cF_j$
  \end{enumerate}
\end{lemma}
\begin{proof}\thesisspacing
  Proof is by induction on the number of iterations, $j$. In this
  proof, the term ``new sets'' will refer to the sets added to $\cF_j$
  in $j$th iteration in line~\ref{setbreak} of Algorithm~\ref{al:filterone},
  $S_1 \cap S_2, S_1 \setminus S_2, S_2 \setminus S_1$ and its images
  in $\cl_j$ where $\cl_{j-1}(S_1)$
  and $\cl_{j-1}(S_2)$ intersect and share a leaf.
  The invariants are true in the base case $(\cF_0, \cl_0)$, since it
  is the input ICPPL.  Assume the lemma is true till the $j-1$th
  iteration. Let us consider the possible cases for each of the above
  invariants for the $j$th iteration.
  
  \begin{enumerate}[\xbullet]
  \item {\em Invariant} I/II
    \begin{enumerate}[{I/II}a $|$] % \textbullet
    \item {\em $R$ is not a new set.} It is in $\cF_{j-1}$. Thus
      trivially true by induction hypothesis.
    \item {\em $R$ is a new set.} If $R$ is in $\cF_{j}$ and not in
      $\cF_{j-1}$, then it must be one of the new sets added in
      $\cF_j$. In this case, it is clear that for each new set, the
      image under $\cl_j$ is a path since by definition the chosen
      sets $S_1$, $S_2$ are from $\cF_{j-1}$ and due to the while loop
      condition, $\cl_{j-1}(S_1)$, $\cl_{j-1}(S_2)$ have a
      common leaf. Thus invariant I is proven.\\
      Moreover, due to induction hypothesis of invariant III and the
      definition of $l_j$ in terms of $l_{j-1}$, invariant II is
      indeed true in the $j$th iteration for any of the new sets.  If
      $R = S_1 \cap S_2$, $|R| = |S_1 \cap S_2| = |\cl_{j-1}(S_1) \cap
      \cl_{j-1}(S_2)| = |\cl_j(S_1 \cap S_2)| = |\cl_j(R)|$.  If $R =
      S_1 \setminus S_2$, $|R| = |S_1 \setminus S_2| = |S_1| - |S_1
      \cap S_2| = |\cl_{j-1}(S_1)| - |\cl_{j-1}(S_1) \cap
      \cl_{j-1}(S_2)| = |\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)| =
      |\cl_j(S_1 \setminus S_2)|
      = |\cl_j(R)|$. Similarly if $R = S_2 \setminus S_1$.\\
    \end{enumerate}
  \item {\em Invariant} III
    \begin{enumerate}[{III}a $|$]
    \item {\em $R$ and $R'$ are not new sets.} It is in
      $\cF_{j-1}$. Thus trivially true by induction hypothesis.
    \item {\em Only one, say $R$, is a new set.} Due to invariant IV
      induction hypothesis, Lemma~\ref{lem:setminuscard} and
      definition of $\cl_j$, it follows that invariant III is true no
      matter which of the new sets $R$ is equal to. If $R = S_1 \cap
      S_2$, $|R \cap R'| = |S_1 \cap S_2 \cap R'| = |\cl_{j-1}(S_1)
      \cap \cl_{j-1}(S_2) \cap \cl_{j-1}(R')| = |\cl_j(S_1 \cap S_2)
      \cap \cl_j(R')| = |\cl_j(R) \cap \cl_j(R')|$.  If $R = S_1
      \setminus S_2$, $|R \cap R'| = |(S_1 \setminus S_2) \cap R'| =
      |(\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)) \cap \cl_{j-1}(R')| =
      |\cl_{j}(S_1 \cap S_2) \cap \cl_{j}(R')| = |\cl_{j}(R) \cap
      \cl_{j}(R')|$. Similarly, if $R = S_2 \setminus
      S_1$. Note $R'$ is not a new set.\\

    \item {\em $R$ and $R'$ are new sets.} By definition, the new sets
      and their path images in path label $\cl_j$ are disjoint so $|R
      \cap R'| = |\cl_j(R) \cap \cl_j(R)| = 0$. Thus case proven.
    \end{enumerate}
  \item {\em Invariant} IV

    This invariant is ensured at the end of every iteration due to
    Lemma~\ref{lem:4-way} and Corollary~\ref{corr:4-way}.
   % \begin{enumerate} [{Case 3.}1:]
    % \item {\em $R$, $R'$ and $R''$ are not new sets.} Trivially true
    %   by induction hypothesis.
    % \item {\em Only one, say $R$, is a new set.}  If $R = S_1 \cap
    %   S_2$, from Lemma~\ref{lem:fourpaths} and invariant III
    %   hypothesis, this case is proven. Similarly if $R$ is any of
    %   the other new sets, the case is proven by also using Lemma
    %   ~\ref{lem:setminuscard}.
    % \item {\em At least two of $R, R', R''$ are new sets.}  The new
    %   sets are disjoint hence this case is vacuously true.
    % \end{enumerate}
  \end{enumerate} 
\end{proof}

\begin{lemma}
  \label{lem:noexit1}
  If the input ICPPL $(\cF, \cl)$ to Algorithm~\ref{al:filterone} is
  feasible, then the set of hypergraph isomorphism functions that
  defines $(\cF, \cl)$'s feasibility is the same as the set that
  defines $(\cF_j, \cl_j)$'s feasibility, if any.%   Secondly, for any
%   iteration $j > 0$ of the {\em \bf while} loop, the {\em \bf exit}
%   statement in line~\ref{ln:exit1} will not execute.
\end{lemma}
\begin{proof}\thesisspacing
  Since $(\cF,\cl)$ is feasible, by Lemma~\ref{lem:feasible}
  $(\cF_j,\cl_j)$ for every iteration $j > 0$ is
  feasible.  % Therefore,
  % every hypergraph isomorphism $\phi: supp(\cF) \rightarrow V(T)$
  % that induces $\cl$ on $\cF$ also induces $\cl_{j-1}$ and $\cl_{j}$
  % on $\cF_{j-1}$ and $\cF_{j}$ respectively, i.e.,
  % $\cl_{\phi[\cF_{j-1}]} = \cl_{j-1}$ and $\cl_{\phi[\cF_j]} =
  % \cl_j$. Thus it can be seen that for all $x \in supp(\cF)$, for
  % all $v \in V(T)$ the following hold true.
  Also, every hypergraph isomorphism $\phi: supp(\cF) \rightarrow
  V(T)$ that induces $\cl$ on $\cF$ also induces $\cl_{j}$ on
  $\cF_{j}$, i.e., $\cl_{\phi[\cF_j]} = \cl_j$. Thus it can be seen
  that for all $x \in supp(\cF)$, for all $v \in V(T)$, if $(x,v) \in
  \phi$ then $v \in \cl_{j}(S)$ for all $S \in \cF_{j}$ such that $x
  \in S$.
  % the following hold true.
  % \begin{enumerate}[i. ]
  % \item If $(x,v) \in \phi$ then $v \in \cl_{j-1}(S)$ for all $S \in
  %   \cF_{j-1}$ such that $x \in S$.
  % \item If $(x,v) \in \phi$ then $v \in \cl_{j}(S)$ for all $S \in
  %   \cF_{j}$ such that $x \in S$
  % \end{enumerate}
  In other words, \filteri outputs a filtered path labeling that
  ``preserves''
  hypergraph isomorphisms of the original path labeling.
%   Secondly, line~\ref{ln:exit1} will execute \iff the exit condition in
%   line~\ref{ln:3waycheck}, i.e. failure of three way intersection
%   preservation, becomes true in any iteration of the {\em \bf while}
%   loop.  Due to Lemma~\ref{lem:invar1} Invariant IV, the exit
%   condition does not occur if the input is a feasible ICPPL.%\qed
  % such that $\phi(x) = v$ where $v$ is the leaf considered in the
  % first iterations of while. Clearly, $\phi$ is a renaming of
  % vertices in hypergraph $\cF$ to those in hypergraph
  % $\cF^\cl$. Thus the following facts can be observed in every
  % iteration of the loop.
  % \begin{enumerate}[\hspace{2mm}i. ] \vspace{\topshrink}
  % \item all intersection cardinalities are preserved in this path
  %   labeling \vspace{\topshrink}
  % \item element $x$ is exclusive in a hyperedge in $\cF$ since $v$
  %   is exclusive in a hyperedge in $\cF^\cl$.
  % \end{enumerate}
  % Thus the exit condition is never rendered true after $x$ and $v$
  % are removed from their respective hyperedges. %\qed

  % \noindent
  % This proof uses mathematical induction on the number of iterations
  % $j$, $j \ge 0$, of the loop that executed without exiting. The
  % base case, $j = 0$ is obviously true since the input is an ICPPL
  % and the exit condition cannot hold true due to ICPPL property
  % (iii).  Assume the algorithm executes till the end of $j-1$th
  % iteration without exiting at line ~\ref{ln:3waycheck}. Consider
  % the $j$th iteration. From Lemma ~\ref{lem:feasible} we know that
  % $(\cF_j, \cl_j)$ and $(\cF_{j-1}, \cl_{j-1})$ are
  % feasible\remove[AS]{and from the proof in lemma lem:invar1 we know
  %   that $(\cF_{j-1}, \cl_{j-1})$ satisfies all the invariants
  %   defined in the lemma}.  Thus there exists a bijection $\phi:
  % supp(\cF) \rightarrow V(T)$ such that the induced path
  %   % labeling on $\cF_{j-1}$ $\cl_{\phi[\cF_{j-1}]} = \cl_{j-1}$.
  % labeling on $\cF_{j}$, $\cl_{\phi[\cF_{j}]}$ and on $\cF_{j-1}$,
  % $\cl_{\phi[\cF_{j-1}]}$ are equal to $\cl_{j}$ and $\cl_{j-1}$
  % respectively.  We need to prove that for any $R, R', R'' \in
  % \cF_{j}$, $|R \cap R' \cap R''| = |\cl_j(R) \cap \cl_j(R') \cap
  % \cl_j(R'')|$.  The following are the possible cases that could
  % arise. From argument above, $|\cl_j(R) \cap \cl_j(R') \cap
  % \cl_j(R'')| = |\cl_{\phi[\cF_{j}]}(R) \cap \cl_{\phi[\cF_{j}]}
  % (R') \cap \cl_{\phi[\cF_{j}]} (R'')|$

  % \begin{enumerate}[a $|$]
  % \item {\em None of the sets are new. $R, R', R'' \in \cF_{j-1}$.}
  %   We know $(\cF_{j-1}, \cl_{j-1})$ is feasible. Thus $|R \cap R'
  %   \cap R''| = |\cl_{j-1}(R) \cap \cl_{j-1}(R') \cap
  %   \cl_{j-1}(R'')| = |\cl_{j}(R) \cap \cl_{j}(R') \cap
  %   \cl_{j}(R'')|$.
  % \item {\em Only one, say $R$, is a new set.}  Let $R = S_1 \cap
  %   S_2$ ($S_1, S_2$ are defined in the proof of lemma
  %   ~\ref{lem:invar1}). Now we have $|R \cap R' \cap R''| = |S_1
  %   \cap S_2 \cap R' \cap R''| = |\cl_{j-1}(S_1) \cap \cl_{j-1}(S_2)
  %   \cap \cl_{j-1}(R') \cap \cl_{j-1}(R'')| = |\cl_{j}(R) \cap
  %   \cl_{j}(R') \cap \cl_{j}(R'')|$. Thus proven. If $R$ is any of
  %   the other new sets, the same claim can be verified using lemma
  %   ~\ref{lem:setminuscard}.
  %     % \item []{\bf Case 3:}
  % \item {\em At least two of $R, R', R''$ are new sets.}  The new
  %   sets are disjoint hence this case is vacuously true.
  % \end{enumerate}
  % %\qed \tnote[E2]{remove the induction proof. just text saying x and
  %   v are exclusive in these sets therefore the intersection
  %   cardinalities don't change thus all invariants are still true}
\end{proof}

As a result of \filteri each leaf $v$ in $T$ is such that there
is exactly one set in $\cF$ with $v$ as a vertex in the path assigned
to it.  \filterii, in Algorithm~\ref{al:filtertwo}, identifies
elements in $supp(\cF)$ whose images are leaves in a hypergraph
isomorphism if one exists.  Let $S \in \cF$ be such that $\cl(S)$ is a
path with leaf and $v \in V(T)$ is the unique leaf incident on it.  We
define a new path labeling $\cl_{new}$ such that $\cl_{new}(\set{x}) =
\set{v}$ where $x$ an arbitrary element from $S \setminus \bigcup_{\hS
  \ne S} \hS$. In other words, $x$ is an element present in no other
set in $\cF$ except $S$. This is intuitive since $v$ is present in no
other path image under $\cl$ other than $\cl(S)$.  The element $x$ and
leaf $v$ are then removed from the set $S$ and path $\cl(S)$
respectively. After doing this for all leaves in $T$, all path images
in the new path labeling $\cl_{new}$ except leaf labels (a path that
has only a leaf is called the {\em leaf label} for the corresponding
single element hyperedge or set) are paths from a new pruned tree $T_0
= T \setminus \{v \mid v \text{ is a leaf in }
T\}$. Algorithm~\ref{al:filtertwo} is now presented with details.


%\temptext{ --- WG11 begin --- } %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{lemma}
%   \label{lem:setminuscard}
%   If $\cA$ is an ICPPL, and $(S_1, P_1),(S_2, P_2),(S_3, P_3) \in
%   \cA$, then $|S_1 \cap (S_2 \setminus S_3)| = |P_1 \cap (P_2
%   \setminus P_3)|$.
% \end{lemma}
% \begin{proof}\thesisspacing
%   $|S_1 \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| =
%   |S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to conditions (ii)
%   and (iii) of ICPPL, $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| = |P_1
%   \cap P_2| - |P_1 \cap P_2 \cap P_3| = |(P_1 \cap P_2) \setminus P_3|
%   = |P_1 \cap (P_2 \setminus P_3)|$. Thus lemma is proven. %\qed
% \end{proof}



% \begin{lemma}
%   \label{lem:invar1}
%   In Algorithm \ref{al:filterone}, at the end of $j$th iteration, $j \ge 0$,
%   of the while loop of Algorithm \ref{al:filterone}, the following invariants
%   are maintained.
%   \begin{itemize}
%   \item {\em Invariant I:} $Q$ is a path in $T$ for each $(P,Q) \in
%     \Pi_j$
%   \item {\em Invariant II:} $|P|=|Q|$ for each $(P,Q) \in \Pi_j$
%   \item {\em Invariant III:} For any two $(P,Q), (P',Q') \in \Pi_j$,
%     $|P' \cap P''|=|Q' \cap Q''|$.
%   \item {\em Invariant IV:} For any three, $(P',Q'), (P'',Q''), (P, Q)
%     \in \Pi_j$, $|P' \cap P'' \cap P|=|Q' \cap Q'' \cap Q|$.
%   \end{itemize}
% \end{lemma}
% \begin{proof}\thesisspacing
%   Proof is by induction on the number of iterations, $j$. In the rest
%   of the proof, the term ``new sets'' will refer to the new sets added
%   in $j$th iteration as defined in line \ref{setbreak} of Algorithm
%   \ref{al:filterone}, i.e. the following three assignment pairs for some
%   $(P_1,Q_1), (P_2,Q_2) \in \Pi_{j-1}$ where $Q_1$ and $Q_2$ intersect
%   and share a leaf: $(P_1 \cap P_2, Q_1 \cap Q_2)$, or $(P_1 \setminus
%   P_2, Q_1 \setminus Q_2)$, or $(P_2 \setminus P_1, Q_2
%   \setminus Q_1)$.\\
%   \noindent
%   The base case, $\Pi_0 = \{(S_i,P_i) \mid i \in [m]\}$, is trivially
%   true since it is the input which is an ICPPL.  Assume the lemma is
%   true till the $j-1$ iteration. Consider $j$th
%   iteration:\\
%   \noindent
%   If $(P,Q)$, $(P',Q')$ and $(P'',Q'')$ are in $\Pi_{j}$ and
%   $\Pi_{j-1}$, all the invariants are
%   clearly true because they are from $j-1$ iteration.\\
%   If $(P,Q)$ is in $\Pi_{j}$ and not in $\Pi_{j-1}$, then it must be
%   one of the new sets added in $\Pi_j$. Since $(P_1,Q_1)$ and
%   $(P_2,Q_2)$ are from $\Pi_{j-1}$ and $Q_1,Q_2$ intersect and have a
%   common leaf, it can be verified that the
%   new sets are also paths. \\
%   By hypothesis for invariant III, invariant II also holds for $(P,Q)$
%   no matter which new set in $\Pi_j$ it
%   is.\\
%   To prove invariant III, if $(P,Q)$ and $(P',Q')$ are not in
%   $\Pi_{j-1}$, then they are both new sets and invariant III holds
%   trivially (new sets are disjoint). Next consider $(P,Q), (P',Q') \in
%   \Pi_j$ with only one of them, say $(P',Q')$, in $\Pi_{j-1}$. Then
%   $(P,Q)$ is one of the new sets added in line \ref{setbreak}. It is
%   easy to see that if $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$, then
%   due to invariant IV in hypothesis, invariant III becomes true in
%   this iteration. Similarly, using lemma \ref{lem:setminuscard}
%   invariant III is proven if $(P, Q)$ is $(P_1 \setminus P_2, Q_1
%   \setminus Q_2)$, or $(P_2 \setminus P_1, Q_2
%   \setminus Q_1)$.\\
%   To prove invariant IV, consider three assignments
%   $(P,Q),(P',Q'),(P'',Q'')$. If at least two of these pairs are in not
%   $\Pi_{j-1}$, then they are any two of the new sets. Note that these
%   new sets are disjoint and hence if $(P',Q'), (P'',Q'')$ are any of
%   these sets, $|P \cap P' \cap P''|=|Q \cap Q' \cap Q''|=0$ and
%   invariant IV is true. Now we consider the case if at most one of
%   $(P,Q),(P',Q'),(P'',Q'')$ is not in $\Pi_{j-1}$. If none of them are
%   not in $\Pi_{j-1}$ (i.e. all of them are in $\Pi_{j-1}$), invariant
%   IV is clearly true. Consider the case where exactly one of them is
%   not in $\Pi_{j-1}$. w.l.o.g let that be $(P,Q)$ and it could be any
%   one of the new sets. If $(P,Q)$ is $(P_1 \cap P_2, Q_1 \cap Q_2)$,
%   from lemma \ref{lem:fourpaths} and invariant III hypothesis,
%   invariant IV is proven. Similarly if $(P,Q)$ is any of the other new
%   sets, invariant IV is proven by also using lemma
%   \ref{lem:setminuscard}. %\qed

% \end{proof} 
%\temptext{ --- WG11 end --- }%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{algorithm}[h]
  \caption{Leaf labeling from an ICPPL {\tt \filterii($\cF, \cl, T$)}}
  \label{al:filtertwo} % {leafasgn}
  \begin{algorithmic}[\lndisplay]
    \STATE $\cF_0 \assign \cF$, $\cl_0(S) \assign \cl(S)$ for all $S
    \in \cF_0$ \COMMENT {Path images are such that no two path images
      share a leaf.}
    \STATE $j \assign 1$\\
    \WHILE {there is a leaf $v$ in $T$ and a unique $S_1 \in
      \cF_{j-1}$ such that $v \in \cl_{j-1}(S_1)$ }\label{uniqueleaf}
    \STATE $\cF_j \assign \cF_{j-1} \setminus \{S_1\}$\\
    \STATE for all $S \in \cF_{j-1}$ such that $S \ne S_1$ set
    $\cl_j(S) \assign
    \cl_{j-1}(S)$\\
    \STATE $X \assign S_1 \setminus \bigcup_{S \in \cF_{j-1}, S \ne S_1}S$\\
%     \IF{$X$ is empty} \label{xempty} \STATE {\bf
%       exit} \label{ln:exit2} \ENDIF
    \STATE \label{xassign} $x \assign $ arbitrary element from $X$\\
    \STATE $\cF_j \assign \cF_j \cup \{\{x\}, S_1 \setminus \{x\}\} $\\
    \STATE $\cl_j(\{x\}) \assign \{v\}$\\
    \STATE $\cl_j(S_1 \setminus \{x\}) \assign \cl_{j-1}(S_1) \setminus \{v\}$\\
    \STATE $j \assign j+1$\\
    \ENDWHILE
    \STATE $\cF' \assign \cF_j$, $\cl' \assign \cl_j$\\
    \RETURN $(\cF', \cl')$
  \end{algorithmic}
\end{algorithm}


Suppose the input $(\cF, \cl)$ is feasible, yet set $X$ in
Algorithm~\ref{al:filtertwo} is empty in some iteration of the {\bf
  while} loop. Then clearly, the algorithm will have a problem in line~\ref{xassign}.
% This will abort our procedure of finding the hypergraph
% isomorphism. 
The following Lemma~\ref{lem:xnotempty} shows that this cannot
happen. Following that Lemma~\ref{lem:invar3} shows that given an
ICPPL input, the filtered output path labeling after \filterii
is also an ICPPL.

%\temptext{ --- WG11 begin --- }%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{lemma}
%   \label{lem:invar3}
%   In Algorithm \ref{al:filtertwo},for all $j \geq 0$, at the end of the
%   $j$th iteration the four invariants given in lemma \ref{lem:invar1}
%   are valid.
%   % Moreover, $X$ as defined in the algorithm is non-empty if this is
%   % an ICPPL.
% \end{lemma}
% \begin{proof}\thesisspacing
%   First we see that $X = S_{i_1} \setminus \bigcup_{i \ne i_1, i \in
%     I}S_i$ is non empty in every iteration for an ICPPL. Suppose $X$
%   is empty. We know that $v \in P_{i_1} \setminus \bigcup_{i \ne i_1,
%     i \in I}P_i$ since $v$ is in the unique path $P_{i_1}$. Since this
%   is an ICPPL $|S_{i_1}| = |P_{i_1}|$. For any $x \in S_{i_1}$ it is
%   contained in at least two sets due to our assumption. Let $S_{i_2}$
%   be a second set that contains $x$. We know $v \notin
%   P_{i_2}$. Therefore there cannot exist a permutation that maps
%   elements of $S_{i_2}$ to $P_{i_2}$. This contradicts our assumption
%   that this is an ICPPL. Thus $X$ cannot be empty.


%   We use mathematical induction on the number of iterations for this
%   proof. The term ``new sets'' will refer to the sets added in $\Pi_j$
%   in the $j$th iteration, i.e. $(P' \setminus \{x\},Q' \setminus
%   \{v\})$ and $(\{x\},\{v\})$ for some $(P',Q')$ in $\Pi_{j-1}$ such
%   that $v$ is a leaf and $Q'$ is the unique path
%   incident on it.\\
%   For $\Pi_0$ all invariants hold because it is output from algorithm
%   \ref{al:filterone} which is an ICPPL. Hence base case is proved.  Assume
%   the lemma holds for $\Pi_{j-1}$. Consider $\Pi_j$ and any $(P,Q) \in
%   \Pi_j$. If $(P,Q) $ is in $ \Pi_j$ and $\Pi_{j-1}$ invariants I and
%   II are true because of induction assumption. If it is only in
%   $\Pi_j$, then it is $\{(P' \setminus \{x\}),(Q' \setminus \{v\})$ or
%   $(\{x\},\{v\})$ for some $(P',Q')$ in $\Pi_{j-1}$. By definition,
%   $x$ is an element in $P'$ (as defined in the algorithm) and $v$ is a
%   leaf in $Q'$. If $(P,Q)$ is $\{(P' \setminus \{x\}),(Q' \setminus
%   \{v\})$, $Q$ is a path since only a leaf is removed from path
%   $Q'$. We know $|P'| = |Q'|$, therefore $|P' \setminus \{x\}| = |Q'
%   \setminus \{v\}|$. Hence in this case invariants I and II are
%   obvious. It is easy to see these invariants hold if $(P,Q)$ is
%   $(\{x\},\{v\})$.


%   For invariant III consider $(P_1,Q_1),(P_2,Q_2)$ in $\Pi_j$. If both
%   of them are also in $\Pi_{j-1}$, claim is proved. If one of them is
%   not in $\Pi_{j-1}$ then it has to be $\{(P' \setminus \{x\}),(Q'
%   \setminus \{v\})$ or $(\{x\},\{v\})$ for some $(P',Q')$ in
%   $\Pi_{j-1}$. Since by definition, $Q'$ is the only path with $v$ and
%   $P'$ the only set with $x$ in the previous iteration, $|P_1 \cap (P'
%   \setminus \{x\})| = |P_1 \cap P'|$ and $|Q_1 \cap (Q' \setminus
%   \{v\})| = |Q_1 \cap Q'|$ and $|P_1 \cap \{x\}| = 0, Q_1 \cap \{v\} =
%   0$. Thus invariant III is also proven.

%   \noindent
%   To prove invariant IV, consider $(P_1,Q_1),(P_2,Q_2), (P_3,Q_3)$ in
%   $\Pi_j$. If exactly one of them, say $P_3 \notin \Pi_{j-1}$, it is
%   one of the new sets. By the same argument used to prove invariant
%   III, $|P_1 \cap P_2 \cap (P' \setminus \{x\})| = |P_1 \cap P_2 \cap
%   P'|$ and $|Q_1 \cap Q_2 \cap (Q' \setminus \{x\})| = |Q_1 \cap Q_2
%   \cap Q'|$. Since $P_1, P_2, P'$ are all in $\Pi_{j-1}$, by induction
%   hypothesis $|P_1 \cap P_2 \cap P'| = |Q_1 \cap Q_2 \cap Q'|$. Also
%   $|P_1 \cap P_2 \cap \{x\}| = 0, Q_1 \cap Q_2 \cap \{v\} = 0$.  If
%   two or more of them are not in $\Pi_{j-1}$, then it can be verified
%   that $|P_1 \cap P_2 \cap P_3| = |Q_1 \cap Q_2 \cap Q_3|$ since the
%   new sets in $\Pi_j$ are either disjoint or as follows: assuming
%   $P_1, P_2 \notin \Pi_{j-1}$ and new sets are derived from $(P', Q'),
%   (P'', Q'') \in \Pi_{j-1}$ with $x_1, x_2$ exclusively in $P_1, P_2$,
%   $(\{x_1\},\{v_1\}), (\{x_2\},\{v_2\}) \in \Pi_j $ thus $v_1, v_2$
%   are exclusively in $Q_1, Q_2$ resp. it follows that $|P_1 \cap P_2
%   \cap P_3| = |(P' \setminus \{x_1\}) \cap (P'' \setminus \{x_2\})
%   \cap P_3| = |P' \cap P'' \cap P_3| = |Q' \cap Q'' \cap Q_3| = |(Q'
%   \setminus \{v_1\} \cap Q'' \setminus \{v_2\} \cap Q_3| = |Q_1 \cap
%   Q_2 \cap Q_3|$. Thus invariant IV is also proven.  %\qed
% \end{proof}

% Using algorithms \ref{al:filterone} and \ref{al:filtertwo} we prove the following
% theorem.

% \begin{theorem}
%   \label{th:perm}
%   If $\cA$ is an ICPPL, then there exists a bijection $\sigma : U
%   \rightarrow V(T)$ such that $\sigma(S_i) = P_i$ for all $i \in I$
% \end{theorem}
% \begin{proof}\thesisspacing
%   This is a contructive proof. First, the given ICPPL $\cA$ and tree
%   $T$ are given as input to Algorithm \ref{al:filterone}. This yields a
%   ``filtered'' ICPPL as the output which is input to Algorithm
%   \ref{al:filtertwo}.  It can be observed that the output of Algorithm
%   \ref{al:filtertwo} is a set of interval assignments to sets and
%   one-to-one assignment of elements of $U$ to each leaf of $T$. To be
%   precise, it would be of the form $\cB_0 = \cA_0 \cup \cL_0$. The
%   leaf assignments are defined in $\cL_0 = \{ (x_i,v_i) \mid x_i \in
%   U, v_i \in T, x_i \ne x_j, v_i \ne v_j, i \ne j, i,j \in [k] \}$
%   where $k$ is the number of leaves in $T$. The path assignments are
%   defined in $\cA_0 \subseteq \{(S_i',P_i') \mid S_i' \subseteq U_0,
%   P_i' \text{ is a path from } T_0\}$ where $T_0$ is the tree obtained
%   by removing all the leaves in $T$ and $U_0 = U \setminus \{ x \mid x
%   \text{ is assigned to a leaf in }\cL_0 \}$. Now we have a subproblem
%   of finding the permutation for the path assignment $\cA_0$ which has
%   paths from tree $T_0$ and sets from universe $U_0$. Now we repeat
%   the procedure and the path assignment $\cA_0$ and tree $T_0$ is
%   given as input to Algorithm \ref{al:filterone}. The output of this
%   algorithm is given to Algorithm \ref{al:filtertwo} to get a new union of
%   path and leaf assignments $\cB_1 = \cA_1 \cup \cL_1$ defined similar
%   to $\cB_0, \cL_0, \cA_0$. In general, the two algorithms are run on
%   path assignment $\cA_{i-1}$ with paths from tree $T_{i-1}$ to get a
%   new subproblem with path assignment $\cA_i$ and tree $T_{i}$. $T_i$
%   is the subtree of $T_{i-1}$ obtained by removing all its
%   leaves. More importantly, it gives leaf assignments $\cL_{i}$ to the
%   leaves in tree $T_{i-1}$. This is continued until we get a
%   subproblem with path assignment $\cA_{d-1}$ and tree $T_{d-1}$ for
%   some $d \le n$ which is just a path. From the last lemma we know
%   that $\cA_{d-1}$ is an ICPPL. Another observation is that an ICPPL
%   with all its tree paths being intervals (subpaths from a path) is
%   nothing but an ICPIA\cite{nsnrs09}.  Let $\cA_{d-1}$ be equal to
%   $\{(S_i'',P_i'') \mid S_i'' \subseteq U_{d-1}, P_i'' \text{ is a
%     path from } T_{d-1} \}$. It is true that the paths $P_i''$s may
%   not be precisely an interval in the sense of consecutive integers
%   because they are some nodes from a tree. However, it is easy to see
%   that the nodes of $T_{d-1}$ can be ordered from left to right and
%   ranked to get intervals $I_i$ for every path $P_i''$ as
%   follows. $I_i = \{[l,r] \mid l = \text{ the lowest rank of the nodes
%     in }P_i'', r = l+|P_i''|-1 \}$. Let asssignment $\cA_d$ be with
%   the renamed paths. $\cA_d = \{ (S_i'', I_i) \mid (S_i'', P_i'') \in
%   \cA_{d-1} \}$. What has been effectively done is renaming the nodes
%   in $T_{d-1}$ to get a tree $T_d$.  The ICPIA $\cA_d$ is now in the
%   format that the ICPIA algorithm requires which gives us the
%   permutation $\sigma' : U_{d-1} \rightarrow T_{d-1}$

% \noindent
% $\sigma'$ along with all the leaf assignments $\cL_i$ gives us the
% permutation for the original path assignment $\cA$.  More precisely,
% the permutation for tree path assignment $\cA$ is defined as
% follows. $\sigma: U \rightarrow T$ such that the following is
% maintained.
% \begin{align*}
%   \sigma(x) &= \sigma'(x),   \text{ if } x \in U_{d-1} \\
%   &= \cL_i(x), \text{ where $x$ is assigned to a leaf in a subproblem
%     $\cA_{i-1}, T_{i-1}$}
% \end{align*}

% \noindent
% To summarize, run algorithm \ref{al:filterone} and \ref{al:filtertwo} on
% $T$. After the leaves have been assigned to specific elements from
% $U$, remove all leaves from $T$ to get new tree $T_0$. The leaf
% assignments are in $\cL_0$. Since only leaves were removed $T_0$ is
% indeed a tree. Repeat the algorithms on $T_0$ to get leaf assignments
% $\cL_{1}$. Remove the leaves in $T_0$ to get $T_1$ and so on until the
% pruned tree $T_d$ is a single path. Now run ICPIA algorithm on $T_d$
% to get permutation $\sigma'$. The relation $\cL_0 \cup \cL_1 \cup
% .. \cup \cL_{d} \cup \sigma'$ gives the bijection required in the
% original problem.%\qed
% \end{proof}
%\temptext{ --- WG11 end --- }%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{lemma}
  \label{lem:xnotempty}
  If the input ICPPL $(\cF, \cl)$ to Algorithm~\ref{al:filtertwo} is
  feasible, then for all iterations $j > 0$ of the {\em \bf while}
  loop, the set $X$ will be non-empty.
% the {\em \bf exit} statement in line~\ref{ln:exit2} does not
%   execute.
\end{lemma}
\begin{proof}\thesisspacing
This directly follows from Lemma~\ref{lem:priv-card} since $X$ is
nothing but $S_{1_{priv}}$.
%   Assume $X$ is empty for some iteration $j > 0$. We know that $v$ is
%   an element of $\cl_{j-1}(S_1)$. Since it is uniquely present in
%   $\cl_{j-1}(S_1)$, it is clear that $v \in \cl_{j-1}(S_1) \setminus
%   \bigcup_{(S \in \cF_{j-1}) \wedge (S \ne S_1)}\cl_{j-1}(S)$.  Note
%   that for any $x \in S_1$ it is contained in at least two sets due to
%   our assumption about cardinality of $X$. Let $S_2 \in \cF_{j-1}$ be
%   another set that contains $x$. From the above argument, we know $v
%   \notin \cl_{j-1}(S_2)$. Therefore there cannot exist a hypergraph
%   isomorphism bijection that maps elements in $S_2$ to those in
%   $\cl_{j-1}(S_2)$. This contradicts our assumption that the input is
%   feasible. Thus $X$ cannot be empty if input is ICPPL and feasible.
  %\qed
\end{proof}

\begin{lemma}
  \label{lem:invar3}
  In Algorithm~\ref{al:filtertwo}, for all $j > 0$, at the end of the
  $j$th iteration of the {\bf while} loop the four invariants given in
  Lemma~\ref{lem:invar1} hold.
\end{lemma}
\begin{proof}\thesisspacing
  Following Lemma~\ref{lem:xnotempty}, we know that set $X$ will not
  be empty in any iteration of the {\em \bf while} loop if input ICPPL
  $(\cF, \cl)$ is feasible and thus $\cl_j$ is always computed for all
  $j > 0$. Also note that removing a leaf from any path keeps the new
  path connected. Thus invariant I is obviously true. In every
  iteration $j > 0$, we remove exactly one element $x$ from one set
  $S$ in $\cF$ and exactly one vertex $v$ which is a leaf from one
  path $\cl_{j-1}(S)$ in $T$. This is because $x$ is exclusive to $S$
  and $v$ is exclusive to $\cl_{j-1}(S)$. Due to this fact, it is
  clear that the intersection cardinality equations do not change,
  i.e., invariants II, III, IV remain true. % On the other hand, if the
%   input ICPPL is not feasible the invariants are vacuously true.
  % \qed
\end{proof}


We have seen two filtering algorithms above, namely,
Algorithm~\ref{al:filterone} for \filteri and
Algorithm~\ref{al:filtertwo} for \filterii which when executed
in that order result in a new ICPPL on the same universe $U$ and
target tree $T$. We also proved that if the input is indeed feasible,
these algorithms executed in sequence give an ICPPL that preserves a
non-empty subset of set of feasibility hypergraph isomorphisms of the
original input. % Now we present the algorithmic characterization of a feasible
% tree path labeling by way of Algorithm~\ref{al:icppl-find-isomorph}.
Now we present Algorithm~\ref{al:icppl-find-isomorph} which uses these
two filters to compute one such isomorphism.

%% IS THIS LEMMA NECESSARY? 31 JAN 2012 %%
% \begin{lemma}{\temptext{PROOF TBD.}}
%   Let $(\cF_2, \cl_2)$ be the output of \filterii and the ICPPL
%   input to \filteri preceeding its call is $(\cF, \cl)$ with
%   target tree $T$. If a bijection $\phi:\supt{\cF_2} \rightarrow V(T)$
%   is a hypergraph isomorphism of $(\cF_2, \cl_2)$, then it is a
%   hypergraph isomorphism of $(\cF, \cl)$.
% \end{lemma}


Algorithm~\ref{al:icppl-find-isomorph} computes a hypergraph
isomorphism $\phi$ recursively using Algorithm~\ref{al:filterone} and
Algorithm~\ref{al:filtertwo} and pruning the leaves of the input
tree. In brief, it is done as follows. If the input is feasible, the
output of \filteri, say $(\cF_1, \cl_1)$, gives a new ICPPL
which preserves all the original hypergraph isomorphisms.  This ICPPL
$(\cF_1, \cl_1)$ is then given to \filterii which gives the
second filtered ICPPL, say $(\cF_2, \cl_2)$ such that a feasible leaf
labeling is in singleton elements of $\cF_2$. These leaf labels are
the elements in $supp(\cF)$ that map to leaves in $T$ in at least one
hypergraph isomorphism of the input ICPPL $\cl$. It must be noted that
at this point, the algorithm ``chooses'' one (or more - there could be
more than one bijections that have the same leaf labels) hypergraph
isomorphism $\phi'$, from the set of all isomorphisms resulting from the
feasibility of the original input $(\cF, \cl)$. However, if there
exists one (\ie input is feasible), it will be found -- thus
performing the test required in \FTPL.

Since their pre-images have been found, all leaves in $T$ are then
pruned away. The leaf labels are removed from the path labeling
$\cl_2$ and the corresponding elements are removed from the
corresponding sets in $\cF_2$. It is now clear that we have a
subproblem with a new hypergraph $\cF'$, new tree path labeling $\cl'$
and target tree $T'$.  The tree pruning algorithm is recursively
called on $\cF', \cl', T'$. The recursive call returns the bijection
$\phi''$ for the rest of the elements in $supp(\cF)$ which along with
the leaf labels $\phi'$ computed earlier gives us a hypergraph
isomorphism $\phi$ for the input $\cF,\cl,T$.  
Lemma~\ref{lem:hyperiso} proves the correctness of this computation.

\begin{algorithm}[h]
  \caption{{\tt get-hypergraph-isomorphism ($\cF, \cl, T$)}}
  \label{al:icppl-find-isomorph}
  \begin{algorithmic}[\lndisplay]

    \IF{$T$ is empty}
    \RETURN $\emptyset$\\
    \ENDIF
    \STATE $L \assign \{v \mid v \text{ is a leaf in }      T\}$\\
    \STATE $(\cF_1, \cl_1) \assign$ {\tt \filteri($\cF, \cl,
      T$)}\\
    \STATE $(\cF_2, \cl_2) \assign$ {\tt \filterii($\cF_1,
      \cl_1, T$)}\\

    \STATE $(\cF', \cl') \assign (\cF_2, \cl_2)$\\
    \STATE $\phi' \leftarrow \emptyset$

    \FOR {every $v \in L$} \STATE $\phi'(x) \assign v$ where $x \in
    \cl_2^{-1}(\{v\})$ \COMMENT {Copy the leaf labels to a one to one
      function $\phi': supp(\cF) \rightarrow L$
    }\\
    \STATE Remove $\{x\}$ and $\{v\}$ from $\cF'$, $\cl'$  appropriately\\
    \ENDFOR

    \STATE $T' \assign T \setminus L$

    \STATE $\phi'' \assign$ {\tt get-hypergraph-isomorphism($\cF',
      \cl', T'$)}
    \STATE $\phi \assign \phi'' \cup \phi'$ \\
    \RETURN $\phi$
  \end{algorithmic}
\end{algorithm}

\begin{lemma}
  \label{lem:hyperiso} %{lem:perm}
%   If $(\cF, \cl)$ is an ICPPL from a tree $T$ and
%   Algorithm~\ref{al:icppl-find-isomorph}, on input $\cF, \cl, T$
%   returns a non-empty function, then there exists a hypergraph
%   isomorphism $\phi : supp(\cF) \rightarrow V(T)$ such that the
%   $\phi$-induced tree path labeling is equal to $\cl$ or $\cl_\phi =
%   \cl$.
  If $(\cF, \cl)$ is an ICPPL from a tree $T$ and
  Algorithm~\ref{al:icppl-find-isomorph}, on input $(\cF, \cl, T)$
  returns a non-empty function $\phi$, then $\phi$ is a hypergraph
  isomorphism $\phi : supp(\cF) \rightarrow V(T)$ such that the
  $\phi$-induced tree path labeling is equal to $\cl$; $\cp_\phi =
  \cl$.
\end{lemma}
\begin{proof}\thesisspacing
  It is clear that in the end of every recursive call to
  Algorithm~\ref{al:icppl-find-isomorph}, the function $\phi'$ is
  one-to-one involving all the leaves in the input target tree $T$ (of
  the current recursive call). Moreover, by Lemma~\ref{lem:noexit1}
  and Lemma~\ref{lem:xnotempty} it is consistent with the input tree
  path labeling $\cl$ (of the current recursive call). The tree
  pruning is done by only removing leaves in each call to the function
  and is done till the tree becomes empty. Thus the returned function
  $\phi: supp(\cF) \rightarrow V(T)$ is a union of mutually exclusive
  one-to-one functions exhausting all vertices of the tree. In other
  words, it is a bijection from $supp(\cF)$ to $V(T)$ inducing the
  given path labeling $\cl$ and thus a hypergraph isomorphism. %\qed
\end{proof}

Finally we have Theorem~\ref{th:charac} which puts together all that
we saw so far in this section to prove that ICPPL is indeed a
characterization of a feasible path labeling.
\begin{theorem}
  \label{th:charac}
  A path labeling $(\cF, \cl)$ on tree $T$ is feasible \iff it is an
  ICPPL and Algorithm~\ref{al:icppl-find-isomorph} with $(\cF, \cl,
  T)$ as input returns a non-empty function.
\end{theorem}
\begin{proof}\thesisspacing
  From Lemma~\ref{lem:hyperiso}, we know that if $(\cF, \cl)$ is an
  ICPPL and if Algorithm~\ref{al:icppl-find-isomorph} with $(\cF, \cl,
  T)$ as input returns a non-empty function, then $(\cF, \cl)$ is
  feasible.  Now consider the case where $(\cF, \cl)$ is feasible, \ie
  there exists a hypergraph isomorphism $\phi$ such that $\cl_\phi =
  \cl$. Lemma~\ref{lem:noexit1} and Lemma~\ref{lem:xnotempty} show us
  that \filteri and \filterii do not exit if input is feasible. Thus
  Algorithm~\ref{al:icppl-find-isomorph} returns a non-empty
  function.%\qed
\end{proof}

\section{Solution to \illustrationproblem}
\label{sec:wallacesol}

In this section we run through the filtering and tree pruning
algorithm seen in Section~\ref{sec:feasible} on an example. The
example problem is the \illustrationproblem posed in
Section~\ref{sec:problem}.  % Chapter~\ref{ch:intro}
The solution is depicted in Figure~\ref{fig:solpartI},
Figure~\ref{fig:solpartIII}, Figure~\ref{fig:solpartIVa},
Figure~\ref{fig:solpartIVb}, Figure~\ref{fig:solpartVI},
Figure~\ref{fig:solpartVII}, Figure~\ref{fig:solpartVIII} and the
figures along with their captions are self-explanatory.

\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}
    $T:$ \infiniteloopI & $\cF:$ \studygroupsI
  \end{tabular}
   
  \caption[\figtabsize Problem solution part 1]{\figtabsize The
    problem is shown again here using the input described in
    Section~\ref{sec:problem}. The target tree is $T$ with vertex set
    $\{1,2,\ldots,11\}$ on the left hand side along with the path
    system (hypergraph) -- $\{7,2,6,5\}, \{8,2,4\}, \{10,6,5,3\},
    \{9,1,5,3,11\}$. The hypergraph is $\cF$ with hyperedges $\{\xPa,
    \xPi, \xVi, \xCh\}, \{\xSn, \xWo, \xPi\}, \{\xCh, \xFr, \xVi,
    \xLi\}, \{\xLu, \xSa, \xSc, \xCh, \xFr\}$ shown in the right hand
    side. In subsequent illustrations, the gray boxes which contain
    the elements of universe $U$, will be assigned to nodes and
    removed from the right hand side figure and placed next to the
    vertex of $T$ in the left hand side figure.  The path labeling is
    implicitly given by the color-coded Venn diagrams (the order of
    listing of the hyperedges in this caption is also done respective
    to the input path labeling).}
  \label{fig:solpartI}  
\end{figure}


\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}
    \infiniteloopIII 
    & 
    \studygroupsIII 
    &
    \studygroupsIIItable
  \end{tabular}
  \caption[\figtabsize Problem solution part 2]{\figtabsize It can be observed in
    Figure~\ref{fig:solpartI}, that none of the leaves are shared by
    more than one path. Hence, \filteri does not alter the
    hypergraphs. \filterii finds the leaf assignments as shown --
    elements \xPa, \xSn, \xLu, \xSc, \xLi, \xWo are assigned to
    vertices 7, 8, 9, 11, 10, 4 respectively. Computation of these
    leaf labels are deterministic except for $\xLu, \xSc$ where the
    algorithm arbritarily choses them from $X = \{\xLu, \xSa, \xSc\}$
    and for $\xSn, \xWo$ arbitrarily choses from $X = \{\xSn,
    \xWo\}$. Here we show only one such choice and clearly one could
    have chosen another leaf label (\eg $\xSa$ on 9 or $\xWo$ on 8) to
    get a different feasible hypergraph isomorphism.  After
    this, the leaves of $T$ are pruned and the hypergraph updated
    accordingly by \algoiii subroutine -- the pruned leaves are shown
    with dotted edges and the corresponding Venn diagrams show the
    updated hypergraphs. $\phi_0$ is this leaf assignment and the
    algorithm proceeds to solve the subproblem with the new
    hypergraphs and path labeling which is: $\{2,6,5\}, \{2\},
    \{6,5,3\}, \{1,5,3\}$ labeled with $\{\xPi, \xVi, \xCh\},
    \{\xPi\}, \{\xCh, \xFr, \xVi\}, \{\xSa, \xCh, \xFr\}$
    respectively.}
  \label{fig:solpartIII}  
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}
    \infiniteloopIVa
    & 
    \studygroupsIVa
  \end{tabular}
  \caption[\figtabsize Problem solution part 3]{\figtabsize In the subproblem shown in
    Figure~\ref{fig:solpartIII}, it can be noted that there are two
    leaves which are shared by more than one paths -- 2 and 3. Hence
    \filteri filters this out one by one. Here we show the handling of
    leaf 2 which was shared by paths $\{2,6,5\}$ ($=P_1$, say) and
    $\{2\}$($=P_2$, say). \filteri removes $P_1$ and adds
    $\{6,5\}$. Note that only one set is added and removed since $P_2
    \subset P_1$. Accordingly, \filteri alters the hypergraph on the
  right hand side by removing and adding $\{\xPi, \xVi, \xCh\}$ and $\{\xVi, \xCh\}$ respectively.}
  \label{fig:solpartIVa}  
\end{figure}


\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}
    \infiniteloopIVb
    & 
    \studygroupsIVb
  \end{tabular}
  \caption[\figtabsize Problem solution part 4]{\figtabsize After handling leaf 2, \filteri proceeds to
    handle leaf 3 which is shared by paths $\{1,5,3\}$ and
    $\{6,5,3\}$. \filteri removes these two paths and adds their
    intersection and set differences -- $\{5,3\}$, $\{1\}$ and
    $\{6\}$. Correspondingly, hyperedges $\{\xSa, \xCh, \xFr\}$ and $\{\xVi,
    \xCh, \xFr\}$ are removed and new hyperedges $\{\xCh, \xFr\}$, $\{\xSa\}$
    and $\{\xVi\}$ respectively are added. There are no more leaves
    shared and the algorithm proceeds to \filterii.}
  \label{fig:solpartIVb}  
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}
    \infiniteloopVI
    & 
    \studygroupsVI
    &
    \studygroupsVItable
  \end{tabular}
  \caption[\figtabsize Problem solution part 5]{\figtabsize \filterii computes the leaf assignment $\phi_1$ -- $\xPi,
    \xSa, \xFr$ on 2,1,3 respectively. These assignments are
    deterministic since $X$ consisted of only single elements for each
  of these leaves. After this the rest of the labeling is fairly
  obvious but we present it in Figure~\ref{fig:solpartVII} for the
  sake of completeness.}
  \label{fig:solpartVI}  
\end{figure}
\clearpage

\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}

    \infiniteloopVII 
    &
    &
    \studygroupsVIItable
  \end{tabular}
  \caption[\figtabsize Problem solution part 6]{\figtabsize The last part of the isomorphism is computed as
  the leaf label $\phi_2$ which maps $\xCh, \xVi$ to 5, 6
  respectively. Figure~\ref{fig:solpartVIII} shows the final
  feasibility isomorphism which is the union of all the leaf labels.}
  \label{fig:solpartVII}  
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{tabular}[h]{c|cc}
    \infiniteloopVIII
    &
    &
    \studygroupsVIIItable
  \end{tabular}
  \caption[\figtabsize Problem solution part 7]{\figtabsize The solution to the problem presented in
    Figure~\ref{fig:solpartI}. The feasibility hypergraph isomorphism
    $\phi$ is computed as the union of the leaf labels
    $\phi_0,\phi_1,\phi_2$. One can easily verify that this
    isomorphism does indeed induce the path labeling given in the
    original input.}
  \label{fig:solpartVIII}
\end{figure}


%\clearpage
\section[Special target trees]{ Computing feasible TPL with special target trees}
\label{sec:spltargettree}

Section~\ref{sec:feasible} described properties that a TPL must have
for it to be feasible. The next problem of interest is to test if a
given hypergraph is a path hypergraph with respect to a given target
tree\footnote{A larger problem would be to find if a given hypergraph
  is a path hypergraph with respect to any tree. This problem is not
  addressed in this thesis.}.  In other words, the problem is to find
out if a feasible tree path labeling exists from a given target tree
for a given hypergraph. In this section we will see two special cases
of this problem where the target tree is from a particular family of
trees. The first one, where the tree is a path as described by the
\CFTPLINT problem (see Section~\ref{sec:myresearchintro}) is a shown
to be equivalent to the well studied problem of consecutive-ones in
Section~\ref{sec:icpplicpia}. The second one, where the tree is a
$k$-subdivided tree as described by \CFTPLKTREE (see
Section~\ref{sec:myresearchintro}), has been solved using a polynomial
time algorithm. The latter problem enforces some conditions on the
hypergraph too which will be seen in Section~\ref{sec:ksubdivstar}.

\subsection{Target tree is a Path}
\label{sec:icpplicpia}

In Section~\ref{sec:motive} it is described how \COP is a
special case of TPL as described by the \CFTPLINT problem. In this
section we will dwell on this in more detail.

\annote[dire]{The special case of TPL where the target tree $T$ is a
path. Hence, all path labels are can be viewed as intervals assigned
to the sets in $\cF$. }{needs work}

It is shown, in \cite{nsnrs09}, that the
filtering algorithms outlined above need only preserve pairwise
intersection cardinalities, and higher level intersection
cardinalities are preserved by the Helly Property of intervals.
% Consequently, the filter algorithms do not need to ever evaluate the
% additional check to {\em \bf exit}.
%\begin{enumerate}
%\item Given tree $T$ is a path. Hence, all path labels are interval labels.
%\item Only pairwise intersection cardinality
%  preservation is sufficient. i.e. property (iii) in ICPPL is not enforced.
%\item The filter algorithms do not have {\em \bf exit} statements.
%\end{enumerate}
%This is called an Intersection Cardinality Preservation Interval
%Assignment (ICPIA) \cite{nsnrs09}. 
This structure and its algorithm is used in the next section for
finding tree path labeling from a $k$-subdivided star due to this
graph's close relationship with intervals.

\tnote[dire]{ELABORATE}


\subsection{Target tree is a $k$-subdivided Star}
\label{sec:ksubdivstar}

\begin{figure}[t] %[htbp] 
  \centering
  \begin{tabular}{lr}
   (a) \ksubstari & (b) \ksubstarii
  \end{tabular}
  \caption{\figtabsize (a) $8$-subdivided star with 7 rays (b)
    3-subdivided star with 3 rays}
  \label{fig:kstar}
\end{figure}

In this section we consider the problem of assigning paths from a
$k$-subdivided star $T$ to a given set system $\cF$ as described by
the \CFTPLKTREE problem.  We consider
$\cF$ for which the overlap graph $\bO(\cF)$ is connected.  The
overlap graph is well-known from the work of
\cite{kklv10,nsnrs09,wlh02}.  We use the notation in
\cite{kklv10}. Recall from Section~\ref{ch:prelims} that hyperedges
$S$ and $S'$ are said to overlap, denoted by $S \overlap S'$, if $S$
and $S'$ have a non-empty intersection but neither of them is
contained in the other. The overlap graph $\bO(\cF)$ is a graph in
which the vertices correspond to the sets in $\cF$, and the vertices
corresponding to the hyperedges $S$ and $S'$ are adjacent if and only
if they overlap.  Note that the intersection graph of $\cF$,
$\bI(\cF)$ is different from $\bO(\cF)$ and $\bO(\cF) \subseteq
\bI(\cF)$.  A connected component of $\bO(\cF)$ is called an overlap
component of $\cF$.  An interesting property of the overlap components
is that any two distinct overlap components, say $\cO_1$ and $\cO_2$,
are such that any two sets $S_1 \in \cO_1$ and $S_2 \in \cO_2$ are
disjoint, or, w.l.o.g, all the sets in $\cO_1$ are contained within
one set in $\cO_2$.  This containment relation naturally determines a
decomposition of the overlap components into rooted containment trees.
We consider the case when there is only one rooted containment tree,
and we first present our algorithm when $\bO(\cF)$ is connected.  It
is easy to see that once the path labeling to the overlap component in
the root of the containment tree is achieved, the path labeling to the
other overlap components in the rooted containment tree is essentially
finding a path labeling when the target tree is a path: each target
path is a path that is allocated to sets in the root overlap
component.  Therefore, for the rest of this section, $\bO(\cF)$ is a
connected graph. We also assume that all hyperedges are of cardinality
at most $k+2$.

Recall from Section~\ref{ch:prelims} that a $k$-subdivided star is a
star with each edge subdivided $k$ times. Therefore, a $k$-subdivided
star has a central vertex which we call the {\em root}, and each root
to leaf path is called a {\em ray}. First, we observe that by removing
the root $r$ from $T$, we get a collection of $p$ vertex disjoint
paths of length $k+1$, $p$ being the number of leaves in $T$.  We
denote the rays by $R_1, \ldots, R_p$, and the number of vertices in
$R_i$, $i \in [p]$ is $k+2$.  Let $\seq{v_{i1},\ldots,v_{i(k+2)}=r}$
denote the sequence of vertices in $R_i$, where $v_{i1}$ is the
leaf. Note that $r$ is a common vertex to all $R_i$.

In this section the given hypergraph, the $k$-subdivided star and the
root of the star are denoted by $\cO$, $T$ and vertex $r$,
respectively.
% For each hyperedge $X \in \cO$, we will maintain a 2-tuple of
% non-negative numbers $\seq{p_1(X), p_2(X)}$.  The numbers satisfy
% the property that $p_1(X) + p_2(X) \leq |X|$, and at the end of path
% labeling, for each $X$, $p_1(X) + p_2(X) = |X|$.  This signifies the
% algorithm tracking the lengths of subpaths of the path assigned to
% $X$ from at most two rays. We also maintain another parameter called
% the {\em residue} of $X$ denoted by $s(X)=|X| - p_1(X)$. This
% signifies the residue path length that must be assigned to $X$ which
% must be from another ray. For instance, if $X$ is labeled a path
% from only one ray, then $p_1(X) = |X|$, $p_2(X) = 0$ and $s(X) = 0$.

% 
% We iteratively consider each ray from which paths will be assigned
% to hyperedges. At the beginning of each iteration hyperedges of
% $\cO$ are classifed into the following disjoint sets.
% \begin{enumerate}
% \item [$\cL_1^i$] {\em Labeled without $r$.} Those that have been
%   labeled with a path which does not contain $r$ in one of the
%   previous iterations.\\ $\cL_1^i = \set{ X \mid p_1(X) = |X| \text{
%       and } p_2(X) = 0 \text{ and } s(X) = 0, X \in \cO}$
% \item [$\cL_2^i$] {\em Labeled with $r$.} Those that have been
%   labeled with two subpaths of $\cl(X)$ containing $r$ from two
%   different rays in two previous iterations.\\ $\cL_2^i = \set{X
%     \mid 0 < p_1\left(X\right), p_2\left(X\right) < |X| \text{ and }
%     s(X) = 0, X \in \cO}$
% \item [$\cT_1^i$] {\em Type 1 / partially labeled.} Those that have
%   been labeled with one path containing $r$ from a single ray in one
%   of the previous iterations. Here, $p_1(X)$ denotes the length of
%   the subpath of $\cl(X)$ that $X$ has been so far labeled
%   with. Also, it is clear that such a path must start at $r$ and
%   must be in a ray different from the one corresponding to $p_1(X)$.\\
%   $\cT_1^i = \set{ X \mid 0 < p_1(X) < |X| \text{ and } p_2(X) = 0
%     \text{ and } s(X) > 0, X \in \cO}$
% \item [$\cT_2^i$] {\em Type 2 / not labeled.} Those that have not
%   been
%   labeled with a path in any previous iteration.\\
%   $\cT_2^i = \set{ X \mid p_1(X) = p_2(X) = 0 \text{ and } s(X) =
%     |X|, X \in \cO}$
% \end{enumerate}
% \vspace{-2mm}
% \begin{align*}
%   \cO &= \cL_1^i \cup \cL_2^i \cup \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]\\
%   \cO_i &= \cT_1^i \cup \cT_2^i, \text{ } \forall i \in [p]
% \end{align*}


The set $\cO_i$ refers to the set of hyperedges $\cT_1^i \cup \cT_2^i$
in the $i$th iteration.  Note that $\cO_1 = \cO$.  In the $i$th
iteration, hyperedges from $\cO_i$ are assigned paths from $R_i$ using
the following rules. Also the end of the iteration, $\cL_1^{i+1},
\cL_2^{i+1}, \cT_1^{i+1}, \cT_2^{i+1}$ are set to $\cL_1^{i},
\cL_2^{i}, \cT_1^{i}, \cT_2^{i}$ respectively, along with some
case-specific changes mentioned in the rules below.

\tnote[dire]{REPEAT!!

In this section we consider the problem of assigning paths from a
$k$-subdivided star $T$ to a given set system $\cF$ such that each set
$X \in \cF$ is of cardinality at most $k+2$.  Secondly, we present our
results only for the case when overlap graph $\bO(\cF)$ is connected.
%The
%overlap graph is well-known from the work of
%\cite{kklv10,nsnrs09,wlh02}.  We use the notation in
%\cite{kklv10}. Recall from Section~\ref{sec:prelims} that hyperedges
%$S$ and $S'$ are said to overlap, denoted by $S \overlap S'$, if $S$ and $S'$
%have a non-empty intersection but neither of them is contained in the
%other. The overlap graph $\bO(\cF)$ is a graph in which the vertices
%correspond to the sets in $\cF$, and the vertices corresponding to the
%hyperedges $S$ and $S'$ are adjacent if and only if they overlap.  Note
%that the intersection graph of $\cF$, $\bI(\cF)$ is different from
%$\bO(\cF)$ and $\bO(\cF) \subseteq \bI(\cF)$.  
A connected component of $\bO(\cF)$ is called an overlap component of
$\cF$.  An interesting property of the overlap components is that any
two distinct overlap components, say $\cO_1$ and $\cO_2$, are such
that any two sets $S_1 \in \cO_1$ and $S_2 \in \cO_2$ are disjoint,
or, w.l.o.g, all the sets in $\cO_1$ are contained within one set in
$\cO_2$.  This containment relation naturally determines a
decomposition of the overlap components into rooted containment trees.
We consider the case when there is only one rooted containment tree,
and we first present our algorithm when $\bO(\cF)$ is connected.  It
is easy to see that once the path labeling to the overlap component in
the root of the containment tree is achieved, the path labeling to the
other overlap components in the rooted containment tree is essentially
finding a path labeling when the target tree is a path: each target
path is a path that is allocated to sets in the root overlap
component.  Therefore, for the rest of this section, $\bO(\cF)$ is a
connected graph. Recall that we also consider the special case when
all hyperedges are of cardinality at most $k+2$.  By definition, a
$k$-subdivided star has a central vertex which we call the {\em root},
and each root to leaf path is called a {\em ray}.  First, we observe
that by removing the root $r$ from $T$, we get a collection of $p$
vertex disjoint paths of length $k+1$, $p$ being the number of leaves
in $T$.  We denote the rays by $R_1, \ldots, R_p$, and the number of
vertices in $R_i$, $i \in [p]$ is $k+2$.  Let
$\seq{v_{i1},\ldots,v_{i(k+2)}=r}$ denote the sequence of vertices in
$R_i$, where $v_{i1}$ is the leaf. Note that $r$ is a common vertex to
all $R_i$.
}  


\noindent {\bf Description of the Algorithm.}
In this section the given hypergraph $\cF$, the $k$-subdivided star
and the root of the star are denoted by $\cO$, $T$ and vertex $r$,
respectively.  In particular, note that the vertices of $\cO$
correspond to the sets in $\cF$, and the edges correspond to the
overlap relation.

\noindent
For each hyperedge $X \in \cO$, we will maintain a 2-tuple of non-negative
 numbers $\seq{p_1(X), p_2(X)}$.  The numbers satisfy the property that
 $p_1(X) + p_2(X) \leq |X|$, and at the end of path labeling, for each
 $X$, $p_1(X) + p_2(X) = |X|$.  This signifies the algorithm tracking
 the lengths of subpaths of the path assigned to $X$ from at most two
 rays. We also maintain another parameter called the {\em residue} of
 $X$ denoted by $s(X)=|X| - p_1(X)$. This signifies the residue path
 length that must be assigned to $X$ which must be from another
 ray. For instance, if $X$ is labeled a path from only one ray, then
 $p_1(X) = |X|$, $p_2(X) = 0$ and $s(X) = 0$.

 \xnoindent The algorithm proceeds in iterations, and in the $i$-th
 iteration, $i > 1$, a single hyperedge $X$ that overlaps with a
 hyperedge that has been assigned a path is considered.  At the
 beginning of each iteration hyperedges of $\cO$ are classifed into
 the following disjoint sets.
 \begin{enumerate}
 \item [$\cL_1^i$] {\em Labeled without $r$.} Those that have been
   labeled with a path which does not contain $r$ in one of the
   previous iterations.\\  $\cL_1^i = \set{ X \mid p_1(X) = |X| \text{ and
     } p_2(X) = 0 \text{ and } s(X) = 0, X \in \cO}$
 \item [$\cL_2^i$] {\em Labeled with $r$.} Those that have been labeled
   with two subpaths of $\cl(X)$ containing $r$ from two different rays
   in two previous iterations.\\ $\cL_2^i = \set{X \mid 0 < p_1\left(X\right),
     p_2\left(X\right) < |X|=p_1(X)+p_2(X) \text{ and } s(X) = 0, X \in \cO}$
   \item [$\cT_1^i$] {\em Type 1 / partially labeled.} Those that have
     been labeled with one path containing $r$ from a single ray in one
     of the previous iterations. Here, $p_1(X)$ denotes the length of
     the subpath of $\cl(X)$ that $X$ has been so far labeled
     with. \\
     $\cT_1^i = \set{ X \mid 0 < p_1(X) < |X| \text{ and } p_2(X) = 0
       \text{ and } s(X) = |X|-p_1(X), X \in \cO}$
   \item [$\cT_2^i$] {\em Type 2 / not labeled.} Those that have not been
     labeled with a path in any previous iteration.\\
     $\cT_2^i = \set{ X \mid p_1(X) = p_2(X) = 0 \text{ and } s(X) = |X|,
       X \in \cO}$
 \end{enumerate}
% \vspace{-2mm}
% \begin{align*}
%   \cO &= \cL_1^i \cup \cL_2^i \cup \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]\\
%   \cO_i &= \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]
% \end{align*}

\noindent
The set $\cO_i$ refers to the set of hyperedges $\cT_1^i \cup \cT_2^i$
in the $i$th iteration.  Note that $\cO_1 = \cO$.  In the $i$th
iteration, hyperedges from $\cO_i$ are assigned paths from $T$ using
the following rules. Also the end of the iteration, $\cL_1^{i+1},
\cL_2^{i+1}, \cT_1^{i+1}, \cT_2^{i+1}$ are set to $\cL_1^{i},
\cL_2^{i}, \cT_1^{i}, \cT_2^{i}$ respectively, along with some
case-specific changes mentioned in the rules below.

\noindent
\begin{enumerate}[I.]
\item {\bf Iteration 1:} Let $S=\{X_1,\ldots,X_s\}$ denote the
  super-marginal hyperedges from $\cO_1$.  If $|S|=s \neq p$, then
  exit reporting failure.  Else, assign to each $X_j \in S$, the path
  from $R_j$ such that the path contains the leaf in $R_j$.  This path
  is refered to as $\cl(X_j)$.  Set $p_1(X_j)=|X|, p_2(X_j)=s(X_j)=0$.
  Hyperedges in $S$ are not added to $\cO_2$ but are added to
  $\cL_1^2$ and all other hyperedges are added to
  $\cO_2$.
\item {\bf Iteration $i$:} Let $X$ be a hyperedge from $\cO_i$ such
  that there exists $Y \in \cL_1^i \cup \cL_2^i$ and $X \overlap
  Y$. Further let $Z \in \cL_1^i \cup L_2^i$ such that $Z \overlap Y$.
  If $X \in \cT_2^i$, and if there are multiple $Y$ candidates then
  any $Y$ is selected.  On the other hand, if $X \in \cT_1^i$, then
  $X$ has a partial path assignment, $\cl'(X)$ from a previous
  iteration, say from ray $R_j$. Then, $Y$ is
  chosen such that $X \cap Y$ has a non-empty intersection with a ray
  different from $R_j$.  The key things that are done in assigning a
  path to $X$ are as follows. The {\em end} of path $\cl(Y)$ where
  $\cl(X)$ would overlap is found, and then based on this the
  existence of a feasible assignment is decided.  It is important to
  note that since $X \overlap Y$, $\cl(X) \overlap \cl(Y)$ in any
  feasible assignment.  Therefore, the notion of the {\em end} at
  which $\cl(X)$ and $\cl(Y)$ overlap is unambiguous, since for any
  path, there are two end points.
  \begin{enumerate}
  \item \label{iendpoint} {\em End point of $\cl(Y)$ where $\cl(X)$ overlaps
      depends on $X \cap Z$:} If $X \cap Z
    \neq \emptyset$, then $\cl(X)$ has an overlap of $|X \cap Y|$ at that
    end of $\cl(Y)$ at which $\cl(Y)$ and $\cl(Z)$ overlap.  If $X
    \cap Z = \emptyset$, then $\cl(X)$ has an overlap of $|X \cap Y|$ at
    that end of $\cl(Y)$ where $\cl(Y)$ and $\cl(Z)$ do not intersect.
  \item {\em Any path of length $s(X)$ at the appropriate end contains
      $r$:} If $X \in \cT_1^i$ then after finding the appropriate end
    as in step~\ref{iendpoint} this the unique path of length $s(X)$
    should end at $r$.  If not, we exit reporting failure.  Else,
    $\cl(X)$ is computed as union of $\cl'(X)$ and this path. If any
    three-way intersection cardinality is violated with this new
    assignment, then exit, reporting failure.  Otherwise, $X$ is added
    to $\cL_2^{i+1}$.  On the other hand, if $X \in \cT_2^i$, then
    after step~\ref{iendpoint}, $\cl(X)$ or $\cl'(X)$ is unique up to
    the root and including it. Clearly, the vertices $\cl(X)$ or
    $\cl'(X)$ contains depends on $|X|$ and $|X \cap Y|$.  If any
    three way intersection cardinality is violated due to this
    assignment, exit, reporting failure.  Otherwise,
    $p_1(X)$ is updated as the length of the assigned path, and $s(X)
    = |X|-p_1(X)$.  If $s(X) > 0$, then $X$ is added to $\cT_1^{i+1}$.
    If $s(X)=0$, then $X$ is added to $\cL_1^{i+1}$.
  \item {\em The unique path of length $s(X)$ overlapping at the
      appropriate end of $Y$ does not contain $r$:} In this case,
    $\cl(X)$ is updated to include this path.  If any three way
    intersection cardinality is violated, exit, reporting failure.
    Otherwise, update $p_1(X)$ and $p_2(X)$ are appropriate, $X$ is
    added to $\cL_1^{i+1}$ or $\cL_2^{i+1}$, as appropriate.
  \end{enumerate}
\end{enumerate}

\noindent {\bf Proof of Correctness and Analysis of Running Time:} It
is clear that the algorithm runs in polynomial time, as at each step,
at most three-way intersection cardinalities need to be checked.
Further, finding super-marginal hyperedges can also be done in
polynomial time, as it involves considering the overlap regions and
checking if the inclusion partial order contains a single minimal
element.  In particular, once the super-marginal edges are identified,
each iteration involes finding the next hyperedge to consider, and
testing for a path to that hyperedge.  To identify the next hyperedge
to consider, we consider the breadth first layering of the hyperedges
with the zeroeth layer consisting of the super-marginal hyperedges.
Since $\cO$ is connected, it follows that all hyperedges of $\cO$ will
be considered by the algorithm.  Once a hyperedge is considered, the
path to be assigned to it can also be computed in constant time.  In
particular, in the algorithm the path to be assigned to $X$ depends on
$\cl(Y), \cl(Z)$, $s(X)$ and the presence or absence of $r$ in the
candidate partial path $\cl'(X)$.  Therefore, once the super-marginal
edges are identified, the running time of the algorithm is linear in
the size of the input.  By the technique used for constructing prime
matrices \cite{wlh02}, the super-marginal edges can be found in linear
time in the input size.  Therefore, the algorithm can be implemented
to run in linear time in the input size.

\noindent
The proof of correctness uses the following main properties:
\begin{enumerate}
\item The $k$-subdivided star has a very symmetric structure.  This
  symmetry is quantified based on the following observation -- either
  there are no feasible path labelings of $\cO$ using paths from $T$,
  or there are exactly $p!$ feasible path labelings.  In other words,
  there is either no feasible assignment, or effectively a unique
  assignment modulo symmetry.
\item The $p$ super-marginal hyperedges, if they exist, will each be
  assigned a path from distinct rays, and each such path contains the
  leaf.
\item For a candidate hyperedge $X$, the partial path assignment
  $\cl'(X)$ is decided by its overlap with $\cl(Y)$ and cardinality of
  intersection with $\cl(Z)$.
\end{enumerate}
These properties are formalized as follows:
\begin{lemma}
  \label{lem:sup-mar}
  If $X \in \cF$ is super-marginal and $\cl$ is a feasible tree path
  labeling to tree $T$, then $\cl(X)$ will contain a leaf in $T$.
\end{lemma}
\begin{proof}\thesisspacing
  Suppose $X \in \cF$ is super-marginal and $(\cF, \cl)$ is a feasible
  path labeling from $T$.  Assume $\cl(X)$ does not have a leaf.  Let
  $R_i$ be one of the rays (or the only ray) $\cl(X)$ is part of.
  Since $X$ is in a connected overlap component, there exists $Y_1 \in
  \cF$ and $X \nsubseteq Y_1$ such that $Y_1 \overlap X$ and $Y_1$ has
  at least one vertex closer to the leaf in $R_i$ than any vertex in
  $X$. Similarly with the same argument there exists $Y_2 \in \cF$
  with same subset and overlap relation with $X$ except it has has at
  least one vertex farther away from the leaf in $R_i$ than any vertex
  in $X$. Clearly $Y_1 \cap X$ and $Y_2 \cap X$ cannot be part of same
  inclusion chain which contradicts that assumption $X$ is
  super-marginal. Thus the claim is proved.
\end{proof}
\begin{lemma}
  If $\cO$ does not have any super-marginal edges, then in any
  feasible path labeling $\cl$ of $\cO$ with paths from $T$ is such
  that, for any hyperedge $X$ for which $\cl(X)$ contains a leaf, $|X|
  \geq k+3$.
\end{lemma}
\begin{proof}\thesisspacing
  The proof of this lemma is by contradiction.  Let $X$ be a
  hyperedges such that $|X| \leq k+2$ and that $\cl(X)$ has a leaf.
  This implies that the overlap regions with $X$, which are captured by
  the overlap regions with $\cl(X)$, will form a single inclusion
  chain. This shows that $X$ is a marginal hyperedge which
  contradicts the assumption that $\cO$ does not have super-marginal
  hyperedges. 
\end{proof}
This lemma is used to prove the next lemma for the case when for all
$X \in \cO$, $|X| \leq k+2$.  The proof is left out as it just uses
the previous lemma and the fact that the hyperedges in $X$ have at
most $k+2$ elements.
\begin{lemma}
  If there is a feasible path labeling for $\cO$ in $T$, then there
  are exactly $p$ super-marginal hyperedges.
\end{lemma}
These lemmas now are used to prove the following theorem.
\begin{theorem}
  Given $\cO$ and a $k$-subdivided star $T$, the above algorithm
  decides correctly if there is a feasible path labeling $\cl$.
\end{theorem}
\begin{proof}\thesisspacing {\em Outline.}
%   If the algorithm outputs a path labeling $\cl$, then it is clear
%   that it is an ICPPL. The reason is that the algorithm checks that
%   three-way intersection cardinalities are preserved in each iteration
%   which ensures \icpplpr~\ref{pr:iii}. Moreover, it is clear that
%   $\cl(X)$ for any $X \in \cO$ is computed by maintaining
%   \icpplpr~\ref{pr:i} and \icpplpr~\ref{pr:ii}. For such a labeling
%   $\cl$, the proof that it is feasible is by induction on $k$. What
%   needs to be shown is that Algorithm~\ref{al:icppl-find-isomorph}
%   successfully runs on input $(\cO, \cl)$. In base case $k=0$, $T$ is
%   a star. The claim is clear by observing that after Filter 1 and one
%   iteration of Filter 2, all the leaves have found their pre-images
%   from support $\cO$.  Therefore, in the induction step, it is clear
%   that after Filter 1 and one iteration of Filter 2, the leaves are
%   assigned pre-images.  Removing the leaves from $T$ and the
%   pre-images from support of $\cO$, results in an ICPPL to a
%   $(k-1)$-subdivided star.  Now we apply the induction hypothesis, and
%   we get a isomorphism between the hypergraph $\cO$ and $\cO^\cl$.
  If the algorithm outputs a path labeling $\cl$, then it is clear
  that it is an ICPPL. The reason is that the algorithm checks that
  three-way intersection cardinalities are preserved in each iteration
  which ensures ICPPL \icpplpr~\ref{pr:iii}. Moreover, it is clear
  that $\cl(X)$ for any $X \in \cO$ is computed by maintaining ICPPL
  \icpplpr~\ref{pr:i} and ICPPL \icpplpr~\ref{pr:ii}. For such a
  labeling $\cl$, the proof that it is feasible is by induction on
  $k$. What needs to be shown is that
  Algorithm~\ref{al:icppl-find-isomorph} successfully runs on input
  $(\cO, \cl)$. In base case $k=0$, $T$ is a star. Also every set is
  at most size 2 ($k+2$) size and thus overlaps are at most 1. If two
  paths share a leaf in \filteri one must be of length 2 and the other
  of length 1. Thus the exit condition is not met. Further, it is also
  clear that the exit condition in \filterii is also not met. Thus
  claim proven for base case.  Now assume the claim to be true when
  target tree is a $(k-1)$-subdivided star. Consider the case of a
  $k$-subdivided star.  We can show that after \filteri and one
  iteration of a modified \filterii {\em all} leaves are assigned
  pre-images.  Removing the leaves from $T$ and the pre-images from
  support of $\cO$, results in an ICPPL to a $(k-1)$-subdivided star.
  Now we apply the induction hypothesis, and we get an isomorphism
  between the hypergraphs $\cO$ and $\cO^\cl$.

  \noindent
  In the reverse direction if there is a feasible path labeling $\cl$,
  then we know that $\cl$ is unique up to isomorphism.  Therefore,
  again by induction on $k$ it follows that the algorithm finds $\cl$.
\end{proof}


% \noindent
% Consider the overlap graph $\bO(\cF)$ of the given hypergraph
% $\cF$. Let $S_{sm} \in \cF$ be such that it is a super-marginal
% hyperedge.  Algorithm~\ref{al:ktree-label} uses $S_{sm}$ along with
% the overlap graph $\bO(\cF)$ to calculate the feasible tree path
% labeling to the $k$-subdivded tree $T$.
%
% \begin{algorithm}[h]
%   \caption{{\tt compute-ksubtree-path-labeling($X, \cF, T$)}}
%   \label{al:ktree-label}
%   \begin{algorithmic}[\lndisplay]
%     \IF{$X = S_{sm}$}
%     \STATE -- TBD --\\
%     \ELSE
%     \STATE -- TBD --\\
%     \ENDIF
%
%   \end{algorithmic}
% \end{algorithm}


% \subsection{temp section from nsnsr09}

% \begin{algorithm}
%   \caption{Basic step in an algorithm to find an ICPIA for a prime
%     matrix $M'$}
%   \label{ds-algo}
%   ICPIA(Set $S$, Integer $p > 0$)

%   \noindent
%   /* {\tt $S \cap S^i \not = \phi$ for some $i \in \{1,\ldots,p\}$,
%     but $S \not\subseteq S^i$, $S^i \not\subseteq S$.  \\ Assigns to
%     $S$ an interval $I$ such that $\{I^1,\ldots,I^p,I\}$ forms an
%     ICPIA for $\{S^1,\ldots,S^p,S\}$.} */
%   \begin{algorithmic}
%     \STATE Let $|S \cap S^i| = z$. \\
%     \STATE Let $I_l$ be the interval such that $|I_l \cap I^i| = z$, $|I_l| = |S|$ and the $z$ common elements are the smallest elements of $I^i$. \\
%     \STATE Let $I_r$ be the interval such that $|I_r \cap I^i| = z$, $|I_r| = |S|$, and the $z$ common elements are the largest elements of $I^i$. \\
%     \IF {$p == 1$}
%     \STATE Assign $I_l$ to $S$ \\
%     \STATE /* {\tt In this case, $I_r$ could also be assigned to $S$.  This will yield the {\bf other} ICPIA} */\\
%     \ELSE \IF{$|I_l \cap I^q| = |S \cap S^q|$ for each $q \in
%       \{1,\ldots,p\}$}
%     \STATE Assign $I_l$ to $S$ and exit.\\
%     \ENDIF \IF{$|I_r \cap I^q| = |S \cap S^q|$ for each $q \in
%       \{1,\ldots,p\}$}
%     \STATE Assign $I_r$ to $S$ and exit.\\
%     \ENDIF \ENDIF \STATE Report no ICPIA and exit.
%   \end{algorithmic}
% \end{algorithm}


% \begin{theorem}
%   Algorithm~\ref{ds-algo} outputs an ICPIA to a prime matrix $M'$
%   \iff there is an ICPIA for $M'$.
% \end{theorem}
% \begin{proof}
%   The only-if part of the theorem is straightforward.  We now show
%   that if there is an ICPIA for $M'$, then Algorithm~\ref{ds-algo}
%   will indeed discover it.  The key fact is that in $M'$ for each
%   set $S$, there is another set $T \in M'$ such that $S \cap T \not
%   = \phi$, and $S$ and $T$ are not contained in each other.  Due to
%   this fact, there are exactly two ICPIAs for $M'$.  The two
%   distinct ICPIAs differ based on the interval assigned to $S_1$,
%   see Algorithm ~\ref{ds-algo}.  If $I_l$ is assigned to $S_1$, then
%   we get one, and the other ICPIA is obtained by assigning $I_r$ to
%   $S_1$.  For each subsequent set, say $S^j$, the interval to be
%   assigned is forced.  It is forced due to the fact that the
%   interval assigned to $S^j$ is based on the interval assigned to
%   $S^i$, where $S^i \cap S^j \not = \phi$, and $S^i \not\subseteq
%   S^j$, and $S^j \not\subseteq S^i$.  Given the fact that the
%   algorithm is an exact implementation of these observations, it
%   follows that Algorithm~\ref{ds-algo} finds an ICPIA if there is
%   one.
% \end{proof}

\section{ TPL on arbitrary trees}
\label{sec:norestraint}

In this section we describe an algorithm for the \CFTPL problem where
the target tree can be any arbitrary tree. In essence, we provide a
characterization for path hypergraphs (see
Section~\ref{sec:pathhypergraph} for definition).  We first study some
properties of the overlap components of the input hypergraph and
introduce some theory in that area. This is in the same vein as the
theory used in \cite{wlh02,nsnrs09} but we extend it to \TPL.  We use
this theory to decompose \CFTPL into subproblems.  Each subproblem is
on a sub-hypergraph of the input, in which for each hyperedge there is
another hyperedge in the sub-hypergraph that overlaps with it. These
sub-hypergraphs are called overlap components (see
Section~\ref{sec:overlapmarginal} for definition). As a consequence of
this characterization, aside from the overlap component subproblems,
we identify two other subproblems that must be solved to obtain an
ICPPL.  The inefficiency of our algorithm in terms of polynomial time
solvability comes from these two subproblems. We leave these subproblems
open to be solved in \p and only mention the obvious brute force
method of solution.

% with which the intersection is {\em
%   strict}- there is a non-empty intersection, but neither is contained
% in the other.  % In
% \cite{wlh02,nsnrs09} where to test for COP in a given matrix, the COP
% problem is solved on an equivalent set of prime matrices.

% \annote{ We refer to this as the Tree Path Assignment problem for an
%   input $(\cF,T)$ pair.}{Add this ``pair'' as a definition in
%   ch:prelims 0 - or should we?}

% In the second part of this paper, we decompose our search for a
% bijection between $U$ and $V(T)$ into subproblems.  

% Finally, we show that Tree Path Assignment is isomorphism-complete.

%\noindent {\bf Finding an assignment of tree paths to a set system.} 
As described by Definition~\ref{def:matrixsetsystem} a set system or
hypergraph can be concisely represented by a binary matrix
\stt the row indices of the matrix denote the vertex set of the
hypergraph and each column bijectively correspond to a hyperedge. And
thus the ideas of feasible \TPL and \ICPPL are also defined for a
binary matrix. If a \TPL $(\cF,\cl,T)$ is feasible, \ie it is an ICPPL
(see Section~\ref{xxxxx} \tnote[dire]{SECTION NUMBER}) and if $M$ is
the representative matrix for hypergraph $\cF$, then we say that $M$
has an \ICPPL and vice versa.


Consider the overlap graph and overlap components of $\bO(\cF)$
defined in Section~\ref{sec:overlapmarginal}.  We use this to
decompose $M$ as described in \cite{wlh02,nsnrs09}.  A {\em prime
  submatrix} of $M$ is defined as the matrix formed by a set of
columns of $M$ which correspond to an overlap component.  Let us
denote the prime submatrices of $M$ by $M_1,\ldots,M_p$, each
corresponding to one of the $p$ overlap components of $\cF$. Clearly,
two distinct prime submatrices have mutually exclusive sets of columns
of $M$.  Let $col(M_i)$ be the set of columns in the submatrix $M_i$.
The support of a prime submatrix $M_i$ and support of a
set of prime submatrices $X$ are defined as follows. Note that for each $i$,
$supp(M_i) \subseteq U$ where $U$ is the vertex set of hypergraph $\cF$.
\begin{align*}
supp(M_i) &= \displaystyle \bigcup_{j \in col(M_i)}S_j\\  
supp(X) &= \displaystyle  \bigcup_{M \in X} supp(M)
\end{align*}


% A
% set system can be concisely represented by a binary matrix where the
% row indices denote the universe of the set system and the column
% indices denote each of the sets. Let the binary matrix be $M$ with
% order $n \times m$, the set system be $\cF = \{S_i \mid i \in [m]\}$,
% universe of set system $U = \{x_1, \dots ,x_n\}$. If $M$ represents
% $\cF$, $|U| = n, |\cF| = m$. Thus $(i,j)$th element of $M$, $M_{ij} =
% 1$ \iff $x_i \in S_j$. 

% If $\cF$ has a feasible tree path assignment
% (ICPPL) $\cA = \{(S_i,P_i) \mid i \in [m]\}$, then we say its
% corresponding matrix $M$ has an ICPPL. Conversly we say that a matrix
% $M$ has an ICPPL if there exists an ICPPL $\cA$ as defined
% above.\\
%\noindent

% We now define the strict intersection graph or overlap graph of
% $\cF$. This graph occurs at many places in the literature, see for
% example \cite{kklv10, wlh02, nsnrs09}.  The vertices of the graph
% correspond to the sets in $\cF$.  An edge is present between vertices
% of two sets \iff the corresponding sets have a nonempty intersection
% and none is contained in the other. Formally, intersection graph is
% $G_f = (V_f, E_f)$ such that $V_f = \{v_i \mid S_i \in \cF\}$ and $E_f
% = \{(v_i, v_j) \mid S_i \cap S_j \ne \O \text{ and }S_i \nsubseteq
% S_j, S_j \nsubseteq S_i \}$. 

\def \primeless {\preccurlyeq}
\noindent
Consider the binary relation $\primeless$ defined on the set of
prime submatrices $\bP = \{M_i \mid i \in [p]\}$ as follows.
\begin{align*}
  \primeless \ = \ &\{(M_i,M_j) \mid \exists S \in
  M_i \text{ and } \exists S' \in M_j \text{ \stt\ } S \subseteq S'\} \\
  \cup \  &\{(M_i,M_i) \mid i \in [p]\}
\end{align*}

% $  \primeless = \{(M_i,M_j) \mid \text{ a set } S \in
%   M_i \text{ is contained in a set } S' \in M_j\} \cup \{(M_i,M_i) | 1
%   \leq i \leq p\} $

This relation is the same as that defined in \cite{nsnrs09}. The prime
submatrices and the above relation can be defined for any hypergraph
since an overlap graph is defined for any hypergraph. We will use this structure of prime submatrices to present our
results on an ICPPL for a hypergraph $\cF$. 
Now we present a few lemma and a theorem that show that $\primeless$ is
a partial order. An alternate notation for $(M_i,M_j) \in \primeless$
is $M_i \primeless M_j$.

% Recall the following
% lemmas, and theorem that $\preccurlyeq$ is a partial order, from
% \cite{nsnrs09}.

\begin{lemma}[{\cite[Lem.~3]{nsnrs09}}] %
  \label{lem:containment} If % $(M_i,M_j) \in
%   \preccurlyeq$
  $M_i \primeless M_j$, then there is a set $S' \in M_j$ such that for
  each $S \in M_i$, $S \subseteq S'$.
\end{lemma}
\begin{lemma}[{\cite[Lem.~4]{nsnrs09}}] %
  For each pair of prime submatrices $M_i, M_j$, either $M_i \not\primeless M_j$
  or $M_j \not\primeless M_i$.
% $(M_i,M_j) \not\in
%   \preccurlyeq$ or $(M_j,M_i) \not\in \preccurlyeq$.
\end{lemma}
\begin{lemma}[{\cite[Lem.~5]{nsnrs09}}] %
  If $M_i \primeless M_j$ and $M_i \primeless M_k$,
  then $M_i \primeless M_k$.
%   If $(M_i,M_j) \in \preccurlyeq $ and $(M_j,M_k) \in \preccurlyeq$,
%   then $(M_i,M_k) \in \preccurlyeq$.
\end{lemma}
\begin{lemma}[{\cite[Lem.~6]{nsnrs09}}] %
  If $M_i \primeless M_j$ and $M_i \primeless M_k$,
  then either $M_j \primeless M_k$ or $M_k \primeless M_j$.
%   If $(M_i,M_j) \in \preccurlyeq$ and $(M_i,M_k) \in \preccurlyeq$,
%   then either $(M_j,M_k) \in \preccurlyeq$ or $(M_k,M_j) \in
%   \preccurlyeq$.
\end{lemma}

\begin{theorem} [{\cite[Th.~4]{nsnrs09}}] %
  \label{thm:partitionold} %
  Let $M$ be a binary matrix and $\bP$ be the set of prime submatrices
  of $M$. Then the following hold true.
  \parindent \defindent
  \begin{enumerate}[i. ]
  \item $\primeless$ is a partial order on $\bP$.
  \item $\primeless$ uniquely partitions $\bP$ into $\bP_1, \bP_2
    \ldots ,\bP_r$ for some $r \ge 1$.
  \item \label{thm:i:totalorder} If $M$ has \COP, then for each $i \in
    [r]$, $\primeless$ induces a total order in $\bP_i$.
  \end{enumerate}
% $\preccurlyeq$ is a partial
%   order on the set of prime submatrices of $M$.  Further, it uniquely
%   partitions the prime submatrices of $M$ such that on each set in
%   the partition $\preccurlyeq$ induces a total order.
\end{theorem}

% \begin{theorem} % [{\cite[Th.~4]{nsnrs09}}] %
%   \label{thm:partitionnew}%
%   \parindent \defindent
%   \begin{enumerate}[i. ]
%   \item $\primeless$ is a partial order on $\bP$.
%   \item $\primeless$ uniquely partitions $\bP$ into $\bP_1, \bP_2
%     \ldots ,\bP_k$ for some $k \ge 1$.
%   \item If $M$ has \COP, then for each $i \in [k]$, $\primeless$
%     induces a total order in $\bP_i$.
%   \end{enumerate}
% \end{theorem}


%   Let $M$ be a binary matrix for a hypergraph
%   with \TPL and $\bP$ be the set of prime submatrices of $M$. Then
%   Theorem~\ref{thm:partitionold} holds true with (iii) changed as
%   follows -- for each $i \in [k]$, $\primeless$ induces an in-tree
%   in $\bP_i$.
Since we are concerned with the generalization of \COP, we generalize
the condition~(\ref{thm:i:totalorder}) in
Theorem~\ref{thm:partitionold} from total order to in-trees as
follows.  The in-tree is derived from the Hasse diagram of
$\primeless$. Each of these in-trees will be on disjoint vertex sets,
which in this case would be disjoint sets of prime-submatrices
$\bP_i$, $i \in [r]$ for some $r > 0$.  For each $\bP_i$, the in-tree
is rooted at a maximal upper bound under $\preccurlyeq$.  The in-trees
are specified by selecting the appropriate edges from the Hasse
diagram associated with $\preccurlyeq$. This is defined in
Theorem~\ref{thm:partition} before which we see the covering relation
for $\primeless$ defined below.
% %D replace \cI with \primeless_c
% Let $\primeless_c$ be the following set:
\begin{align*}
  \primeless_c \ \  = \ \ &\{ (M_i,M_j) \mid M_i \primeless M_j \text{ \stt\ } \nexists
  M_k \text{ s.t. } M_i \primeless M_k \text{, } M_k \primeless M_j \} \\
  \cup \ \ &\{ (M_i,M_i), i \in [p] \}
\end{align*}

It is easy to see that $\primeless_c$ is the covering relation of the partial
order $\primeless$.

\begin{theorem}%
  \label{thm:partition} %
  Let $M$ be a binary matrix and $\bP$ be the set of prime matrices of
  $M$. The partial order $\primeless$ and its covering relation
  $\primeless_c$ are as defined earlier.
  Then the directed graph $X = (\bP, \primeless_c)$ whose vertex
  set is the set of prime submatrices and the edges are given
  by the covering relation $\primeless_c$, is a vertex
  disjoint collection of in-trees and the root of each in-tree is a
  maximal upper bound in $\primeless$.
\end{theorem}
\begin{proof}\thesisspacing
  To observe that $X$ is a collection of in-trees, we observe that for
  vertices corresponding to maximal upper bounds, no outgoing edge is
  present in $\primeless_c$.  Secondly, for each other element, exactly one
  outgoing edge is chosen, and for the minimal lower bound, there is
  no incoming edge.  Consequently, $X$ is acyclic, and since each
  vertex has at most one edge leaving it, it follows that $X$ is a
  collection of in-trees, and for each in-tree, the root is a maximal
  upper bound in $\primeless$.  
\end{proof}
Let the partition of $X$ given by Theorem \ref{thm:partition} be
$\{X_1,\ldots,X_r\}$.  Further, each in-tree itself can be layered
based on the distance from the root.  The root is considered to be at
level zero. For $j \geq 0$, Let $X_{i,j}$ denote the set of prime
matrices in level $j$ of in-tree $X_i$.

\begin{lemma}
  \label{lem:subicppa}
  Let $M$ be a matrix and let $X$ be the directed graph whose vertices
  are in correspondence with the prime submatrices of $M$.  Further
  let $\{X_1,\ldots,X_r\}$ be the partition of $X$ into in-trees as
  defined above.  Then, matrix $M$ has an ICPPL in tree $T$ \iff $T$
  can be partitioned into vertex disjoint subtrees $\{T_1, T_2, \dots
  T_r\}$ such that, for each $1 \leq i \leq r$, the set of prime
  submatrices corresponding to vertices in $X_i$ has an ICPPL in
  $T_i$.
\end{lemma}
\begin{proof}\thesisspacing
  Let us consider the reverse direction first.  Let us assume that $T$
  can be partitioned into $T_1, \ldots, T_r$ such that for each $1
  \leq i \leq r $, the set of prime submatrices corresponding to
  vertices in $X_i$ has an ICPPL in $T_i$.  It is clear from the
  properties of the partial order $\preccurlyeq$ that these ICPPLs
  naturally yield an ICPPL of $M$ in $T$.  The main property used in
  this inference is that for each $1 \leq i \neq j \leq r$, $supp(X_i)
  \cap supp(X_j) = \phi$.

\noindent
To prove the forward direction, we show that if $M$ has an ICPPL, say
$\cA$, in $T$, then there exists a partition of $T$ into vertex
disjoint subtree $T_1, \ldots, T_r$ such that for each $1 \leq i \leq
r$, the set of prime submatrices corresponding to vertices in $X_i$
has an ICPPL in $T_i$.  For each $1 \leq i \leq r$, we define based on
$\cA$ a subtree $T_i$ corresponding to $X_i$.  We then argue that the
trees thus defined are vertex disjoint, and complete the proof.
Consider $X_i$ and consider the prime submatrix in $X_{i,0}$.
Consider the paths assigned under $\cA$ to the sets in the prime
submatrix in $X_{i,0}$.  Since the component in $G_f$ corresponding
to this matrix is a connected component, it follows that union of
paths assigned to this prime-submatrix is a subtree of $T$.  We call
this sub-tree $T_i$.  All other prime-submatrices in $X_i$ are
assigned paths in $T_i$ since $\cA$ is an ICPPL, and the support of
other prime submatrices in $X_i$ are contained in the support of the
matrix in $X_{i,0}$.  Secondly, for each $1 \leq i \neq j \leq r$,
$supp(X_i) \cap supp(X_j) = \phi$, and since $\cA$ is an ICPPL, it
follows that $T_i$ and $T_j$ are vertex disjoint.  Finally, since $|U|
= |V(T)|$, it follows that $T_1, \ldots, T_r$ is a partition of $T$
into vertex disjoint sub-trees such that for each $1 \leq i \leq r$,
the set of matrices corresponding to nodes in $X_i$ has an ICPPL in
$T_i$.  Hence the lemma.
\end{proof}
The essence of the following lemma is that an ICPPL only needs to be
assigned to the prime submatrix corresponding to the root of each
in-tree, and all the other prime submatrices only need to have an
Intersection Cardinality Preserving Interval Assignments (ICPIA).
Recall, an ICPIA is an assignment of intervals to sets such that the
cardinality of an assigned interval is same as the cardinality of the
interval, and the cardinality of intersection of any two sets is same
as the cardinality of the intersection of the corresponding intervals.
It is shown in \cite{nsnrs09} that the existence of an ICPIA is a
necessary and sufficient condition for a matrix to have COP.  We
present the pseudo-code to test if $M$ has an ICPPL in $T$.
\begin{lemma} \label{lem:rooticppa} Let $M$ be a matrix and let $X$ be
  the directed graph whose vertices are in correspondence with the
  prime submatrices of $M$.  Further let $\{X_1,\ldots,X_r\}$ be the
  partition of $X$ into in-trees as defined earlier in this section.
  Let $T$ be the given tree and let $\{T_1, \ldots, T_r\}$ be a given
  partition of $T$ into vertex disjoint sub-trees.  Then, for each $1
  \leq i \leq r$, the set of matrices corresponding to vertices of
  $X_i$ has an ICPPL in $T_i$ if and only if the matrix in $X_{i,0}$
  has an ICPPL in $T_i$ and all other matrices in $X_i$ have an {\bf
    {\em ICPIA}}.
\end{lemma}
\begin{proof}\thesisspacing
  The proof is based on the following fact- $\preccurlyeq$ is a
  partial order and $X$ is a digraph which is the disjoint union of
  in-trees.  Each edge in the in-tree is a containment relationship
  among the supports of the corresonding submatrices. Therefore, any
  ICPPL to a prime submatrix that is not the root is contained in a
  path assigned to the sets in the parent matrix.  Consequently, any
  ICPPL to the prime submatrix that is not at the root is an ICPIA,
  and any ICPIA can be used to construct an ICPPL to the matrices
  corresponding to nodes in $X_i$ provided the matrix in the root has
  an ICPPL in $T_i$.  Hence the lemma.
\end{proof}
Lemma \ref{lem:subicppa} and Lemma \ref{lem:rooticppa} point out two
algorithmic challenges in finding an ICPPL for a given set system
$\cF$ in a tree $T$.  Given $\cF$, finding $X$ and its partition
$\{X_1,\ldots,X_r\}$ into in-trees can be done in polynomial time.  On
the other hand, as per lemma \ref{lem:subicppa} we need to parition
$T$ into vertex disjoint sub-trees $\{T_1, \ldots, T_r\}$ such that
for each $i$, the set of matrices corresponding to nodes in $X_i$ have
an ICPPL in $T_i$.  This seems to be a challenging step, and it must
be remarked that this step is easy when $T$ itself is a path, as each
individual $T_i$ would be sub-paths.  The second algorithmic challenge
is identified by lemma \ref{lem:rooticppa} which is to assign an ICPPL
from a given tree to the matrix associated with the root node of
$X_i$.
\begin{algorithm}[h]
  \caption{Algorithm to find an ICPPL for a matrix $M$ on tree $T$:
    $main\_ICPPL(M, T$)}
  \label{al:icppa-main}
  \begin{algorithmic}
    \STATE Identify the prime submatrices. This is done by
    constructing the strict overlap graph and identify connected
    components.  Each connected component yields a prime submatrix.
    \\ 
    \STATE Construct the partial order $\preccurlyeq$ on the set of
    prime submatrices.  \\ 
    \STATE Construct the partition $X_1,\ldots,X_r$ of the prime
    submatrices induced by $\preccurlyeq$ \\
    \STATE For each $1 \leq i \leq r$, Check if all matrices except
    those in $X_{i,0}$ has an ICPIA.  If a matrix does not have ICPIA
    exit with a negative answer.  To check for the existence of ICPIA,
    use the result in \cite{nsnrs09}.  \STATE Find a partition of
    $T_1, \ldots, T_r$ such that matrices in $X_{i,0}$ has an ICPPL in
    $T_i$.  If not such partition exists, exit with negative answer.
  \end{algorithmic}
\end{algorithm}


\section[Complexity]{Complexity of Tree Path Assignment-A Discussion}
\label{sec:tplcomplexity}
Recall that the input to the Tree Path Assignment question is an order
pair $(\cF,T)$ where $\cF$ is a family of subsets of an universe $U$,
and $T$ is a tree such that $|V(T)| = |U|$.  The question is to come
up with a bijection from $U$ to $V(T)$ such that the image of each set
in $\cF$ is a path in $T$.

\tnote[dire]{it is known that if the given tree is a path a
feasible assignment can be found in polynomial time, and we observe
that it can actually be done in logspace. }

We also point out Consecutive Ones Testing is in Logspace from two
different results in the literature \cite{kklv10, mcc04}. To the best
of our knowledge this observation has not been made earlier.


\subsection{Consecutive Ones Testing is in Logspace}
\label{sec:cotlogspace}
While Tree Path Assignment is isomorphism-complete, it is polynomial
time solvable when the given tree is a path.  Indeed, in this case we
encounter a restatement of matrices with the COP.  The known
approaches to testing for COP fall into two categories: those that
provide a witness when the input matrix does not have COP, and those
that do not provide a witness.  The first linear time algorithm for
testing COP for a binary matrix was using a data structure called PQ
trees, which represent all COP orderings of $M$, invented by
\cite{bl76}. There is a PQ tree for a matrix \iff the matrix has COP.
Indeed, this is an algorithmic characterization of the consecutive
ones property and the absence of the PQ-tree does not yield any
witness to the reason for failure.  A closely related data structure
is the generalized PQ tree in \cite{mcc04}.  In generalized PQ tree
the P and Q nodes are called prime and linear nodes. Aside from that,
it has a third type of node called degenerate nodes which is present
only if the set system does not have COP \cite{mcc04}.  Using the idea
of generalized PQ tree, \cite{mcc04} proves that checking for
bipartiteness in the certain incomparability graph is sufficient to
check for COP.  \cite{mcc04} invented a certificate to confirm when a
binary matrix does not have COP.  \cite{mcc04} describes a graph
called incompatibility graph of a set system $\cF$ which has vertices
$(a,b), a \ne b$ for every $a, b \in U$, $U$ being the universe of the
set system. There are edges $((a,b),(b,c))$ and $((b,a),(c,b))$ if
there is a set $S \in \cF$ such that $a, c \in S$ and $b \notin S$. In
other words the vertices of an edge in this graph represents two
orderings that cannot occur in a consecutive ones ordering of $\cF$.
\begin{theorem}[Theorem 6.1, \cite{mcc04}]
  Let $\cF$ be an arbitrary set family on domain $V$. Then $\cF$ has
  the consecutive ones property if and only if its incompatibility
  graph is bipartite, and if it does not have the consecutive ones
  property, the incompatibility graph has an odd cycle of length at
  most $n+3$.
\end{theorem}
This theorem gives a certificate as to why a given matrix does not
have COP.  Similarly, the approach of testing for an ICPIA in
\cite{nsnrs09} also gives a different certificate- a prime submatrix
that does not have an ICPIA.  Further, the above theorem can be used
to check if a given matrix has COP in logspace by checking if its
incompatibility graph is bipartite. \cite{rei84} showed that checking
for bipartiteness can be done in logspace. Thus we conclude that
consecutive ones testing can be done in logspace.

\noindent
More recently, \cite{kklv10} showed that interval graph isomorphism
can be done in logspace. Their paper proves that a canon for interval
graphs can be calculated in logspace using an interval hypergraph
representation of the interval graph with each hyperedge being a set
to which an interval shall be assigned by the canonization
algorithm. An overlap graph (subgraph of intersection graph, edges
define only strict intersections and no containment) of the hyperedges
of the hypergraph is created and canons are computed for each overlap
component. The overlap components define a tree like relation due to
the fact that two overlap components are such that either all the
hyperedges of one is disjoint from all in the other, or all of them
are contained in one hyperedge in the other. This is similar to the
containment tree defined in \cite{nsnrs09} and in this paper. Finally
the canon for the whole graph is created using logspace tree
canonization algorithm from \cite{sl92}. The interval labelling done
in this process of canonization is exactly the same as the problem of
assigning feasible intervals to a set system, and thus the problem of
finding a COP ordering in a binary matrix \cite{nsnrs09}.

\begin{theorem}[Theorem 4.7, \cite{kklv10}]
  \label{th:canonlabel}
  Given an interval hypergraph $\cH$, a canonical interval labeling
  $l_H$ for $H$ can be computed in FL.
\end{theorem}


We present the following reduction to see that COP testing is indeed
in logspace. Given a binary matrix $M$ of order $n \times m$, let $S_i
= \{j \mid M[j,i]=1 \}$. Let $\cF = \{S_i \mid i \in [m] \}$ be this
set system. Construct a hypergraph $\cH$ with its vertex set being
$\{1, 2, \dots n\}$. The edge set of $\cH$ is isomorphic to
$\cF$. Thus every edge in $\cH$ represents a set in the given set
system $\cF$. Let this mapping be $\pi: E(\cH) \rightarrow \cF$. It is
easy to see that if $M$ has COP, then $\cH$ is an interval
hypergraph. From theorem \ref{th:canonlabel}, it is clear that the
interval labeling $l_{\cH}: V(\cH) \rightarrow [n]$ can be calculated
in logspace. Construct sets $I_i = \{ \l_{\cH}(x) \mid x \in E, E \in
E(\cH), \pi(E) = S_i\}$, for all $i \in [m]$. Since $\cH$ is an
interval hypergraph, $I_i$ is an interval for all $i \in [m]$, and is
the interval assigned to $S_i$ if $M$ has COP.

Now we have the following corollary.
\begin{corollary}
  \label{cor:coplog}
  If a binary matrix $M$ has COP then the interval assignments to each
  of its columns can be calculated in FL.
\end{corollary}

\noindent
Finally, we conclude by asking about the complexity of Tree Path
Assignment restricted to other subclasses of trees.  In particular, is
Tree Path Assignment in caterpillars easier than Tree Path assignment
in general trees.



% \noindent
% It has been long known that interval graph recognition is in
% logspace\cite{rei84}. Recently interval graph isomorphism was also
% shown to be logspace decidable using a logspace canonization
% algorithm by \cite{kklv10}.  This result is built on top of logspace
% results of undirected graph connectivity \cite{rei08}, logspace
% tractability using a certain logical formalism called FP+C and
% modular decomposition of interval graphs\cite{lau10} etc.  Interval
% graphs are closely connected to binary matrices with COP. The
% maximal clique vertex incidence matrix (matrix with rows
% representing maximal cliques and columns representing vertices of a
% graph) has COP on columns \iff the graph is an interval
% graph\cite{fg65}. This follows from the interval graph
% characterization by \cite{gh64}. Due to this close relation it is
% natural to see if consecutive ones property can be
% tested in logspace. \\
% \noindent
% We also explore some extensions of the interval assignment problem
% in \cite{nsnrs09}, namely caterpillar path assignment problem.

% We present a logspace algorithm here that uses the ICPIA
% characterization of binary matrices with COP (set system associated
% with such a matrix)\cite{nsnrs09}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DUMMYTOC Assignment\tnote{Merge
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   with the original charac
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   section}}
% \label{feasible}
% Consider a path assignment $\cA = \{(S_i, P_i) \mid S_i \in \cF, P_i
% \text{ is a path from $T$}, i \in [m]\}$ to a set system $\cF =
% \{S_i \mid S_i \subseteq U, i \in [m]\}$, were $T$ is a given tree,
% $U$ is the set system's universe and $m$ is the number of sets in
% $\cF$. We call $\cA$ an {\em Intersection Cardinality Preserving
%   Path Assignment (ICPPL)} if it has the following properties.

% \begin{enumerate}
% \item [i.]  $|S_i| = |P_i|$ for all $i \in [m]$
% \item [ii.] $|S_i \cap S_j| = |P_i \cap P_j|$ for all $i,j \in [m]$
%   % \item [iii.] $|\bigcup_{i \in J} S_i| = |\bigcup_{i \in J} P_i|$
%   %   for all $J \subseteq I$\footnote{TBD: this is needed now to
%   %     fix
%   %     some proofs}
% \item [iii.] $|S_i \cap S_j \cap S_k| = |P_i \cap P_j \cap P_k|$ for
%   all $i,j,k \in [m]$
% \end{enumerate}

% \begin{lemma}
%   \label{lem:setminuscard}
%   If $\cA$ is an ICPPL, and $(S_1, P_1),(S_2, P_2),(S_3, P_3) \in
%   \cA$, then $|S_1 \cap (S_2 \setminus S_3)| = |P_1 \cap (P_2
%   \setminus P_3)|$.
% \end{lemma}
% \begin{proof}
%   $|S_1 \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| =
%   |S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to conditions (ii)
%   and (iii) of ICPPL, $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| =
%   |P_1 \cap P_2| - |P_1 \cap P_2 \cap P_3| = |(P_1 \cap P_2)
%   \setminus P_3| = |P_1 \cap (P_2 \setminus P_3)|$. Thus lemma is
%   proven. %\qed
% \end{proof}

% \begin{lemma}
%   \label{lem:fourpaths} Consider four paths in a tree $Q_1, Q_2,
%   Q_3, Q_4$ such that they have nonempty pairwise intersection and
%   $Q_1, Q_2$ share a leaf. Then there exists distinct $i, j, k \in
%   \{1,2,3,4\}$ such that, $Q_1 \cap Q_2 \cap Q_3 \cap Q_4 = Q_i \cap
%   Q_j \cap Q_k$.
% \end{lemma}
% \begin{proof}\thesisspacing
%   {\em Case 1:} w.l.o.g, consider $Q_3 \cap Q_4$ and let us call it
%   $Q$. This is clearly a path (intersection of two paths is a path).
%   %   Since $Q_1, Q_2$ share a leaf, the following are paths $Q_1
%   %   \setminus Q_2$, $Q_2 \setminus Q_1$, $Q_1 \cap Q_2$ and they
%   %   are
%   %   mutually disjoint.
%   Suppose $Q$ does not intersect with $Q_1 \setminus Q_2$, i.e. $Q
%   \cap (Q_1 \setminus Q_2) = \O$. Then $Q \cap Q_1 \cap Q_2 = Q \cap
%   Q_2$. Similarly, if $Q \cap (Q_2 \setminus Q_1) = \O$, $Q \cap Q_1
%   \cap Q_2 = Q \cap Q_1$. Thus it is clear that if the intersection
%   of any two paths does not intersect with any of the set
%   differences of the remaining two paths, the claim in the lemma is
%   true.
%   %   Note that $Q_1 \setminus Q_2$ and $Q_2
%   %   \setminus Q_1$ are paths because $Q_1, Q_2$ share a leaf.\\
%   {\em Case 2:} Let us consider the compliment of the previous
%   case. i.e. the intersection of any two paths intersects with both
%   the set differences of the other two. First let us consider $Q
%   \cap (Q_1 \setminus Q_2) \ne \O$ and $Q \cap (Q_1 \setminus Q_2)
%   \ne \O$, where $Q = Q_3 \cap Q_4$. Since $Q_1$ and $Q_2$ share a
%   leaf, there is exactly one vertex at which they branch off from
%   the path $Q_1 \cap Q_2$ into two paths $Q_1 \setminus Q_2$ and
%   $Q_2 \setminus Q_1$. Let this vertex be $v$. It is clear that if
%   path $Q_3 \cap Q_4$, must intersect with paths $Q_1 \setminus Q_2$
%   and $Q_2 \setminus Q_1$, it must contain $v$ since these are paths
%   from a tree. Moreover, $Q_3 \cap Q_4$ intersects with $Q_1 \cap
%   Q_2$ at exactly $v$ and only at $v$ which means that $Q_1 \cap
%   Q_2$ does not intersect with $Q_3 \setminus Q_4$ or $Q_4 \setminus
%   Q_3$ which contradicts initial condition of this case. Thus this
%   case cannot occur and case 1 is the only possible scenario. \\
%   Thus lemma is proven %\qed
% \end{proof}


% \noindent
% In the remaining part of this section we show that a path assignment
% is feasible if and only if it is an ICPPL.  One direction of this
% claim is clear: that is a path assignment is feasible, then all
% intersection cardinalities are preserved, that is the path
% assignment is an ICPPL.  The reason is that a feasible path
% assignment has an associated bijection between $U$ and $V(T)$ such
% that the sets map to paths.  The rest of the section is devoted to
% constructively proving that it is sufficient, for the existence of a
% bijection, for a path assignment to be an ICPPL.  At a top-level,
% the constructive approaches refine the path assignment iteratively,
% such that at the end of each iteration we have a path assignment,
% and finally we have a family of bijections.  First we present and
% then prove the correctness of Algorithm \ref{al:filterone}.  This algorithm
% refines the path assignment by considering pairs of paths that share
% a leaf.

% \begin{algorithm}[h]
%   \caption{Permutations from an ICPPL $\{(S_i,P_i) | i \in I\}$}
%   \label{al:filterone}
%   \begin{algorithmic}
%     \STATE Let $\Pi_0=\{(S_i,P_i)| i \in I\}$\\
%     \STATE $j = 1$;
%     \label{shareleaf} \WHILE {There is $(P_1,Q_1), (P_2,Q_2) \in
%       \Pi_{j-1}$ with $Q_1$ and $Q_2$ having a common leaf} \STATE
%     $\Pi_j= \Pi_{j-1} \setminus \{(P_1,Q_1),(P_2,Q_2)\}$;
%     \label{setbreak}\STATE $\Pi_j = \Pi_j \cup \{(P_1 \cap P_2,Q_1
%     \cap Q_2), (P_1 \setminus P_2,Q_1 \setminus Q_2), (P_2 \setminus
%     P_1, Q_2 \setminus Q_1)\}$; \STATE $j = j+1$; \ENDWHILE \STATE
%     $\Pi = \Pi_j$; \STATE Return $\Pi$;
%   \end{algorithmic}
% \end{algorithm}

% \begin{lemma}
%   \label{lem:invar1}
%   In Algorithm \ref{al:filterone}, at the end of $j$th iteration, $j \ge
%   0$, of the while loop of Algorithm \ref{al:filterone}, the following
%   invariants are maintained.
%   \begin{itemize}
%   \item {\em Invariant I:} $Q$ is a path in $T$ for each $(P,Q) \in
%     \Pi_j$
%   \item {\em Invariant II:} $|P|=|Q|$ for each $(P,Q) \in \Pi_j$
%   \item {\em Invariant III:} For any two $(P,Q), (P',Q') \in \Pi_j$,
%     $|P' \cap P''|=|Q' \cap Q''|$.
%   \item {\em Invariant IV:} For any three, $(P',Q'), (P'',Q''), (P,
%     Q) \in \Pi_j$, $|P' \cap P'' \cap P|=|Q' \cap Q'' \cap Q|$.
%   \end{itemize}
% \end{lemma}
% \begin{proof}
%   Proof is by induction on the number of iterations, $j$. In the
%   rest of the proof, the term ``new sets'' will refer to the new
%   sets added in $j$th iteration as defined in line \ref{setbreak} of
%   Algorithm \ref{al:filterone}, i.e. the following three assignment pairs
%   for some $(P_1,Q_1), (P_2,Q_2) \in \Pi_{j-1}$ where $Q_1$ and
%   $Q_2$ intersect and share a leaf: $(P_1 \cap P_2, Q_1 \cap Q_2)$,
%   or $(P_1 \setminus P_2, Q_1 \setminus Q_2)$, or $(P_2 \setminus
%   P_1, Q_2
%   \setminus Q_1)$.\\
%   \noindent
%   The base case, $\Pi_0 = \{(S_i,P_i) \mid i \in [m]\}$, is
%   trivially true since it is the input which is an ICPPL.  Assume
%   the lemma is true till the $j-1$ iteration. Consider $j$th
%   iteration:\\
%   \noindent
%   If $(P,Q)$, $(P',Q')$ and $(P'',Q'')$ are in $\Pi_{j}$ and
%   $\Pi_{j-1}$, all the invariants are
%   clearly true because they are from $j-1$ iteration.\\
%   If $(P,Q)$ is in $\Pi_{j}$ and not in $\Pi_{j-1}$, then it must be
%   one of the new sets added in $\Pi_j$. Since $(P_1,Q_1)$ and
%   $(P_2,Q_2)$ are from $\Pi_{j-1}$ and $Q_1,Q_2$ intersect and have
%   a common leaf, it can be verified that the
%   new sets are also paths. \\
%   By hypothesis for invariant III, invariant II also holds for
%   $(P,Q)$ no matter which new set in $\Pi_j$ it
%   is.\\
%   To prove invariant III, if $(P,Q)$ and $(P',Q')$ are not in
%   $\Pi_{j-1}$, then they are both new sets and invariant III holds
%   trivially (new sets are disjoint). Next consider $(P,Q), (P',Q')
%   \in \Pi_j$ with only one of them, say $(P',Q')$, in
%   $\Pi_{j-1}$. Then $(P,Q)$ is one of the new sets added in line
%   \ref{setbreak}. It is easy to see that if $(P,Q)$ is $(P_1 \cap
%   P_2, Q_1 \cap Q_2)$, then due to invariant IV in hypothesis,
%   invariant III becomes true in this iteration. Similarly, using
%   lemma \ref{lem:setminuscard} invariant III is proven if $(P, Q)$
%   is $(P_1 \setminus P_2, Q_1 \setminus Q_2)$, or $(P_2 \setminus
%   P_1, Q_2
%   \setminus Q_1)$.\\
%   To prove invariant IV, consider three assignments
%   $(P,Q),(P',Q'),(P'',Q'')$. If at least two of these pairs are in
%   not $\Pi_{j-1}$, then they are any two of the new sets. Note that
%   these new sets are disjoint and hence if $(P',Q'), (P'',Q'')$ are
%   any of these sets, $|P \cap P' \cap P''|=|Q \cap Q' \cap Q''|=0$
%   and invariant IV is true. Now we consider the case if at most one
%   of $(P,Q),(P',Q'),(P'',Q'')$ is not in $\Pi_{j-1}$. If none of
%   them are not in $\Pi_{j-1}$ (i.e. all of them are in $\Pi_{j-1}$),
%   invariant IV is clearly true. Consider the case where exactly one
%   of them is not in $\Pi_{j-1}$. w.l.o.g let that be $(P,Q)$ and it
%   could be any one of the new sets. If $(P,Q)$ is $(P_1 \cap P_2,
%   Q_1 \cap Q_2)$, from lemma \ref{lem:fourpaths} and invariant III
%   hypothesis, invariant IV is proven. Similarly if $(P,Q)$ is any of
%   the other new sets, invariant IV is proven by also using lemma
%   \ref{lem:setminuscard}. %\qed

% \end{proof}

% \noindent
% It can be observed that the output of algorithm \ref{al:filterone} is such
% that every leaf is incident on at most a single path in the new set
% of assignments. This is due to the loop condition at line
% \ref{shareleaf}. Let $v_1$ be the leaf incident on path
% $P_i$. Assign to it any one element from $S_i \setminus \bigcup_{i
%   \ne j} S_j$. Remove $(S_i, P_i)$ from assignments and add
% $(\{x_1\}, \{v_1\}), (S_i \setminus \{x_1\}, P_i \setminus
% \{v_1\})$. Now all assignments except single leaf assignments are
% paths from the subtree $T_0 = T \setminus \{v \mid v \text{ is a
%   leaf in } T\}$.


% \begin{algorithm}[h]
%   \caption{Leaf assignments from an ICPPL $\{(S_i,P_i) | i \in I\}$}
%   \label{al:filtertwo}
%   \begin{algorithmic}
%     \STATE Let $\Pi_0=\{(S_i,P_i)| i \in [m]\}$. Paths are such that
%     no
%     two paths $P_i, P_j, i \ne j$ share a leaf.\\
%     \STATE $j = 1$\\
%     \WHILE {there is a leaf $v$ and a unique $(S_{i_1}, P_{i_1})$
%       such that $v \in P_{i_1}$}
%     \STATE $\Pi_j=   \Pi_{j-1} \setminus \{(S_{i_1}, P_{i_1})\}$\\
%     \STATE $X = S_{i_1} \setminus \bigcup_{i \ne i_1, i \in I}S_i$
%     \IF{$X$ is empty} \STATE exit \ENDIF; \STATE Let $x = $
%     arbitrary element from $X$ \vspace{2mm}

%     \STATE $\Pi_j = \Pi_j \cup \{(S_{i_1} \setminus \{x\}),(P_{i_1}
%     \setminus
%     \{v\}), (\{x\},\{v\})\}$\\
%     \STATE $j = j+1$\\
%     \ENDWHILE
%     \STATE $\Pi = \Pi_j$\\
%     \STATE Return $\Pi$\\
%   \end{algorithmic}
% \end{algorithm}

% \begin{lemma}
%   \label{lem:invar3}
%   In Algorithm \ref{al:filtertwo},for all $j \geq 0$, at the end of the
%   $j$th iteration the four invariants given in lemma
%   \ref{lem:invar1} are valid.
%   %   Moreover, $X$ as defined in the algorithm is non-empty if this
%   %   is
%   %   an ICPPL.
% \end{lemma}
% \begin{proof}
%   First we see that $X = S_{i_1} \setminus \bigcup_{i \ne i_1, i \in
%     I}S_i$ is non empty in every iteration for an ICPPL. Suppose $X$
%   is empty. We know that $v \in P_{i_1} \setminus \bigcup_{i \ne
%     i_1, i \in I}P_i$ since $v$ is in the unique path
%   $P_{i_1}$. Since this is an ICPPL $|S_{i_1}| = |P_{i_1}|$. For any
%   $x \in S_{i_1}$ it is contained in at least two sets due to our
%   assumption. Let $S_{i_2}$ be a second set that contains $x$. We
%   know $v \notin P_{i_2}$. Therefore there cannot exist a
%   permutation that maps elements of $S_{i_2}$ to $P_{i_2}$. This
%   contradicts our assumption that this is an ICPPL. Thus $X$ cannot
%   be empty.


%   We use mathematical induction on the number of iterations for this
%   proof. The term ``new sets'' will refer to the sets added in
%   $\Pi_j$ in the $j$th iteration, i.e. $(P' \setminus \{x\},Q'
%   \setminus \{v\})$ and $(\{x\},\{v\})$ for some $(P',Q')$ in
%   $\Pi_{j-1}$ such that $v$ is a leaf and $Q'$ is the unique path
%   incident on it.\\
%   For $\Pi_0$ all invariants hold because it is output from
%   algorithm \ref{al:filterone} which is an ICPPL. Hence base case is
%   proved.  Assume the lemma holds for $\Pi_{j-1}$. Consider $\Pi_j$
%   and any $(P,Q) \in \Pi_j$. If $(P,Q) $ is in $ \Pi_j$ and
%   $\Pi_{j-1}$ invariants I and II are true because of induction
%   assumption. If it is only in $\Pi_j$, then it is $\{(P' \setminus
%   \{x\}),(Q' \setminus \{v\})$ or $(\{x\},\{v\})$ for some $(P',Q')$
%   in $\Pi_{j-1}$. By definition, $x$ is an element in $P'$ (as
%   defined in the algorithm) and $v$ is a leaf in $Q'$. If $(P,Q)$ is
%   $\{(P' \setminus \{x\}),(Q' \setminus \{v\})$, $Q$ is a path since
%   only a leaf is removed from path $Q'$. We know $|P'| = |Q'|$,
%   therefore $|P' \setminus \{x\}| = |Q' \setminus \{v\}|$. Hence in
%   this case invariants I and II are obvious. It is easy to see these
%   invariants hold if $(P,Q)$ is $(\{x\},\{v\})$.


%   For invariant III consider $(P_1,Q_1),(P_2,Q_2)$ in $\Pi_j$. If
%   both of them are also in $\Pi_{j-1}$, claim is proved. If one of
%   them is not in $\Pi_{j-1}$ then it has to be $\{(P' \setminus
%   \{x\}),(Q' \setminus \{v\})$ or $(\{x\},\{v\})$ for some $(P',Q')$
%   in $\Pi_{j-1}$. Since by definition, $Q'$ is the only path with
%   $v$ and $P'$ the only set with $x$ in the previous iteration,
%   $|P_1 \cap (P' \setminus \{x\})| = |P_1 \cap P'|$ and $|Q_1 \cap
%   (Q' \setminus \{v\})| = |Q_1 \cap Q'|$ and $|P_1 \cap \{x\}| = 0,
%   Q_1 \cap \{v\} = 0$. Thus invariant III is also proven.

%   \noindent
%   To prove invariant IV, consider $(P_1,Q_1),(P_2,Q_2), (P_3,Q_3)$
%   in $\Pi_j$. If exactly one of them, say $P_3 \notin \Pi_{j-1}$, it
%   is one of the new sets. By the same argument used to prove
%   invariant III, $|P_1 \cap P_2 \cap (P' \setminus \{x\})| = |P_1
%   \cap P_2 \cap P'|$ and $|Q_1 \cap Q_2 \cap (Q' \setminus \{x\})| =
%   |Q_1 \cap Q_2 \cap Q'|$. Since $P_1, P_2, P'$ are all in
%   $\Pi_{j-1}$, by induction hypothesis $|P_1 \cap P_2 \cap P'| =
%   |Q_1 \cap Q_2 \cap Q'|$. Also $|P_1 \cap P_2 \cap \{x\}| = 0, Q_1
%   \cap Q_2 \cap \{v\} = 0$.  If two or more of them are not in
%   $\Pi_{j-1}$, then it can be verified that $|P_1 \cap P_2 \cap P_3|
%   = |Q_1 \cap Q_2 \cap Q_3|$ since the new sets in $\Pi_j$ are
%   either disjoint or as follows: assuming $P_1, P_2 \notin
%   \Pi_{j-1}$ and new sets are derived from $(P', Q'), (P'', Q'') \in
%   \Pi_{j-1}$ with $x_1, x_2$ exclusively in $P_1, P_2$,
%   $(\{x_1\},\{v_1\}), (\{x_2\},\{v_2\}) \in \Pi_j $ thus $v_1, v_2$
%   are exclusively in $Q_1, Q_2$ resp. it follows that $|P_1 \cap P_2
%   \cap P_3| = |(P' \setminus \{x_1\}) \cap (P'' \setminus \{x_2\})
%   \cap P_3| = |P' \cap P'' \cap P_3| = |Q' \cap Q'' \cap Q_3| = |(Q'
%   \setminus \{v_1\} \cap Q'' \setminus \{v_2\} \cap Q_3| = |Q_1 \cap
%   Q_2 \cap Q_3|$. Thus invariant IV is also proven.  %\qed
% \end{proof}

% Using algorithms \ref{al:filterone} and \ref{al:filtertwo} we prove the
% following theorem.

% \begin{theorem}
%   \label{th:perm}
%   If $\cA$ is an ICPPL, then there exists a bijection $\sigma : U
%   \rightarrow V(T)$ such that $\sigma(S_i) = P_i$ for all $i \in I$
% \end{theorem}
% \begin{proof}
%   This is a contructive proof. First, the given ICPPL $\cA$ and tree
%   $T$ are given as input to Algorithm \ref{al:filterone}. This yields a
%   ``filtered'' ICPPL as the output which is input to Algorithm
%   \ref{al:filtertwo}.  It can be observed that the output of Algorithm
%   \ref{al:filtertwo} is a set of interval assignments to sets and
%   one-to-one assignment of elements of $U$ to each leaf of $T$. To
%   be precise, it would be of the form $\cB_0 = \cA_0 \cup
%   \cL_0$. The leaf assignments are defined in $\cL_0 = \{ (x_i,v_i)
%   \mid x_i \in U, v_i \in T, x_i \ne x_j, v_i \ne v_j, i \ne j, i,j
%   \in [k] \}$ where $k$ is the number of leaves in $T$. The path
%   assignments are defined in $\cA_0 \subseteq \{(S_i',P_i') \mid
%   S_i' \subseteq U_0, P_i' \text{ is a path from } T_0\}$ where
%   $T_0$ is the tree obtained by removing all the leaves in $T$ and
%   $U_0 = U \setminus \{ x \mid x \text{ is assigned to a leaf in
%   }\cL_0 \}$. Now we have a subproblem of finding the permutation
%   for the path assignment $\cA_0$ which has paths from tree $T_0$
%   and sets from universe $U_0$. Now we repeat the procedure and the
%   path assignment $\cA_0$ and tree $T_0$ is given as input to
%   Algorithm \ref{al:filterone}. The output of this algorithm is given to
%   Algorithm \ref{al:filtertwo} to get a new union of path and leaf
%   assignments $\cB_1 = \cA_1 \cup \cL_1$ defined similar to $\cB_0,
%   \cL_0, \cA_0$. In general, the two algorithms are run on path
%   assignment $\cA_{i-1}$ with paths from tree $T_{i-1}$ to get a new
%   subproblem with path assignment $\cA_i$ and tree $T_{i}$. $T_i$ is
%   the subtree of $T_{i-1}$ obtained by removing all its leaves. More
%   importantly, it gives leaf assignments $\cL_{i}$ to the leaves in
%   tree $T_{i-1}$. This is continued until we get a subproblem with
%   path assignment $\cA_{d-1}$ and tree $T_{d-1}$ for some $d \le n$
%   which is just a path. From the last lemma we know that $\cA_{d-1}$
%   is an ICPPL. Another observation is that an ICPPL with all its
%   tree paths being intervals (subpaths from a path) is nothing but
%   an ICPIA\cite{nsnrs09}.  Let $\cA_{d-1}$ be equal to
%   $\{(S_i'',P_i'') \mid S_i'' \subseteq U_{d-1}, P_i'' \text{ is a
%     path from } T_{d-1} \}$. It is true that the paths $P_i''$s may
%   not be precisely an interval in the sense of consecutive integers
%   because they are some nodes from a tree. However, it is easy to
%   see that the nodes of $T_{d-1}$ can be ordered from left to right
%   and ranked to get intervals $I_i$ for every path $P_i''$ as
%   follows. $I_i = \{[l,r] \mid l = \text{ the lowest rank of the
%     nodes in }P_i'', r = l+|P_i''|-1 \}$. Let asssignment $\cA_d$ be
%   with the renamed paths. $\cA_d = \{ (S_i'', I_i) \mid (S_i'',
%   P_i'') \in \cA_{d-1} \}$. What has been effectively done is
%   renaming the nodes in $T_{d-1}$ to get a tree $T_d$.  The ICPIA
%   $\cA_d$ is now in the format that the ICPIA algorithm requires
%   which gives us the permutation $\sigma' : U_{d-1} \rightarrow
%   T_{d-1}$

%   \noindent
%   $\sigma'$ along with all the leaf assignments $\cL_i$ gives us the
%   permutation for the original path assignment $\cA$.  More
%   precisely, the permutation for tree path assignment $\cA$ is
%   defined as follows. $\sigma: U \rightarrow T$ such that the
%   following is maintained.
%   \begin{align*}
%     \sigma(x) &= \sigma'(x),   \text{ if } x \in U_{d-1} \\
%     &= \cL_i(x), \text{ where $x$ is assigned to a leaf in a
%       subproblem $\cA_{i-1}, T_{i-1}$}
%   \end{align*}

%   \noindent
%   To summarize, run algorithm \ref{al:filterone} and \ref{al:filtertwo} on
%   $T$. After the leaves have been assigned to specific elements from
%   $U$, remove all leaves from $T$ to get new tree $T_0$. The leaf
%   assignments are in $\cL_0$. Since only leaves were removed $T_0$
%   is indeed a tree. Repeat the algorithms on $T_0$ to get leaf
%   assignments $\cL_{1}$. Remove the leaves in $T_0$ to get $T_1$ and
%   so on until the pruned tree $T_d$ is a single path. Now run ICPIA
%   algorithm on $T_d$ to get permutation $\sigma'$. The relation
%   $\cL_0 \cup \cL_1 \cup .. \cup \cL_{d} \cup \sigma'$ gives the
%   bijection required in the original problem.%\qed
% \end{proof}


