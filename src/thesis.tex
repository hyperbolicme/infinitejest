\documentclass[MS]             % MS thesis dissertation.
              {iitmdiss}

\usepackage{times}             % Font?
\usepackage{t1enc}             % T1 encoding??  
%\usepackage{boxedminipage}
\usepackage{../lib/mythesislib}
\usepackage{../lib/mylatexlib}

\def \mythesissubmissiondate {30 December 2011}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title page
\title{\mythesistitle} 
\author{\myname} 
\date{\MakeUppercase
  {\mythesissubmissionmonth}} 
\department{\MakeUppercase{\mydept}}

%\nocite{*}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Certificate
\certificate

\vspace*{0.5in}

\noindent 
This is to certify that the thesis titled {\bf \mythesistitle},
submitted by {\bf \myname}, to the Indian Institute of Technology,
Madras, for the award of the degree of {\bf \mydegree}, is
a bona fide record of the research work done by her under our
supervision.  The contents of this thesis, in full or in parts, have
not been submitted to any other Institute or University for the award
of any degree or diploma.

\vspace*{1.5in}

\begin{singlespacing}
  \hspace*{-0.25in}
%   \begin{tabular}[h]{lr}
%     {\bf Dr.~\myadvisor} & \\
%     {\small Research Guide} & \\
%     {\small Associate Professor} & \\
%     {\small Dept. of \mydept} & \hfill {\small Chennai}\\
%     {\small IIT Madras -- 600 036} & \hfill {\small\mythesissubmissiondate}
%  \end{tabular}
  \parbox{3in}{
    \noindent {\bf Dr.~\myadvisor} \\
    \small
    \noindent Research Guide\\
    \noindent Associate Professor\\
    \noindent Dept. of \mydept\\
    \noindent IIT Madras -- 600 036
  } \hfill
  \parbox{1.25in}{               % {1.75in}
    \small
    \vspace*{0.75in}
    \begin{tabular}[h]{r}
    \noindent {Chennai}\\         
    \noindent {\mythesissubmissiondate} 
    \end{tabular}
  }
\end{singlespacing}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Acknowledgements
\acknowledgements

\tnote{WIP}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract

\begin{abstract}
  \noindent {\bf Keywords}: \hspace*{0.5em} \parbox[t]{4.4in}{consecutive
    ones property, algorithmic graph theory, hypergraph isomorphism,
    interval labeling} \vspace*{24pt}

\def \tem {}
  \noindent 
  \annote{In this paper, we explore a natural generalization of
  results on binary matrices with the |\tem consecutive ones property|. 
  We consider the following constraint satisfaction problem. Given (i)
  a set system $\F \subseteq$ $(2^{U} \setminus \emptyset)$ of a
  finite set $U$ of cardinality $n$, (ii) a tree $T$ of size $n$ and
  (iii) a bijection called |\tem tree path labeling|, $\cl$ mapping the
  sets in $\cF$ to paths in $T$, does there exist at least one
  bijection $\phi:U \rightarrow V(T)$ such that for each $S \in \cF$,
  $\{\phi(x) \mid x \in S\} = \cl(S)$?  A tree path labeling of a set
  system is called |\tem feasible| if there exists such a bijection
  $\phi$.  We present an algorithmic characterization of feasible tree
  path labeling. COP is a special instance of tree path labeling
  problem when $T$ is a path.  We conclude with a polynomial time
  algorithm to find a feasible tree path labeling of a given set
  system when $T$ is a |\tem $k$-subdivided star|, set system has a
  single containment tree of overlap components and set size is
  limited to at most $k+2$. }{this is the abstract of the
  paper. expand to fit thesis.}
\end{abstract}


%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table of contents etc.

\begin{singlespace}
\tableofcontents
\thispagestyle{empty}

\listoftables
\addcontentsline{toc}{chapter}{LIST OF TABLES}
\listoffigures
\addcontentsline{toc}{chapter}{LIST OF FIGURES}
\end{singlespace}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abbreviations
\abbreviations

\noindent 
\begin{tabbing}
xxxxxxxxxxx \= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
\textbf{COP}   \> Consecutive Ones Property \\
\textbf{COT}   \> Consecutive Ones Testing \\
\textbf{ICPIA}   \> Intersection Cardinality Preservation Interval Assignment \\
\textbf{ICPPL}   \> Intersection Cardinality Preserved Path Labeling \\
% ADD MORE HERE
\end{tabbing}

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Notation

\chapter*{\centerline{NOTATION}}
\addcontentsline{toc}{chapter}{NOTATION}

\begin{singlespace}
\begin{tabbing}
xxxxxxxxxxx \= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
\textbf{$2^{U}$}  \> Powerset of set $U$ \\
\end{tabbing}
\end{singlespace}

\pagebreak
\clearpage

% The main text will follow from this point so set the page numbering
% to arabic from here on.
\pagenumbering{arabic}

\chapter{Introduction}
\label{chap:intro}

\section{Introduction}
\label{sec:intro}
\vspace{\secfirstparatrim} 

Consecutive ones property is a non-trivial property of binary matrices
that has been studied widely in the literature for over past 50
years. Detection of COP in a matrix is possible efficiently and there
are several algorithms that achieve the same. This thesis documents
the work done on an extension of COP extended from the equivalent
interval assignment problem in \cite{nsnrs09}. These new results
rigorously prove a natural extension (to trees) of their
characterization as well as makes connections to graph isomorphism,
namely path graph isomorphism.

% \tnote{testing 1 2 3...}
% \tnote[bogus1]{testing 1 2 3...}
% \tnote[bogus2]{testing 1 2 3...}
% \tnote[GTC]{testing 1 2 3...}
% \tnote[bogus4]{testing 1 2 3...}
% \tnote[TH]{testing 1 2 3...}

\subsection{Illustration of the problem}
\label{sec:problem}
\vspace{\secfirstparatrim}

A group of students, \Pa, \Pi, \Sn, \Wo, \Vi, \Li, \Ch, \Sa, \Fr,
  \Sc\ and \Lu\ enroll at the
% {\bf Wo}odstock, {\bf Vi}olet, {\bf Li}nus, {\bf Ch}arlie, {\bf
%   Sa}lly, {\bf Re}run, {\bf Sc}hr{\"o}eder} and {\em {\bf Lu}cy}
% enroll at the
  {\WSI} for a liberal arts programme.  As part of their semester
  thesis, they pick a body of work to study and form the namesake
  study groups, {\LLL}, {\GGG}, {\BBB} and {\TTT}\tnote[TH]{put bib
    entries for these works!}. A student will be in at least one study
  group and may be in more than one. For instance, as will be seen
  later, {\Fr} studies both {\LLL} and {\TTT} while \Wo\ studies only
  \BBB.

Let $U$ and $\cF$ represent the set of students and the set of study
groups respectively and the integers $n$ and $m$ denote the total
number students and study groups respectively. In relation to this
example, these are defined in Table~\ref{tab:wsigroups}. Also given
there is the study group allocation to students.

% \vspace{-3mm}
% \begin{align*}
% U &= \{\xPa,\; \xPi,\; \xSn,\; \xWo,\; \xVi,\; \xLi,\; \xCh,\;
%     \xSa,\; \xFr,\; \xSc,\; \xLu\}\\
% \cF &= \{\xLLL, \xGGG, \xBBB, \xTTT\}\\
% \xLLL &= \{\xCh,\;  \xSa,\;  \xFr,\;  \xSc,\;  \xLu \}\\
% \xGGG &= \{\xPa,\;  \xPi,\;  \xVi,\;  \xCh \}\\
% \xBBB &= \{\xSn,\;  \xPi,\;  \xWo \}\\
% \xTTT &= \{\xVi,\;  \xLi,\;  \xCh,\;  \xFr \}\\
% n &= |U| = 11\\
% m &= |\cF| = 4  
% \end{align*}


\begin{table}[htbp]
  \centering
  { \footnotesize
  \begin{tabular}{rcl}
    $U $&$=$&$ \{\xPa,\; \xPi,\; \xSn,\; \xWo,\; \xVi,\; \xLi,\; \xCh,\;
    \xSa,\; \xFr,\; \xSc,\; \xLu\}$\\
    $\cF $&$=$&$ \{\xLLL, \xGGG, \xBBB, \xTTT\}$\\
    $\xLLL $&$=$&$ \{\xCh,\;  \xSa,\;  \xFr,\;  \xSc,\;  \xLu \}$\\
    $\xGGG $&$=$&$ \{\xPa,\;  \xPi,\;  \xVi,\;  \xCh \}$\\
    $\xBBB $&$=$&$ \{\xSn,\;  \xPi,\;  \xWo \}$\\
    $\xTTT $&$=$&$ \{\xVi,\;  \xLi,\;  \xCh,\;  \xFr \}$\\
    $n $&$=$&$ |U| = 11$\\
    $m $&$=$&$ |\cF| = 4$      
  \end{tabular}
}
  \caption{\figtabsize Students and study groups in \WSI}
  \label{tab:wsigroups}
\end{table}

% The administration faces a small challenge with their
% accommodation. 
The campus has a residential area {\residenceblock} that has $n$
single occupancy apartments reserved for the study groups'
accommodation.  All these apartments are located such that the streets
connecting them do {\em not} form
loops. Fig~\ref{fig:streetmappathpeople} \tnote[TH]{fig:streetmap}
shows the street map for {\residenceblock}. It may be noted that as a
graph, it classifies as a tree.


\begin{table}[htbp]
  \centering
  {\footnotesize    
    \begin{tabular}{l||l}
      \begin{tabular}{rcl}
        $T $&$=$&$ \text{\em Street map tree of \residenceblock}$\\
        $V(T) $&$=$&$ \{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 \}$\\
        % $\phi^{-1}(V(T)) $&$=$&$ \{ \xSa,\; \xPi,\; \xFr,\; \xWo,\;
        % \xCh,\; \xVi,\;
        % \xPa,\; \xSn,\; \xLu,\; \xLi,\; \xSc \}$\\
        $\cP $&$=$&$ \{R\xLLL, R\xGGG, R\xBBB, R\xTTT\}$\\
        $R\xLLL $&$=$&$ \{9, 1, 5, 3, 11\}$\\
        $R\xGGG $&$=$&$ \{7, 2, 6, 5\}$\\
        $R\xBBB $&$=$&$ \{8, 2, 4 \}$\\
        $R\xTTT $&$=$&$ \{10, 6, 5, 3\}$\\
        $n $&$=$&$ |V| = 11$\\
        $m $&$=$&$ |\cP| = 4$\\\\
        $\cl $&$=$& {\em Study group to route mapping}\\        
        $\cl(\mathbb{X}) $&$=$&  $R\mathbb{X}$ for all $\mathbb{X} \in
        \cF$
      \end{tabular} & 
      \begin{tabular}{c}
       {\em Apartment allocation }($\phi$)\\
                    \begin{tabular}{c|c}                      
                      1  & \xSa\\
                      2  & \xPi\\
                      3  & \xFr\\
                      4  & \xWo\\
                      5  & \xCh\\
                      6  & \xVi\\
                      7  & \xPa\\
                      8  & \xSn\\
                      9  & \xLu\\
                      10 & \xLi\\
                      11 & \xSc                     
                    \end{tabular}
      \end{tabular}\\
    \end{tabular}
  }
  \caption{\figtabsize A solution to study group accommodation problem}
  \label{tab:iltree}
\end{table}

A natural question would be to find how the students should be
allocated apartments such that each study group has the {\em least
  distance to travel} for a discussion? More specifically, we are
interested in enforcing additional conditions, namely, that all the
students in a study group must be next to each other; in other words,
for one student to reach another fellow study group member's apartment
(for all study groups the student is part of), she must not have to
pass the apartment of any student who is not in that study group. To
further elucidate, the apartments of students of any study group must
be arranged in an exclusive unfragmented path on the street
map. Exclusivity here means that the path must not have apartments
from other study groups (unless that apartment is also part of {\em
  this} study group).

An intuitive approach to this problem would be to first find the paths
that each study group decides to inhabit and then refine the
allocation to individual students. A feasible allocation of exclusive
routes to study groups is illustrated in
Fig~\ref{fig:streetmappathpeople} \tnote[TH]{fig:streetmappath} and
the students' allocation of apartments that obeys this route
allocation is also shown. Table~\ref{tab:iltree} shows the same
solution set theoretically.  How this is algorithmically computed is
the focus of this thesis.

%%%%%%%%%%%% THESIS UNCOMMENT %%%%%%%%%%%%
% \begin{figure}[t]%[htbp]
%  \centering
%   \includegraphics[scale=0.3]{../img/1_infinite_loop.png}
%   \caption{{\residenceblock} street map}
%   \label{fig:streetmap}
% \end{figure}

% \begin{figure}[t]%[htbp]
%   \centering
%   \includegraphics[scale=0.3]{../img/2_infinite_loop_BTWF.png}
%   \caption{{\residenceblock} street map with study group routes
%     allocated. Routes are color coded as follows: red for
%     \textcolor{red}{$\xLLL$} group, blue for \textcolor{blue}{$\xGGG$}
%     group, orange for \textcolor{YellowOrange}{$\xBBB$} group, green for
%     \textcolor{green}{$\xTTT$} group}
%   \label{fig:streetmappath}
% \end{figure}
% \begin{figure}[t] % [h]
%   \centering
%   \includegraphics[scale=0.5]{../img/3_infinite_loop.png}
%   \caption{Individual allocation of apartments to students in
%     {\residenceblock} that meets the requirements stated before.}
%   \label{fig:streetmappathpeople}
% \end{figure}
%%%%%%%%%%%% END THESIS UNCOMMENT %%%%%%%%%%%%
% \begin{figure}[htbp] %[t]%
%  \centering
%   (a) \includegraphics[scale=0.2]{../img/1_infinite_loop.png}
%   (b) \includegraphics[scale=0.2]{../img/2_infinite_loop_BTWF.png}
%  \label{fig:streetmap}
%   \caption{\figtabsize (a) {\residenceblock} street map (b) {\residenceblock} street map with study group routes
%     allocated. Routes are color coded as follows: red for
%     \textcolor{red}{$\xLLL$} group, blue for \textcolor{blue}{$\xGGG$}
%     group, orange for \textcolor{YellowOrange}{$\xBBB$} group, green for
%     \textcolor{green}{$\xTTT$} group}
% \end{figure}
\begin{figure}[htbp] %[t]%
  \centering
  \includegraphics[scale=0.3]{../img/3_infinite_loop.png}
  \caption{\figtabsize Individual allocation of apartments to students
    in {\residenceblock} that meets the requirements stated before.
    The routes are color coded as follows: red for
    \textcolor{red}{$\xLLL$} group, blue for \textcolor{blue}{$\xGGG$}
    group, orange for \textcolor{yellow}{$\xBBB$} group, green
    for \textcolor{green}{$\xTTT$} group. {\tiny {\em Peanuts images
        {\copyright} Charles Schulz}}}% YellowOrange
  \label{fig:streetmappathpeople}
\end{figure}
\tnote[TH]{make dashed/textured lines for routes. make it color agnostic.}

As a special case, suppose all the apartments are on the same street
or if they are all lined up on a single path, the street map becomes a
tree that is just a path. Then the problem becomes what is called an
{\em interval assignment problem}. The idea of interval assignment may
not be obvious here; hence to see this, consider a different problem
in {\WSI} where the classes for these study groups courses need to be
scheduled during a day (or a week or any time period). Each study
group has a bunch of courses associated with it some of which may be
shared by two or more study groups. It is mandatory that a student who
is a member of a study group takes all the courses associated with
that group. There are slots during the day for classes to be held and
the problem is to allocate class slots to courses such that all the
classes of a study group are consecutive. It is debatable if this will
not hamper the attention span and memory retention rate of the
students but that is, regrettably, out of the scope of this
thesis. The parallels between this class allocation problem and the
accommodation problem can be seen as follows. The set $U$ here, are
the courses offered (say Course 101 {\coneohone}, Course 102
{\coneohtwo} and so on). In this variation of the problem, the
collection $\cF$ is the set of study groups but the study groups are
filled by course IDs (in place of students in the earlier
example). For instance, Course 101 is mandatory for all study groups
$\xLLL$, $\xGGG$, $\xBBB$, $\xTTT$ and Course 102 is mandatory for
only the $\xLLL$ group) and so on. The sequence of class slots for the
day (or week or any time period) is analogous to the street map in the
accommodation problem. It is quite obvious now why this version of the
problem (where the ``target graph'' is a path and not any
tree\tnote[TH]{Allowing any tree in this example could be seen as a
  scenario where there are parallel classes. A node falling in the
  path between two other nodes would mean that the corresponding is
  scheduled between the other two.}) is called an interval assignment
problem.

The interval assignment problem to a set system is equivalent to the
consecutive ones property (COP) problem in binary matrices\cite{wlh02,
  nsnrs09}.  The COP problem is to rearrange rows (columns) of a
binary matrix in such a way that every column (row) has its {\un}s
occur consecutively. If this is possible the matrix is said to have
the COP.  COP is a well researched combinatorial problem and has
several positive results on tests for it and computing the COP
permutation (i.e. the course schedule in the above illustration) which
will be surveyed later in this document. Hence we are interested in
extensions of COP, more specifically, the extension of interval
assignment problem to tree path assignment problem (which is
illustrated by the study group accommodation problem).

Section~\ref{sec:background} gives a brief survey of COP and
optimization problems related to it followed by motivation for the
thesis in Section~\ref{sec:motive}.  Section~\ref{sec:results}
presents a summary of our results on the extension of COP namely, the
tree path labeling problem. \tnote[TH]{update for thesis}


\section{Consecutive Ones Property Testing - a Survey} %{Background}
\label{sec:background}
\vspace{\secfirstparatrim}
In this section, a brief survey of the consecutive ones problem and its
optimization problems is presented.

%%%%%%                              %%%%%%
%THX is the second level of ``tnote''-ing%
%%%%%%                              %%%%%%
\tnote[TH]{ADD: As it will be described in detail later in this
  document, isomorphism of certain % classes of graphs, namely chordal
%   graphs, have a close relationship with consecutive ones property and
%   generalizations of it.  This is perhaps because of how closely COP
%   of a matrix relates to properties of graphs derived from matrices as
%   seen in the following results.
}
\tnote[THX]{ADD: peo exists iff chordal. lexicographic BFS
  [tag:chordalGraph]} %
\tnote[THX]{ADD: A well known result in %perfect graph theory is that
%  the maximal cliques of  an interval graph $G$ can be linearly ordered
%   such that for all $v \in V(G)$, cliques containing $v$ are
%   consecutive in the ordering cite~{gh64}. This clearly means that a
%   graph $G$ is an interval graph if and only if
}% 
\tnote[THX]{verify
  from paper the statement of claim.}% 
\tnote[TH]{maximal clique vertex
  incidence matrix of%  $G$ has COP.  Also, maximal cliques of any
%   chordal graph can be enumerated in polytime $O(m+n)$
}
\tnote[THX]{citation?!!}%  
\tnote[TH]{cite~{fg65} uses these results to
  give the first polynomial time algorithm for COT.}%
\tnote[THX]{check. how do they use it?}%  
\tnote[TH]{ A bipartite graph
  is convex%  (on $R$) if and only if its half adjacency matrix has COP
%   on rows.  The results in cite~{bl76} on COT are based on the result
%   that interval graphs are AT-free chordal graphs.
}%
\tnote[THX]{the latter being Tucker's?}%  
\tnote[THX]{(2) TBD survey
  -- % see blue notes (in notebook) under Graph Isomorphism. namely
%   citations in cite:aas93 (3) a brief on heirarchy of chordal graphs,
%   path graphs, interval graphs, peo, clique tree etc. and results. (4)
%   interval graphs are incomparability graphs. see
%   Golumbic. [tag:classification] (5) finding min length hole in
%   bipartite graph is polynomial time [Sec 3.3.2 in cite:d08phd] (6)
%   theorem 2.2 in cite:d08phd - $G$ is union of v.d. caterpillars iff
%   $M$ has COP in rows. $M$ is edge vertex incidence matrix $(*,2)$ of
%   $G$
}%


\subsection{Matrices with COP}
\label{sec:copmatrices}
\vspace{\secfirstparatrim} 
As seen earlier, the interval assignment problem (illustrated as the
course scheduling problem in Section~\ref{sec:problem}), is a special
case of the problem we address in this thesis, namely the tree path
labeling problem (illustrated as the study group accommodation
problem). The interval assignment problem and COP problem are equivalent
problems. In this section we will see some of the results that
exists in the literature today towards solving the COP problem and
optimization problems surrounding it.

\begin{figure}[t] %[htbp]
  \centering
  % \includegraphics[scale=0.4]{../img/0_cop_nocop.png}
{\figtabsize
 \begin{tabular}[h]{l|lcccl}
    $M_1$: & $M_1'$: &&&& $M_2$:\\
    &&&&&\\
    \begin{tabular}[h]{llll}
      $c_1$ & $c_2$ &$c_3$ &$c_4$\\
      &&&\\
      \un & 0   & \un & 0\\
      0   & \un & 0   & \un \\
      \un & 0   & 0   & \un
    \end{tabular}
    &
    \begin{tabular}[h]{llll}
      $c_3$ &$c_1$ &$c_4$& $c_2$\\
      &&&\\
      \un & \un & 0 & 0\\
      0 & 0 & \un & \un \\
      0 & \un & \un & 0
    \end{tabular}
    &&&&
    \begin{tabular}[h]{llll}
      $d_1$ & $d_2$ &$d_3$ &$d_4$\\
      % &&&\\
      &&&\\
      \un & \un & 0 & 0\\
      0 & \un & \un & 0 \\
      0 & \un & 0 & \un 
    \end{tabular}
  \end{tabular}
}

  \caption{\figtabsize Matrices with and without COP. $M_1$ has COP because by
    permuting its columns, $c_1$-$c_4$, one can obtain $M_1'$ where
    the {\un}s in each row are consecutive. $M_2$, however, does not
    have COP since no permutation of its columns, $d_1$-$d_4$, will
    arrange {\un}s in each row consecutively \cite{d08phd}.}

  \label{fig:cop-matrix}
\end{figure}

Recall that a matrix with COP is one whose rows (columns)
can be rearranged so that the {\un}s in every column (row) are in
consecutive rows (columns). Figure~\ref{fig:cop-matrix} shows examples
of this property.
COP in binary matrices has several practical applications in diverse
fields including scheduling \cite{hl06}, information retrieval
\cite{k77} and computational biology \cite{abh98}.  Further, it is a
tool in graph theory \cite{mcg04} for interval graph recognition,
characterization of Hamiltonian graphs, planarity testing \cite{bl76}
and in integer linear programming \cite{ht02,hl06}.


The obvious first questions after being introduced to the consecutive
ones property of binary matrices are if COP can be detected
efficiently in a binary matrix and if so, can the COP permutation of
the matrix also be computed efficiently?  Recognition of COP in a
binary matrix is polynomial time solvable and the first such algorithm
was given by \cite{fg65}.  A landmark result came a few years later
when \cite{at72} discovered the families of forbidden submatrices that
prevent a matrix from having COP and most, if not all, results that
came later were based on this discovery which connected COP in binary
matrices to convex bipartite graphs. In fact, the forbidden
submatrices came as a corollary to the discovery that convex bipartite
graphs are AT-free in \cite{at72}\tnote[GTC]{check}. The first linear time
algorithm for COP testing (COT) was invented by \cite{bl76} using a
data structure called PQ trees.  Since then several COT algorithms
have been invented -- some of which involved variations of PQ trees
\cite{mm96,wlh01,mcc04}, some involved set theory and ICPIA
\cite{wlh02,nsnrs09}, parallel COT algorithms\cite{as95,bs03,ly91} and
certifying algorithms\cite{mcc04}. % These algorithms
% improve over PQ trees on the time complexity and/or the complexity
% of implementation.

The construction of PQ trees in \cite{bl76} draws on the
close relationship of matrices with COP to interval graphs. A PQ tree of a
matrix is one that stores all row (column) permutations of the matrix
that give the COP orders (there could be multiple orders of rows or columns) of the matrix. This
is constructed using an elaborate linear time procedure and is also
a test for planarity\tnote[GTC]{check check check. both interval
  graph and planarity in this paper?}. % Since this
% result, several improvements have been made to the procedural
% complexity of the algorithm itself and also derivative data structures
% that are easier to construct.
PQR trees is a generalized data structure based on PQ trees
\cite{mm96,mpt98}.  \cite{tm05} describes an improved algorithm to
build PQR trees. \tnote[GTC]{improv in terms of what?}\cite{wlh02}
describes the simpler algorithm for COT. Hsu also invented PC trees
\cite{wlh01}\tnote[TH]{This result first appeared inproc ISAAC92}
which is claimed to be much easier to implement. \cite{nsnrs09}
describes a characterization of consecutive ones property solely based
on the cardinality properties of the set representations of the
columns (rows); every column (row) is equivalent to a set that has the
row (column) indices of the rows (columns) that have one entries in
this column (row). This is interesting and relevant, especially to
this thesis because it simplifies COT to a great
degree. \tnote[GTC]{it reduces the solution search space. fill in the blanks.}

\cite{mcc04} describes a different approach to COT. While all previous
COT algorithms gave the COP order if the matrix has the property but
exited stating negative if otherwise, this algorithm gives an evidence
by way of a certificate of matrix even when it has no COP. This
enables a user to verify the algorithm's result even when the answer
is negative. This is significant from an implementation perspective
because automated program verification is hard and manual verification
is more viable. Hence having a certificate reinforces an
implementation's credibility. Note that when the matrix {\em has} COP,
the COP order is the certificate.  The internal machinery of this
algorithm is related to the weighted betweenness problem
addressed\tnote[GTC]{in what way??} in \cite{co98}.  \tnote[GTC]{expand
  on the COP order graph creation and it having to be bipartite for M
  to have COP. and thus an odd cycle being an evidence of no COP.}
\tnote[TH]{ where should this go?: (1) cite|jlm97 (application of PQ trees
  in graphics). (2) helly's theorem citation
  19XXdgk-Hellystheorem-Danzer-Gruenbaum-Klee}

\subsection{Optimization problems in COP}
\label{sec:optcop}
\vspace{\secfirstparatrim}  
So far we have been concerned about matrices that have the consecutive
ones property. However in real life applications, it is rare that data
sets represented by binary matrices have COP, primarily due to the
noisy nature of data available. At the same time, COP is not arbitrary
and is a desirable property in practical data representation
\cite{co98,jkckv04,k77}. In this context, there are several
interesting problems when a matrix does not have COP but is ``close''
to having COP or is allowed to be altered to have COP. These are the
optimization problems related to a matrix which does not have
COP. Some of the significant problems are surveyed in this section.

\tnote[TH]{ -- sect 4.1 in cite:d08phd has many results
  surveyed. hardness results, approx. results. results are usually for
  a class of matrices $(a,b)$ where number {\un}s in columns and rows
  are restriced to $a$ and $b$ . -- problem of flipping at most $k$
  entries of $M$ to make it attain COP. this is NP complete
  cite:b75-phd}\tnote[TH]{(1) scite:lb62 showed that interval graphs
  are AT-free.  describe AT (2) show the close relationship b/w COP
  and graphs sec 2.2, pg 31} \cite{at72} showed that a matrix that
does not have COP have certain substructures that prevent it from
having COP. Tucker classified these forbidden substructures into five
classes of submatrices. This result is presented in the context of
convex bipartite graphs which \cite{at72} proved to be
AT-free\tnote[TH]{ check this up. give details. - doms'}. By
definition, convex bipartite graph have half adjacency matrices that
have COP on either rows or columns (graph is biconvex if it has COP on
both)\cite{d08phd}. A half adjacency matrix is a binary matrix
representing a bipartite graph as follows. The set of rows and the set
of columns form the two partitions of the graph. Each row node is
adjacent to those nodes that represent the columns that have {\un}s in
the corresponding row. \cite{at72} proves that this bipartite graph
has no asteroidal triple if and only if the matrix has COP and goes on
to identify the forbidden substructures for these bipartite
graphs. The matrices corresponding to these substructures are the
forbidden submatrices.

Once a matrix has been detected to not have COP (using any of the COT
algorithms mentioned earlier), it is naturally of interest to find out
the smallest forbidden substructure (in terms of number of rows and/or
columns and/or number of entries that are {\un}s). \cite{d08phd}
discusses a couple of algorithms which are efficient if the number of
{\un}s in a row is small. This is of significance in the case of sparse
matrices where this number is much lesser than the number of
columns. $(*,\Delta)${\em -matrices} are matrices with no restriction
on number of {\un}s in any column but has at most $\Delta$ {\un}s in
any row. {\sc Min COS-R (Min COS-C), Max COS-R (Max COS-C)} are
similar problems which deals with inducing COP on a matrix. In {\sc
  Min COS-R (Min COS-C)} the question is to find the minimum number of
rows (columns) that must be deleted to result in a matrix with COP.
In the dual problem {\sc Max COS-R (Max COS-C)} the search is for the
maximum number of rows (columns) that induces a submatrix with
COP. Given a matrix $M$ with no COP, \cite{b75-phd} shows that finding
a submatrix $M'$ with all columns\tnote[GTC]{check if b75 deals with
  COP col or COP row. also is it any submatrix with k less than r rows
  or submatrix must have all columns?} but a maximum cardinality
subset of rows such that $M'$ has COP is NP complete. \cite{hg02}
corrects an error of the abridged proof of this reduction as given in
\cite{gj79}.  \cite{d08phd} discusses all these problems in detail
giving an extensive survey of the previously existing results which
are almost exhaustively all approximation results and hardness
results. Taking this further, \cite{d08phd} presents new results in
the area of parameterized algorithms for this
problem\tnote[TH]{elaborate - what are the results?}.

Another problem is to find the minimum number of entries in the matrix
that can be toggled to result in a matrix with COP.  \cite{v85}
discusses approximation of {\sc COP Augmentation} which is the problem
of changing of the minimum number of zero entries to {\un}s so that the
resulting matrix has COP. As mentioned earlier, this problem is
known to be NP complete due to \cite{b75-phd}. \cite{v85} also proves,
using a reduction to the longest path problem, \tnote[GTC]{or is it a
  survey of another result?  check.} that finding a Tucker's forbidden
submatrix of at least $k$ rows is NP complete. \tnote[GTC]{how is this
  different from booth's 75 result??}  \tnote[TH]{where should this
  go? cite|tz04 (approx submatrix with COP sparse matrices)}

\cite{jkckv04} discusses the use of matrices with almost-COP (instead
of one block of consecutive {\un}s, they have $x$ blocks, or {\em
  runs}, of consecutive {\un}s and $x$ is not too large) in the
storage of very large databases.  The problem is that of reordering of
a binary matrix such that the resulting matrix has at most $k$ runs of
{\un}s. This is proved to be NP hard using a reduction from the
Hamiltonian path problem.\tnote[TH]{Theorem 2.1 in jkckv}
\tnote[TH]{(1) A connection of COP problem to the travelling salesman
  problem is also introduced. what does this mean? -- COP can be used
  as a tool to reorder $0.5T \le runs(M) \le T$. (2) The optimization
version of the $k$-run problem, i.e. minimization of number of blocks
of ones is proven to be NP complete by cite:k77}\tnote[GTC]{are these two
  the same?} \tnote[TH]{what is the reduction?} \tnote[TH]{other
  problems similar to COP -- cite:ckl96 (ILP, circ ones, one drop) --
  cite:th98 (generalization of COP - minimax, biotonic column) Tucker}

\section{Generalization of COP - The Motivation}  %{Motivation}
\label{sec:motive}
\vspace{\secfirstparatrim}  
As seen in Section~\ref{sec:copmatrices}, \cite{nsnrs09} describes a
characterization of consecutive ones property based on the cardinality
properties of the set representations of the columns. This result is
very relevant to this thesis because aside from it simplifying COT to
a great degree, our generalization problem is motivated by their
results.

The result in
\cite{nsnrs09} characterizes interval assignments to the sets which
can be obtained from a single permutation of the rows.  They show that
for each set, the cardinality of the interval assigned to it must be
same as the cardinality of the set, and the intersection cardinality
of any two sets must be same as the intersection cardinality of the
corresponding intervals.  While this is obviously a necessary
condition, this result shows this is also sufficient.  \cite{nsnrs09}
calls such an interval assignment an Intersection Cardinality
Preserving Interval Assignment (ICPIA).  This paper generalizes the
idea from \cite{wlh02} of decomposing a given binary matrix into prime
matrices for COT and describes an algorithm to test if an ICPIA exists
for a given set system.


The tree path labeling problem is a natural generalization of the
interval assignment problem or the COP problem. The problem is defined
as follows -- given a set system $\cF$ from a universe $U$ and a tree
$T$, does there exist a bijection from $U$ to the vertices of $T$ such
that each set in the system maps to a path in $T$.  We refer to this
as the {\em tree path labeling problem} for an input set system,
target tree pair -- $(\cF,T)$. As a special case if the tree $T$ is a
path, the problem becomes the interval assignment problem.  We focus
on the question of generalizing the notion of an ICPIA \cite{nsnrs09}
to characterize feasible path assignments.  We show that for a given
set system $\cF$, a tree $T$, and an assignment of paths from $T$ to
the sets, there is a feasible bijection between $U$ and $V(T)$ if and
only if all intersection cardinalities among any three sets (not
necessarily distinct) is same as the intersection cardinality of the
paths assigned to them and the input passes a filtering algorithm
(described in this paper) successfully.  This characterization gives a
natural data structure that stores all the relevant feasible
bijections between $U$ and $V(T)$. This reduces the search space for
the solution considerably from the universe of all possible bijections
between $U$ and $V(T)$ to only those bijections that maintain the
characterization\tnote[TH]{REWORD}.  Further, the filtering algorithm
is also an efficient algorithm to test if a tree path labeling to the
set system is
feasible.  %This generalizes the result in \cite{nsnrs09}.


% How the problem of COT is related to the constraint statisfaction
% problem of interval assignment to sets in a system can be seen as
% follows. Every column of the binary matrix can be converted into a set
% of integers which are the indices of rows with {\un}s in that column. It
% is apparent that if the matrix has COP, then constructing such sets
% after applying the COP permutation to the matrix will result in all
% sets with consecutive integers. In other words, after application of
% COP reordering, the sets are intervals. Indeed the problem now becomes
% finding interval assignments to a given set system such that there
% exists a permutation of the universe (set of row indices) which
% converts each set to its assigned interval. 


\def \probdefwidth {0.85\linewidth}
\def \FTPL {{\sc Feasible Tree Path Labeling}}
\def \CFTPL {\sc Compute Feasible Path Labeling} 
\section{Summary of results}
\label{sec:results}
\vspace{\secfirstparatrim}
% We address the computation of TPL\footnote{Tree Path Labeling} for a
% given hypergraph\footnote{The term {\em hypergraph} is used instead
%   {\em set systems} are used interchangably in this
%   section. Hypergraphs that have TPLs on some target tree are called
%   {\em path hypergraphs}.} and target tree in this research. However
% optimization problems in TPL, akin to problems in
% Section~\ref{sec:optcop} for COP, is outside the scope of this thesis.
As we saw earlier by the result in \cite{nsnrs09}, pairwise
intersection cardinality preservation is necessary and sufficient for
an interval assignment to be feasible for a given
hypergraph\footnote{A {\em hypergraph} is an alternate representation
  of a set system and will be used through out this section.} and thus
is a characterization for COP. In our work we extend this
characterization and find that trio-wise intersection cardinality
preservation makes a tree path labeling \footnote{A {\em tree path
    labeling} $\cl$ is a bijection of paths from the target tree $T$
  to the hyperedges in given hypergraph $\cF$.} (TPL) feasible, which
is a generalization of the COP problem. This problem is defined as
follows.

%\begin{tabular}[t]{c}
{\small
\begin{minipage}[h]{5in}
 % \begin{singlespace}
 \vspace{2mm}
 {\large \FTPL}\\
 \begin{tabular}[t]{l|l}
 \hline\\
    {\tt Input} & 
    \begin{minipage}[t]{\probdefwidth}
      A hypergraph $\cF$ with vertex set $U$, a tree $T$, a set of
      paths $\cP$ from $T$ and a
      bijection $\cl$~$:$~$\cF \rightarrow \cP$.\\
    \end{minipage}\\
    {\tt Question} &
    \begin{minipage}[t]{\probdefwidth}
      Does there exist a bijection $\phi$~$:$~$U \rightarrow V(T)$
      such that $\phi$ when applied on any hyperedge in $\cF$ will
      give
      the path mapped to it by the given tree path labeling $\cl$.\\
      { i.e., $\cl(S) = \{\phi(x) \mid x \in S\}$, for every hyperedge
        $S \in \cF$.}
    \end{minipage}\\
  \end{tabular}
  % \end{singlespace}
\end{minipage}\\
}
%\end{tabular}

We give a necessary and sufficient condition (called ICPPL)\tnote[GTC]{say
  a few words about icppl} for {\FTPL} to output in affirmative. This
characterization can be checked in polynomial time.  The most
interesting consequence is that in our constructive procedure, it is
sufficient to iteratively check if three-way intersection
cardinalities are preserved.  In other words, in each iteration, it is
sufficient to check if the intersection of any three hyperedges is of
the same cardinality as the intersection of the corresponding paths.
Thus this generalizes the well studied question of the feasible
interval assignment problem which is the special case when the target
tree $T$ is simply a path \cite{wlh02,nsnrs09}.

\tnote{A few lines on the algo itself.}

Aside from checking if a given TPL is feasible, we also solve the
problem of computing a feasible TPL for a given hypergraph and target
tree, if one exists. This problem, {\CFTPL}, is defined as follows.

{\small
\begin{minipage}[h]{5in}
 % \begin{singlespace}
 \vspace{2mm}
  {\large \CFTPL}\\
  % 
  \begin{tabular}[t]{l|l}
    \hline\\
    {\tt Input} & 
    \begin{minipage}[t]{\probdefwidth}
      A hypergraph $\cF$ with vertex set $U$ and a tree $T$.\\
    \end{minipage}\\

    {\tt Question} &
    \begin{minipage}[t]{\probdefwidth}
      Does there exist a set of paths $\cP$ from $T$ and a bijection
      $\cl$~$:$~$\cF \rightarrow \cP$, such that {\FTPL} returns {\bf
        true} on $(\cF, T, \cl)$.
    \end{minipage}\\
  \end{tabular}
  % \end{singlespace}
\end{minipage}\\
}

\def \kstar {$k$-subdivided star}
\def \CFTPLKTREE {\sc Compute $k$-subdivided Star Path Labeling}

We present a polynomial time algorithm for {\CFTPL} when the target
tree $T$ belongs to a special class of trees called {\em \kstar s} and
when the hyperedges in the hypergraph $\cF$ have at most $k+2$
vertices. A couple of examples of {\kstar s} are given in
Figure~\ref{fig:ksubstar}.

%This problem, {\CFTPLKTREE}, is defined as follows. \\
\begin{figure}[t]
  \centering
  \begin{tabular}[h]{ccccc}
  \includegraphics[scale=0.3]{../img/star.pdf} &&&&
  \includegraphics[scale=0.3]{../img/kstar.pdf}\\
  (a) &&&& (b)
  \end{tabular}
  \caption{\figtabsize Examples of {\kstar s}. (a) $k = 0$
    (b) $k = 2$ }
  \label{fig:ksubstar}
\end{figure}

%\vspace{3mm}
{\small
\begin{minipage}[h]{5in}
 % \begin{singlespace}
 \vspace{2mm}
  {\large \CFTPLKTREE}\\
  \begin{tabular}[t]{l|l}
    \hline\\
    {\tt Input} & 
    \begin{minipage}[t]{\probdefwidth}
      A hypergraph $\cF$ with vertex set $U$ such that every hyperedge
      $S \in \cF$ is of cardinality at most $k+2$ and a {\kstar} $T$.\\
    \end{minipage}\\
    {\tt Question} &
    \begin{minipage}[t]{\probdefwidth}
      Does there exist a set of paths $\cP$ from $T$ and a bijection
      $\cl$~$:$~$\cF \rightarrow \cP$, such that {\FTPL} returns {\bf
        true} on $(\cF, T, \cl)$.
    \end{minipage}\\
  \end{tabular}
  % \end{singlespace}
\end{minipage}\\
}

In spite of this being a restricted case, we believe that our results
are of significant interest in understanding the nature of {\sc Graph
  Isomorphism} which is polynomial time solvable in interval graphs
while being hard on path graphs\cite{kklv10}. {\kstar s} are a class
of trees which are in many ways very close to intervals or paths. Each
ray\footnote{The path from a leaf to the root, the vertex with highest
degree, is called a {\em ray} of the \kstar.} are independent except
for the root\footnote{The vertex with maximum degree in a {\kstar} is
  called {\em root}} and hence can be considered as an independent interval
till the root. Our algorithm builds on this fact and uses the interval
assignment algorithm\cite{nsnrs09} up until ``reaching'' the root and
then uses the trio-wise intersection cardinality (the extra condition
in ICPPL after ICPIA) check to resolve the
ambiguity about which ray the algorithm should ``grow'' the solution
into in the next iteration.

We also have an algorithm for solving {\CFTPL} with no restrictions
which runs in exponential time. 
% and explores a partial order theory of
% matrices related to {FTPL}.
% gives interesting insight
% into the problem of 
This algorithm finds a path labeling from $T$ by decomposing the
problem into smaller subproblems of finding path labeling of subsets
of $\cF$ from subtrees of $T$. Given the fact that binary matrices
naturally represent a set
system % , we look at the matrix representation of subsets of $\cF$.
and that the overlap relation between the sets involved is an obvious
equivalence relation, $\cF$ naturally partitions into equivalence
classes known as overlap components. In the context of COP, {\em overlap
components} were used in \cite{wlh02} and \cite{kklv10}. Moreover,
\cite{nsnrs09} discovered that these equivalence classes form a total
order. We extend this to TPL and find that when $\cF$ is a path
hypergraph\footnote{If there exists an FTPL for a hypergraph $\cF$, it
  is called a path hypergraph.}, the classes can be partially ordered
as an in-tree in polynomial time. Once $\cF$ is
``broken'' into overlap components, one must identify the subtree of
$T$ that it needs to map to and this is the hard part which is
currently open to be solved in polynomial time.

\tnote[TH]{The connection of TPL to graph
  isomorphism will be made later in the document} 


% In the later part of this paper, we decompose our search for a
% bijection between $U$ and $V(T)$ into subproblems.  Each subproblem
% is on a set subsystem in which for each set, there is another set in
% the set subsystem with which the intersection is {\em strict}, i.e.,
% there is a non-empty intersection, but neither is contained in the
% other.  This is in the spirit of results in \cite{wlh02,nsnrs09}
% where to test for the COP in a given matrix, the COP problem is
% solved on an equivalent set of prime matrices.

%\subsection{RESULTS}
% \section{Preliminaries} 
% \label{sec:prelims} 

% \subsection{Hypergraph} 
% The set $\F \subseteq (2^{U} \setminus \emptyset)$ is a {\em set
%   system} of a universe $U$ with $|U| = n$.  The {\em support} of a
% set system $\F$ denoted by $supp(\cF)$ is the union of all the sets in
% $\F$; $supp(\F) = \bigcup_{S \in \F}S$. For the purposes of this
% paper, a set system is required to ``cover'' the universe; $ supp(\cF)
% = U$.
% % A set system $\cF$ can be alternatively represented by a {\em
% %   hypergraph} $\H_\cF$ whose vertex set is $supp(\cF)$ and
% % hyperedges are the sets in $\cF$. This is a known representation for
% % interval systems in literature \cite{bls99,kklv10}.  We extend this
% % definition here to path systems.
% A set system $\cF$ can also be visualized as a {\em
%   hypergraph}\, vertex set is $supp(\cF)$ and hyperedges are the sets
% in $\cF$.  The {\em intersection graph}\, $\bI(\cF)$ of a hypergraph
% $\cF$ is a graph such that its vertex set has a bijection to $\cF$ and
% there exists an edge between two vertices \iff their corresponding
% hyperedges have a non-empty intersection \cite{mcg04}.  Two
% hypergraphs $\cF'$, $\cF''$ are said to be {\em isomorphic} to each
% other, denoted by $\cF' \cong \cF''$, \iff there exists a bijection
% $\phi: supp(\cF') \rightarrow supp(\cF'')$ such that for all sets $A
% \subseteq supp(\cF')$, $A$ is a hyperedge in $\cF'$ \iff  $B$ is a
% hyperedge in $\cF''$ where $B = \{\phi(x) \mid x \in A\}$
% \cite{kklv10}, written as $B=\phi(A)$.
% % This is called {\em hypergraph isomorphism}.

% %\noindent
% \subsection{Path Hypergraph from a Tree} 
% We consider trees $T$ such that $|V(T)|=|U|=n$.  A {\em path system}\,
% $\cP$ is a set system of paths from $T$; $\cP \subseteq \{P \mid P
% \subseteq V, \text{ } T[P] \text{ is a path} \}$.  This generalizes
% the fact, from the literature \cite{bls99,kklv10}, that intervals can
% be viewed as sub-paths of a path.
% % Due to the equivalence of set system and hypergraph in the scope of
% % this paper, we drop the subscript $_H$ in the notation and refer to
% % both the structures by $\cF$.
% % \vspace{\prelimspace}%\tnote{also extend $\phi$ to hyperedges -- see if
% % required } \vspace{\prelimspace} \vspace{\prelimspace}
% % \noindent
% If the intersection graphs of $\cF$ and $\cP$( a path system) are
% isomorphic, $\bI(\cF) \cong \bI(\cP)$, then the associated bijection
% $\cl: \cF \rightarrow \cP$ due to this isomorphism is called a {\em
%   path labeling} of the hypergraph $\cF$.  Note that there are two
% kinds of isomorphisms here.  We are concerned about the isomrophisms
% intersection graphs on $\cF$ and $\cP$, and also the isomorphism
% between the hypergraph $\cF$ and $\cP$.
% % To illustrate further, let $\cg: V(\cF) \rightarrow V(\cP)$ be the
% % above mentioned isomorphism where $V(\cF)$ and $V(\cP)$ are the
% % vertex sets that represent the hyperedges for each hypergraph
% % respectively, $V(\cF) = \{ v_S \mid S \in \cF\}$ and $V(\cP) = \{
% % v_P \mid P \in \cP\}$. Then the path labeling $\cl$ is defined as
% % follows: $\cl(S_1) = P_1$ \iff $\cg (v_{S_1}) = v_{P_1}$.  Just to
% % emphasize, for a path labeling $\cl$ of $\cF$ with $\cP$ as the path
% % system, $\cF^\cl$ is same as $\cP$.  The path system $\cP$ may be
% % alternatively denoted in terms of $\cF$ and $\cl$ as $\cF^\cl$. In
% % most scenarios in this paper, what is given are the pair $(\cF,
% % \cl)$ and the target tree $T$; hence this notation will be used more
% % often.
% If $\cF \cong \cP$ where $\cP$ is a path system, then $\cF$ is called
% a {\em path hypergraph} and $\cP$ is called {\em path representation}
% of $\cF$. If this isomorphism is $\phi: supp(\cF) \rightarrow V(T)$,
% then it is clear that there is a path labeling $\cl_\phi: \cF
% \rightarrow \cP$ to the set system; $\cl_\phi(S) = \set{y \mid y =
%   \phi(x), x \in S}$ for all $S \in \cF$. In other words, if $\cF
% \cong \cP$, we get a path labeling.  Recall that $supp(\cP) = V(T)$.
% % \vspace{\prelimspace} A graph $G$ is a {\em path graph} if it is
% % isomorphic to the intersection graph $\bI(\cP)$ of a path system
% % $\cP$.  This isomorphism gives a bijection $\cl': V(G) \rightarrow
% % \cP$. Moreover, for the purposes of this paper, we require that in a
% % path labeling, $supp(\cP) = V(T)$.  If graph $G$ is also isomorphic
% % to $\bI(\cF)$ for some hypergraph $\cF$, then clearly there is a
% % bijection $\cl: \cF \rightarrow \cP$ such that $\cl(S) = \cl'(v_S)$
% % where $v_S$ is the vertex corresponding to set $S$ in $\bI(\cF)$ for
% % any $S \in \cF$. This bijection $\cl$ is called the {\em path
% %   labeling} of the hypergraph $\cF$ and the path system $\cP$ may be
% % alternatively denoted as $\cF^\cl$.  \vspace{\prelimspace}
% In this work, we are given as input $\cF$ and a tree $T$, and the
% question is whether there is a path labeling $\cl$ to a set of paths
% in $T$.  We refer to such a solution path system by $\cF^\cl$.  A path
% labeling $(\cF, \cl)$ is defined to be {\em feasible} if
% % $\cF \cong \cF^\cl$ and this
% there is a hypergraph isomorphism $\phi: supp(\cF) \rightarrow
% supp(\cF^\cl)=V(T)$ induces a path labeling $\cl_\phi: \cF \rightarrow
% \cF^\cl$ such that $\cl_\phi = \cl$.
% % \vspace{\prelimspace}

% \subsection{Overlap Graphs and Marginal Hyperedges} 
% An {\em
%   overlap graph}\, $\bO(\cF)$ of a hypergraph $\cF$ is a graph such
% that its vertex set has a bijection to $\cF$ and there exists an edge
% between two of its vertices \iff their corresponding hyperedges
% overlap. Two hyperedges $S$ and $S'$ are said to {\em overlap},
% denoted by $S \overlap S'$, if they have a non-empty intersection and
% neither is contained in the other; $S \overlap S' \text{ iff } S \cap
% S' \ne \emptyset, S \nsubseteq S', S' \nsubseteq S$. Thus $\bO(\cF)$
% is a spanning subgraph of $\bI(\cF)$ and not necessarily
% connected. Each connected component of $\bO(\cF)$ is called an {\em
%   overlap component}.
% % If there are $d$ overlap components in $\bO(\cF)$, the set
% % subsystems are denoted by $\cO_1, \cO_2, \ldots \cO_d$. Clearly
% % $\cO_i \subseteq \F, i \in [d]$. For any $i, j \in [d]$, it can be
% % verified that one of the following is true.
% % \begin{enumerate}[a) ]
% % \item $supp(\cO_i)$ and $supp(\cO_j)$ are disjoint
% % \item $supp(\cO_i)$ is a subset of a set in $\cO_j$
% % \item $supp(\cO_j)$ is a subset of a set in $\cO_i$
% % \end{enumerate}
% % \vspace{\prelimspace} \xnoindent
% A hyperedge $S \in \cF$ is called {\em marginal} if for all $S'
% \overlap S$, the overlaps $S \cap S'$ form a single inclusion chain
% \cite{kklv10}. Additionally, if $S$ is such that it is contained in no
% other marginal hyperedge in $\cF$, then it is called {\em
%   super-marginal}.
% % i.e., it is inclusion maximal then it is called {\em
% %   super-marginal}.

% \subsection{$k$-subdivided Star -- A Special Tree} 
% A {\em star} graph
% is a complete bipartite graph $K_{1,p}$ which is clearly a tree and
% $p$ is the number of leaves. The vertex with maximum degree is called
% the {\em center} of the star and the edges are called {\em rays} of
% the star. A {\em $k$-subdivided star} is a star with all its rays
% subdivided exactly $k$ times. The definition of a {\em ray of a
%   $k$-subdivided star} is extended to the path from the center to a
% leaf. It is clear that all rays are of length $k+2$. See
% fig.~\ref{fig:kstar} for examples.

% \begin{figure}[htbp] 
%   \centering
%   (i) \includegraphics{cop-tree_thesis.1} \ \ \ \ \ \  
%   (ii)  \includegraphics{cop-tree_thesis.2}
%   \caption{(i) $8$-subdivided star with 7 rays, (ii) 3-subdivided
%     star with 3 rays}
%   \label{fig:kstar}
% \end{figure}


% \subsection{Characterization of Feasible Tree Path  Labelings} \tnote[TH]{UNCOMMENT all proofs}
% \label{sec:feasible} 
% \vspace{\secfirstparatrim}  

% In this section we give an algorithmic characterization of a
% feasibility of tree path labeling.
% % Consider a path labeling $\cl: \cF \rightarrow \cP$ for set system $\cF$
% % and path system $\cP$ on the given tree $T$. We
% % call $\cl$ an {\em Intersection Cardinality Preserving Path Labeling
% %   (ICPPL)} if it has the following properties.
% Consider a path labeling $(\cF, \cl)$ on the
% given tree $T$. We call $(\cF, \cl)$ an {\em Intersection Cardinality
%   Preserving Path Labeling (ICPPL)} if it has the following
% properties.

% % \begin{enumerate}[{\icpplpr\ }i. ]
% % \item \label{pr:i} $|S| = |\cl(S)|$, \hfill for all $S \in \cF$
% %   % \vspace{\topshrink}
% % \item \label{pr:ii}$|S_1 \cap S_2| = |\cl(S_1) \cap \cl(S_2)|$, \hfill
% %   for all distinct $S_1, S_2 \in \cF$
% %   % \vspace{\topshrink}
% % \item \label{pr:iii}$|S_1 \cap S_2 \cap S_3| = |\cl(S_1) \cap \cl(S_2)
% %   \cap \cl(S_3)|$, \hfill for all distinct $S_1, S_2, S_3 \in \cF$
% % \end{enumerate}

% \begin{table}[h]
%   \centering
%   \begin{tabular}[l]{rrcll}
%     Pr i. & \label{xpr:i} $|S| $&$=$&$ |\cl(S)|$ & $\forall$ $S \in \cF$\\
%     Pr ii. & \label{xpr:ii}$|S_1 \cap S_2| $&$=$&$ |\cl(S_1) \cap
%     \cl(S_2)|$ &  $\forall$ distinct $S_1, S_2 \in \cF$\\
%     Pr iii. & \label{xpr:iii}$|S_1 \cap S_2 \cap S_3| $&$=$&$
%     |\cl(S_1) \cap \cl(S_2) \cap \cl(S_3)|$ & $\forall$ distinct $S_1,
%     S_2, S_3 \in \cF$ 
%   \end{tabular}
%   \caption{ICPPL properties}
%   \label{tab:icpplpr}
% \end{table}





% \noindent
% The following lemma is useful in subsequent arguments. 
% \begin{lemma}
%   \label{lem:setminuscard}
%   If $\cl$ is an ICPPL, and $S_1, S_2, S_3 \in \cF$, then $|S_1 \cap
%   (S_2 \setminus S_3)| = |\cl(S_1) \cap (\cl(S_2) \setminus
%   \cl(S_3))|$.
% \end{lemma}

% % \begin{proof}%[Proof of Lemma~\ref{lem:setminuscard}]
% %   Let $P_i = \cl(S_i)$, for all $i \in \set{1,2,3}$. We have $|S_1
% %   \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| = |S_1
% %   \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to properties
% %   (\ref{pr:ii}) and (\ref{pr:iii}) of ICPPL, $|S_1 \cap S_2| - |S_1
% %   \cap S_2 \cap S_3| = |P_1 \cap P_2| - |P_1 \cap P_2 \cap P_3| =
% %   |(P_1 \cap P_2) \setminus P_3| = |P_1 \cap (P_2 \setminus
% %   P_3)|$. Thus lemma is proved. \qed
% % \end{proof}


% In the remaining part of this section we show that $(\cF, \cl)$ is
% feasible if and only if it is an ICPPL and
% Algorithm~\ref{al:icppl-find-isomorph} returns a non-empty
% function. Algorithm~\ref{al:icppl-find-isomorph} recursively does two
% levels of filtering of $(\cF, \cl)$ to make it simpler while retaining
% the set of isomorphisms, if any, between $\cF$ and $\cF^\cl$.
% % One direction of this claim isclear: that if a path
% % labeling is feasible, then all intersection cardinalities are
% % preserved, i.e. the path labeling is an ICPPL. Algorithm~\ref{perms}
% % \annote{has no premature exit condition hence any input will go
% %   through it}{Prove that the filtered sets has ICPPL \iff input PL
% %   has ICPPL?}. Algorithm~\ref{leafasgn} has an exit condition at
% % line~\ref{xempty}. It can be easily verified that $X$ cannot be
% % empty if $\cl$ is a feasible path labeling. The reason is that a
% % feasible path labeling has an associated bijection between
% % $supp(\cF)$ and $V(T)$ \remove{i.e. $supp(\cF^{\cl})$} such that
% % the sets map to paths, ``preserving'' the path labeling.  The rest
% % of the section is devoted to constructively proving that it is
% % sufficient for a path labeling to be an ICPPL and pass the two
% % filtering algorithms.  To describe in brief, the constructive
% % approaches refine an ICPPL iteratively, such that at the end of each
% % iteration we have a ``filtered'' path labeling, and finally we have
% % a path labeling that defines a family of bijections from $supp(\cF)$
% % to $V(T)$\remove{ i.e. $supp(\cF^{\cl})$}.

% First, we present Algorithm~\ref{perms} called {\tt filter\_1}
% % , and
% % prove its correctness.  
% This algorithm refines the path labeling by
% processing pairs of paths in $\cF^\cl$ that share a leaf until no two
% paths in the new path labeling share any leaf.
% \tnote{write a note summarizing filter 1}
% % \begin{algorithm}[h]
% %   \caption{Refine ICPPL {\tt filter\_1($\cF, \cl, T$)}}
% %   \label{perms}
% %   \begin{algorithmic}[\lndisplay]
% %     \STATE $\cF_0 \assign \cF$, $\cl_0(S) \assign \cl(S)$ for all $S \in \cF_0$\\
% %     \STATE $j \assign 1$\\
% %     \WHILE {there is $S_1, S_2 \in \cF_{j-1}$ such that
% %       $\cl_{j-1}(S_1)$ and $\cl_{j-1}(S_2)$ have a common leaf in
% %       $T$}\label{shareleaf} \STATE $\cF_j \assign (\cF_{j-1} \setminus
% %     \{S_1, S_2\})
% %     \cup \{S_1 \cap S_2, S_1 \setminus S_2, S_2 \setminus S_1 \}$ \label{setbreak} 
% %     \COMMENT {Remove $S_1$, $S_2$ and add the ``filtered'' sets}
% %     \STATE {\bf for} every $S \in \cF_{j-1}$ s.t. $S \ne S_1$ and $S \ne
% %     S_2$ {\bf do} $\cl_j(S) \assign \cl_{j-1}(S)$ {\bf end for}\\

% %     \STATE $\cl_j(S_1 \cap S_2) \assign \cl_{j-1}(S_1) \cap
% %     \cl_{j-1}(S_2)$
% %     \COMMENT {Carry forward the path labeling for all existing sets other than
% %       $S_1$, $S_2$}
% %     \STATE $\cl_j(S_1 \setminus S_2) \assign \cl_{j-1}(S_1) \setminus
% %     \cl_{j-1}(S_2)$ 
% %     \COMMENT {Define path labeling for new sets}
% %     \STATE $\cl_j(S_2 \setminus S_1) \assign \cl_{j-1}(S_2) \setminus
% %     \cl_{j-1}(S_1)$

% %     \IF{$(\cF_j, \cl_j)$ does not satisfy (\icpplpr~\ref{pr:iii}) of ICPPL}
% %     \label{ln:3waycheck}
% %     \STATE {\bf exit} \label{ln:exit1} \\
% %     \ENDIF

% %     \STATE $j \assign j+1$\\
% %     \ENDWHILE
% %     \STATE $\cF' \assign \cF_j$, $\cl' \assign \cl_j$\\
% %     \RETURN $(\cF', \cl')$
% %   \end{algorithmic}
% % \end{algorithm}

% \begin{lemma} 
%  \label{lem:feasible} 
%  In Algorithm~\ref{perms}, if input $(\cF, \cl)$ is a feasible path
%  assignment then at the end of $j$th iteration of the {\bf while}
%  loop, $j \ge 0$, $(\cF_j, \cl_j)$ is a feasible path assignment.
% \end{lemma}

% % \begin{proof}%[Proof of Lemma~\ref{lem:feasible}]
% %   We will prove this by mathematical induction on the number of
% %   iterations. The base case $(\cF_0, \cl_0)$ is feasible since it is
% %   the input itself which is given to be feasible. Assume the lemma is
% %   true till $j-1$th iteration. i.e. every hypergraph isomorphism
% %   $\phi: supp\left(\cF_{j-1}\right) \rightarrow V\left(T \right)$ that
% %   defines $(\cF, \cl)$'s feasibility, is such that the induced path
% %   labeling on $\cF_{j-1}$, $\cl_{\phi[{\cF_{j-1}}]}$ is equal to
% %   $\cl_{j-1}$. We will prove that $\phi$ is also the bijection that
% %   makes $(\cF_j, \cl_j)$ feasible. Note that $supp(\cF_{j-1}) =
% %   supp(\cF_{j})$ since the new sets in $\cF_j$ are created from basic
% %   set operations to the sets in $\cF_{j-1}$. For the same reason and
% %   $\phi$ being a bijection, it is clear that when applying the $\phi$
% %   induced path labeling on $\cF_j$, $ \cl_{\phi[{\cF_{j}}]}(S_1
% %   \setminus S_2) = \cl_{\phi[{\cF_{j-1}}]}(S_1) \setminus
% %   \cl_{\phi[{\cF_{j-1}}]}(S_2)$. Now observe that $ \cl_j(S_1
% %   \setminus S_2) = \cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2) =
% %   \cl_{\phi[{\cF_{j-1}}]}(S_1) \setminus
% %   \cl_{\phi[{\cF_{j-1}}]}(S_2)$. Thus the induced path labeling
% %   $\cl_{\phi[{\cF_{j}}]} = \cl_{j}$. Therefore lemma is proved.  \qed
% % \end{proof}

% \begin{lemma}
%   \label{lem:invar1} In Algorithm~\ref{perms}, at the end of $j$th
%   iteration, $j \ge 0$, of the {\bf while} loop, the following
%   invariants are maintained.
% %   \begin{enumerate}[I {\ }] %\vspace{\topshrink}
% %   \item $\cl_j(R)$ is a path in $T$, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
% %     \ \ \ \ \ \ \ \ \ \ for all $R \in \cF_j$%\vspace{\topshrink}
% %   \item $|R| = |\cl_j(R)|$, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
% %     \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for all $R \in
% %     \cF_j$%\vspace{\topshrink}
% %   \item $|R \cap R'| = |\cl_j(R) \cap \cl_j(R')|$, \ \ \ \ \ \ \ \ \ \
% %     \ \ \ \ \ \ \ \ \ \ for all $R, R' \in \cF_j$%\vspace{\topshrink}
% %   \item $|R \cap R' \cap R''|=|\cl_j(R) \cap \cl_j(R') \cap
% %     \cl_j(R'')|$, \ \ \ for all $R, R', R'' \in \cF_j$
% %   \end{enumerate}

%   \begin{tabular}[h]{lll}
%     I & $\cl_j(R)$ is a path in $T$, & for all $R \in \cF_j$\\ 
%     II  & $|R| = |\cl_j(R)|$, & for all $R \in \cF_j$ \\ 
%     III  & $|R \cap R'| = |\cl_j(R) \cap \cl_j(R')|$, & for all $R, R'
%     \in \cF_j$\\ 
%     IV  & $|R \cap R' \cap R''|=|\cl_j(R) \cap \cl_j(R') \cap
%     \cl_j(R'')|$, & for all $R, R', R'' \in \cF_j$ 
%   \end{tabular}
% \end{lemma}

% % \begin{proof}
% %  Proof is by induction on the number of iterations, $j$. In this
% %   proof, the term ``new sets'' will refer to the sets added to $\cF_j$
% %   in $j$th iteration in line~\ref{setbreak} of Algorithm~\ref{perms},
% %   $S_1 \cap S_2, S_1 \setminus S_2, S_2 \setminus S_1$ and its
% %   images in $\cl_j$ where $\cl_{j-1}(S_1)$
% %   and $\cl_{j-1}(S_2)$ intersect and share a leaf.\\
% %   The invariants are true in the base case $(\cF_0, \cl_0)$, since it
% %   is the input ICPPL.  Assume the lemma is true till the $j-1$th
% %   iteration. Let us consider the possible cases for each of the above invariants for
% %   the $j$th iteration.

% %   \begin{enumerate}[\textreferencemark]
% %   \item {\em Invariant} I/II
% %     \begin{enumerate}[{I/II}a $|$] % \textbullet 
% %     \item {\em $R$ is not a new set.} It is in $\cF_{j-1}$. Thus
% %       trivially true by induction hypothesis.
% %     \item {\em $R$ is a new set.} If $R$ is in $\cF_{j}$ and not in
% %       $\cF_{j-1}$, then it must be one of the new sets added in
% %       $\cF_j$. In this case, it is clear that for each new set, the
% %       image under $\cl_j$ is a path since by definition the chosen
% %       sets $S_1$, $S_2$ are from $\cF_{j-1}$ and due to the while loop
% %       condition, $\cl_{j-1}(S_1)$, $\cl_{j-1}(S_2)$ have a
% %       common leaf. Thus invariant I is proved.\\
% %       Moreover, due to induction hypothesis of invariant III and the
% %       definition of $l_j$ in terms of $l_{j-1}$, invariant II is
% %       indeed true in the $j$th iteration for any of the new sets.  If
% %       $R = S_1 \cap S_2$, $|R| = |S_1 \cap S_2| = |\cl_{j-1}(S_1) \cap
% %       \cl_{j-1}(S_2)| = |\cl_j(S_1 \cap S_2)| = |\cl_j(R)|$.
% %       If $R = S_1 \setminus S_2$, $|R| = |S_1 \setminus S_2| = |S_1| -
% %       |S_1 \cap S_2| = |\cl_{j-1}(S_1)| - |\cl_{j-1}(S_1) \cap
% %       \cl_{j-1}(S_2)| = |\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)| =
% %       |\cl_j(S_1 \setminus S_2)|
% %       = |\cl_j(R)|$. Similarly if $R = S_2 \setminus S_1$.\\
% %     \end{enumerate}
% %   \item {\em Invariant} III
% %     \begin{enumerate}[{III}a $|$]
% %     \item {\em $R$ and $R'$ are not new sets.} It is in
% %       $\cF_{j-1}$. Thus trivially true by induction hypothesis.
% %     \item {\em Only one, say $R$, is a new set.} Due to invariant IV
% %       induction hypothesis, Lemma~\ref{lem:setminuscard} and
% %       definition of $\cl_j$, it follows that invariant III is true no
% %       matter which of the new sets $R$ is equal to. If $R = S_1 \cap
% %       S_2$, $|R \cap R'| = |S_1 \cap S_2 \cap R'| = |\cl_{j-1}(S_1)
% %       \cap \cl_{j-1}(S_2) \cap \cl_{j-1}(R')| = |\cl_j(S_1 \cap S_2)
% %       \cap \cl_j(R')| = |\cl_j(R) \cap \cl_j(R')|$.  If $R = S_1
% %       \setminus S_2$, $|R \cap R'| = |(S_1 \setminus S_2) \cap R'| =
% %       |(\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)) \cap \cl_{j-1}(R')| =
% %       |\cl_{j}(S_1 \cap S_2) \cap \cl_{j}(R')| = |\cl_{j}(R) \cap
% %       \cl_{j}(R')|$. Similarly, if $R = S_2 \setminus
% %       S_1$. Note $R'$ is not a new set.\\

% %     \item {\em $R$ and $R'$ are new sets.} By definition, the new
% %       sets and their path images in path label $\cl_j$ are disjoint so
% %       $|R \cap R'| = |\cl_j(R) \cap \cl_j(R)| = 0$. Thus case proved.
% %     \end{enumerate}
% %   \item {\em Invariant} IV
    
% %     Due to the condition in line~\ref{ln:3waycheck}, this invariant is
% %     ensured at the end of every iteration.
% % %     \begin{enumerate} [{Case 3.}1:]
% % %     \item {\em $R$, $R'$ and $R''$ are not new sets.} Trivially
% % %       true by induction hypothesis.
% % %     \item {\em Only one, say $R$, is a new set.}
% % %       If $R = S_1 \cap S_2$,  from Lemma~\ref{lem:fourpaths} and
% % %       invariant III hypothesis,  this case is proven. Similarly if $R$
% % %       is any of the other new  sets, the case is proven by also using
% % %       Lemma ~\ref{lem:setminuscard}.
% % %     \item {\em At least two of $R, R', R''$ are new sets.}
% % %       The new sets are disjoint hence this case is vacuously true.
% % %     \end{enumerate}
% %   \end{enumerate} \qed
% % %\vspace{-6mm} 

% % \end{proof}

% \begin{lemma}
%   \label{lem:noexit1}
%   If the input ICPPL $(\cF, \cl)$ to Algorithm~\ref{perms} is
%   feasible, then the set of hypergraph isomorphism functions that
%   defines $(\cF, \cl)$'s feasibility is the same as the set that
%   defines $(\cF_j, \cl_j)$'s feasibility, if any.  Secondly, for any
%   iteration $j > 0$ of the {\em \bf while} loop, the {\em \bf exit}
%   statement in line~\ref{ln:exit1} will not execute.
% \end{lemma}
% \tnote[TH]{UNCOMMENT}
% % \begin{proof}
% %   Since $(\cF,\cl)$ is feasible, by Lemma~\ref{lem:feasible}
% %   $(\cF_j,\cl_j)$ for every iteration $j > 0$ is feasible.  % Therefore,
% % %   every hypergraph isomorphism $\phi: supp(\cF) \rightarrow V(T)$ that
% % %   induces $\cl$ on $\cF$ also induces $\cl_{j-1}$ and $\cl_{j}$ on
% % %   $\cF_{j-1}$ and $\cF_{j}$ respectively, i.e., $\cl_{\phi[\cF_{j-1}]}
% % %   = \cl_{j-1}$ and $\cl_{\phi[\cF_j]} = \cl_j$. Thus it can be seen
% % %   that for all $x \in supp(\cF)$, for all $v \in V(T)$ the following
% % %   hold true.
% %   Also, every hypergraph isomorphism $\phi: supp(\cF) \rightarrow
% %   V(T)$ that induces $\cl$ on $\cF$ also induces $\cl_{j}$ on
% %   $\cF_{j}$, i.e., $\cl_{\phi[\cF_j]} = \cl_j$. Thus it can be seen
% %   that for all $x \in supp(\cF)$, for all $v \in V(T)$, if $(x,v) \in
% %   \phi$ then $v \in \cl_{j}(S)$ for all $S \in \cF_{j}$ such that $x
% %   \in S$.
% % % the following
% % %   hold true.
% % %   \begin{enumerate}[i. ]
% % %   \item If $(x,v) \in \phi$ then $v \in \cl_{j-1}(S)$ for all $S \in
% % %     \cF_{j-1}$ such that $x \in S$.
% % %   \item If $(x,v) \in \phi$ then $v \in \cl_{j}(S)$ for all $S \in
% % %     \cF_{j}$ such that $x \in S$
% % %   \end{enumerate}
% %   In other words, filter 1 outputs a filtered path labeling that
% %   ``preserves''
% %   hypergraph isomorphisms of the original path labeling.\\
% %   Secondly, line~\ref{ln:exit1} will execute \iff the exit condition in
% %   line~\ref{ln:3waycheck}, i.e. failure of three way intersection
% %   preservation, becomes true in any iteration of the {\em \bf while}
% %   loop.  Due to Lemma~\ref{lem:invar1} Invariant IV, the exit
% %   condition does not occur if the input is a feasible ICPPL.\qed

% % %   such that $\phi(x) = v$ where $v$ is the leaf considered in the
% % %   first iterations of while. Clearly, $\phi$ is a renaming of
% % %   vertices in hypergraph $\cF$ to those in hypergraph $\cF^\cl$. Thus
% % %   the following facts can be observed in every iteration of the loop.

% % %   \begin{enumerate}[\hspace{2mm}i. ] \vspace{\topshrink}
% % %   \item all intersection cardinalities are preserved in this path
% % %     labeling \vspace{\topshrink}
% % %   \item element $x$ is exclusive in a hyperedge in $\cF$ since $v$ is
% % %     exclusive in a hyperedge in $\cF^\cl$.
% % %   \end{enumerate}

% % %   Thus the exit condition is never rendered true after $x$ and $v$ are
% % %   removed from their respective hyperedges. \qed

% % % \noindent
% % % This proof uses mathematical induction on the number
% % %   of iterations $j$, $j \ge 0$, of the loop that executed
% % %   without exiting. The base case, $j = 0$ is obviously true since the
% % %   input is an ICPPL and the exit condition cannot hold true due to
% % %   ICPPL property (iii).  Assume the algorithm executes till the end
% % %   of $j-1$th iteration without exiting at line
% % %  ~\ref{ln:3waycheck}. Consider the $j$th iteration. From Lemma
% % %  ~\ref{lem:feasible} we know that $(\cF_j, \cl_j)$ and $(\cF_{j-1},
% % %   \cl_{j-1})$ are feasible\remove[AS]{and from the proof in lemma
% % %     lem:invar1 we know that $(\cF_{j-1}, \cl_{j-1})$ satisfies all the
% % %     invariants defined in the lemma}.  Thus there exists a bijection
% % %   $\phi: supp(\cF) \rightarrow V(T)$ such that the induced path
% % %   % labeling on $\cF_{j-1}$ $\cl_{\phi[\cF_{j-1}]} = \cl_{j-1}$.
% % %   labeling on $\cF_{j}$, $\cl_{\phi[\cF_{j}]}$ and on $\cF_{j-1}$,
% % %   $\cl_{\phi[\cF_{j-1}]}$ are equal to $\cl_{j}$ and $\cl_{j-1}$
% % %   respectively.  We need to prove that for any $R, R', R'' \in
% % %   \cF_{j}$, $|R \cap R' \cap R''| = |\cl_j(R) \cap \cl_j(R') \cap
% % %   \cl_j(R'')|$.
% % %   The following are the possible cases that could arise. From argument
% % %   above, $|\cl_j(R) \cap \cl_j(R') \cap \cl_j(R'')| =
% % %   |\cl_{\phi[\cF_{j}]}(R) \cap \cl_{\phi[\cF_{j}]} (R') \cap
% % %   \cl_{\phi[\cF_{j}]} (R'')|$

% % %   \begin{enumerate}[a $|$]
% % %   \item {\em None of the sets are new. $R, R', R'' \in \cF_{j-1}$.}
% % %     We know $(\cF_{j-1}, \cl_{j-1})$ is feasible. Thus $|R \cap R'
% % %     \cap R''| = |\cl_{j-1}(R) \cap \cl_{j-1}(R') \cap \cl_{j-1}(R'')|
% % %     = |\cl_{j}(R) \cap \cl_{j}(R') \cap \cl_{j}(R'')|$.
% % %   \item {\em Only one, say $R$, is a new set.}  Let $R = S_1 \cap S_2$
% % %     ($S_1, S_2$ are defined in the proof of lemma
% % %    ~\ref{lem:invar1}). Now we have $|R \cap R' \cap R''| = |S_1 \cap
% % %     S_2 \cap R' \cap R''| = |\cl_{j-1}(S_1) \cap \cl_{j-1}(S_2) \cap
% % %     \cl_{j-1}(R') \cap \cl_{j-1}(R'')| = |\cl_{j}(R) \cap \cl_{j}(R')
% % %     \cap \cl_{j}(R'')|$. Thus proven. If $R$ is any of the other new
% % %     sets, the same claim can be verified using lemma
% % %    ~\ref{lem:setminuscard}.
% % %     % \item []{\bf Case 3:}
% % %   \item {\em At least two of $R, R', R''$ are new sets.}  The new sets
% % %     are disjoint hence this case is vacuously true.
% % %   \end{enumerate}
% % %   \qed
% % %   \tnote[E2]{remove the induction proof. just text saying x and v are
% % %     exclusive in these sets therefore the intersection cardinalities
% % %     don't change thus all invariants are still true} 
% % \end{proof}

% As a result of Algorithm~\ref{perms} each leaf $v$ in $T$
% is such that there is exactly one set in $\cF$ with $v$ as a vertex in
% the path assigned to it.  In Algorithm~\ref{leafasgn} we identify
% elements in $supp(\cF)$ whose images are leaves in a hypergraph
% isomorphism if one exists.  Let $S \in \cF$ be such that $\cl(S)$ is a
% path with leaf and $v \in V(T)$ is the unique leaf incident on it.  We
% define a new path labeling $\cl_{new}$ such that $\cl_{new}(\set{x}) =
% \set{v}$ where $x$ an arbitrary element from $S \setminus \bigcup_{\hS
%   \ne S} \hS$. In other words, $x$ is an element present in no other
% set in $\cF$ except $S$. This is intuitive since $v$ is present in no
% other path image under $\cl$ other than $\cl(S)$.  The element $x$ and
% leaf $v$ are then removed from the set $S$ and path $\cl(S)$
% respectively. After doing this for all leaves in $T$, all path images
% in the new path labeling $\cl_{new}$ except leaf labels (a path that
% has only a leaf is called the {\em leaf label} for the corresponding
% single element hyperedge or set) are paths from a new pruned tree $T_0
% = T \setminus \{v \mid v \text{ is a leaf in }
% T\}$. Algorithm~\ref{leafasgn} is now presented with details.

% \tnote{write a note summarizing filter 1}
% % \begin{algorithm}[h]
% %   \caption{Leaf labeling from an ICPPL {\tt filter\_2($\cF, \cl, T$)}}
% %   \label{leafasgn}
% %   \begin{algorithmic}[\lndisplay]
% %     \STATE $\cF_0 \assign \cF$, $\cl_0(S) \assign \cl(S)$ for all $S \in \cF_0$
% %     \COMMENT {Path images are such that no two path images share a
% %       leaf.}
% %     \STATE $j \assign 1$\\
% %     \WHILE {there is a leaf $v$ in $T$ and a unique $S_1 \in
% %       \cF_{j-1}$ such that $v \in \cl_{j-1}(S_1)$ }\label{uniqueleaf}
% %     \STATE $\cF_j \assign \cF_{j-1} \setminus \{S_1\}$\\
% %     \STATE for all $S \in \cF_{j-1}$ such that $S \ne S_1$ set
% %     $\cl_j(S) \assign
% %     \cl_{j-1}(S)$\\
% %     \STATE $X \assign S_1 \setminus \bigcup_{S \in \cF_{j-1}, S \ne S_1}S$\\
% %     \IF{$X$ is empty} \label{xempty} \STATE {\bf exit} \label{ln:exit2} \ENDIF
% %     \STATE $x \assign $ arbitrary element from $X$\\
% %     \STATE $\cF_j \assign \cF_j \cup \{\{x\}, S_1 \setminus \{x\}\} $\\
% %     \STATE $\cl_j(\{x\}) \assign \{v\}$\\
% %     \STATE $\cl_j(S_1 \setminus \{x\}) \assign \cl_{j-1}(S_1) \setminus \{v\}$\\
% %     \STATE $j \assign j+1$\\
% %     \ENDWHILE
% %     \STATE $\cF' \assign \cF_j$, $\cl' \assign \cl_j$\\
% %     \RETURN $(\cF', \cl')$
% %   \end{algorithmic}
% % \end{algorithm}

% Suppose the input ICPPL $(\cF, \cl)$ is feasible, yet set $X$ in
% Algorithm~\ref{leafasgn} is empty in some iteration of the {\bf while}
% loop. This will abort our procedure of finding the hypergraph
% isomorphism. The following lemma shows that this will not happen.

% \begin{lemma}
%   \label{lem:xnotempty}
%   If the input ICPPL $(\cF, \cl)$ to Algorithm~\ref{leafasgn} is
%   feasible, then for all iterations $j > 0$ of the {\em \bf while}
%   loop, the {\em \bf exit} statement in line~\ref{ln:exit2} does not
%   execute.
% \end{lemma}

% % \begin{proof}
% %   Assume $X$ is empty for some iteration $j > 0$. We know that $v$ is
% %   an element of $\cl_{j-1}(S_1)$. Since it is uniquely present in
% %   $\cl_{j-1}(S_1)$, it is clear that $v \in \cl_{j-1}(S_1) \setminus
% %   \bigcup_{(S \in \cF_{j-1}) \wedge (S \ne S_1)}\cl_{j-1}(S)$.  Note
% %   that for any $x \in S_1$ it is contained in at least two sets due to
% %   our assumption about cardinality of $X$. Let $S_2 \in \cF_{j-1}$ be
% %   another set that contains $x$. From the above argument, we know $v
% %   \notin \cl_{j-1}(S_2)$. Therefore there cannot exist a hypergraph
% %   isomorphism bijection that maps elements in $S_2$ to those in
% %   $\cl_{j-1}(S_2)$. This contradicts our assumption that the input is
% %   feasible. Thus $X$ cannot be empty if input is ICPPL and feasible.
% %   \qed
% % \end{proof}

% \begin{lemma}
%   \label{lem:invar3}
%   In Algorithm~\ref{leafasgn}, for all $j > 0$, at the end of the
%   $j$th iteration of the {\bf while} loop the four invariants given in
%   Lemma~\ref{lem:invar1} hold.
% \end{lemma}

% % \begin{proof}
% %   By Lemma~\ref{lem:xnotempty} we know that set $X$ will not be empty
% %   in any iteration of the {\em \bf while} loop if input ICPPL $(\cF,
% %   \cl)$ is feasible and $\cl_j$ is always computed for all $j >
% %   0$. Also note that removing a leaf from any path keeps the new path
% %   connected. Thus invariant I is obviously true. In every iteration $j
% %   > 0$, we remove exactly one element $x$ from one set $S$ in $\cF$
% %   and exactly one vertex $v$ which is a leaf from one path
% %   $\cl_{j-1}(S)$ in $T$. This is because as seen in
% %   Lemma~\ref{lem:xnotempty}, $x$ is exclusive to $S$ and $v$ is
% %   exclusive to $\cl_{j-1}(S)$. Due to this fact, it is clear that the
% %   intersection cardinality equations do not change, i.e., invariants
% %   II, III, IV remain true. On the other hand, if the input ICPPL is
% %   not feasible the invariants are vacuously true. \qed
% % \end{proof}



% %% OLD TEXT TB DELETED?
% % \textcolor{cyan}{
% % \begin{lemma}
% %   \label{lem:notfeasibleexit}
% %   \tnote{IS THIS CORRECT?}  If input ICPPL $(\cF, \cl)$ is not
% %   feasible, then in one of the recursive calls to Algorithm --3--, the
% %   {\em \bf exit} statement in line x in Algorithm --1 or line y in
% %   Algorithm --2 will get executed.
% % \end{lemma}
% % }
% %% END OLD TEXT TB DELETED?


% We have seen two filtering algorithms above, namely,
% Algorithm~\ref{perms} {\tt filter\_1} and Algorithm~\ref{leafasgn}
% {\tt filter\_2} which when executed serially respectively result in a
% new ICPPL on the same universe $U$ and tree $T$. We also proved that
% if the input is indeed feasible, these algorithms do indeed output the
% filtered ICPPL. Now we present the algorithmic characterization of a
% feasible tree path labeling by way of Algorithm~\ref{al:icppl-find-isomorph}.

% Algorithm~\ref{al:icppl-find-isomorph} computes a
% hypergraph isomorphism $\phi$ recursively using Algorithm~\ref{perms}
% and Algorithm~\ref{leafasgn} and pruning the leaves of the input
% tree. In brief, it is done as follows. Algorithm~\ref{leafasgn} gives
% us the leaf labels in $\cF_2$, i.e., the elements in $supp(\cF)$ that
% map to leaves in $T$, where $(\cF_2, \cl_2)$ is the output of
% Algorithm~\ref{leafasgn}. All leaves in $T$ are then pruned away. The
% leaf labels are removed from the path labeling $\cl_2$ and the
% corresponding elements are removed from the corresponding sets in
% $\cF_2$. This tree pruning algorithm is recursively called on the
% altered hypergraph $\cF'$, path label $\cl'$ and tree $T'$. The
% recursive call returns the bijection $\phi''$ for the rest of the
% elements in $supp(\cF)$ which along with the leaf labels $\phi'$ gives
% us the hypergraph isomorphism $\phi$.  The following lemma formalizes
% the characeterization of feasible path labeling.

% \tnote{write a note summarizing filter 1}
% % \begin{algorithm}[h]
% %   \caption{{\tt get-hypergraph-isomorphism($\cF, \cl, T$)}}
% %   \label{al:icppl-find-isomorph}
% %   \begin{algorithmic}[\lndisplay]

% %     \IF{$T$ is empty}
% %     \RETURN $\emptyset$\\
% %     \ENDIF
% %     \STATE $L \assign \{v \mid v \text{ is a leaf in }      T\}$\\
% %     \STATE $(\cF_1, \cl_1) \assign$ {\tt filter\_1($\cF, \cl,
% %       T$)}\\
% %     \STATE $(\cF_2, \cl_2) \assign$ {\tt filter\_2($\cF_1,
% %       \cl_1, T$)}\\

% %     \STATE $(\cF', \cl') \assign (\cF_2, \cl_2)$\\
% %     \STATE $\phi' \leftarrow \emptyset$

% %     \FOR {every $v \in L$}
% %     \STATE $\phi'(x) \assign v$ where $x \in \cl_2^{-1}(\{v\})$
% %     \COMMENT {Copy the leaf labels to a one to one function $\phi':
% %       supp(\cF) \rightarrow L$
% %       }\\
% %     \STATE Remove $\{x\}$ and $\{v\}$ from $\cF'$, $\cl'$  appropriately\\
% %     \ENDFOR

% %     \STATE $T' \assign T \setminus L$

% %     \STATE $\phi'' \assign$ {\tt
% %       get-hypergraph-isomorphism($\cF', \cl', T'$)}
% %     \STATE $\phi \assign \phi'' \cup \phi'$ \\
% %     \RETURN $\phi$
% %   \end{algorithmic}
% % \end{algorithm}

% \begin{lemma}
%   \label{lem:hyperiso}  %{lem:perm}
%   If $(\cF, \cl)$ is an ICPPL from a tree $T$ and
%   Algorithm~\ref{al:icppl-find-isomorph}, {\tt
%     get- hypergraph- isomorphism ($\cF, \cl, T$)} returns a non-empty
%   function, then there exists a hypergraph isomorphism $\phi :
%   supp(\cF) \rightarrow V(T)$ such that the $\phi$-induced tree path
%   labeling is equal to $\cl$ or $\cl_\phi = \cl$.
% \end{lemma}
% % \begin{proof}
% %   It is clear that in the end of every recursive call to
% %   Algorithm~\ref{al:icppl-find-isomorph}, the function $\phi'$ is one
% %   to one involving all the leaves in the tree passed as input to that
% %   recursive call. Moreover, by Lemma~\ref{lem:noexit1} and
% %   Lemma~\ref{lem:xnotempty} it is consistent with the tree path
% %   labeling $\cl$ passed. The tree pruning is done by only removing
% %   leaves in each call to the function and is done till the tree
% %   becomes empty. Thus the returned function $\phi: supp(\cF)
% %   \rightarrow V(T)$ is a union of mutually exclusive one to one
% %   functions exhausting all vertices of the tree. In other words, it is
% %   a bijection from $supp(\cF)$ to $V(T)$ inducing the given path
% %   labeling $\cl$ and thus a hypergraph isomorphism. \qed
% % \end{proof}

% \begin{theorem}
%   \label{th:charac}
%   A path labeling $(\cF, \cl)$ on tree $T$ is feasible \iff it is an
%   ICPPL and Algorithm~\ref{al:icppl-find-isomorph} with $(\cF, \cl,
%   T)$ as input returns a non-empty function.
% \end{theorem}
% % \begin{proof}
% %   From Lemma~\ref{lem:hyperiso}, we know that if $(\cF, \cl)$ is an
% %   ICPPL and Algorithm~\ref{al:icppl-find-isomorph} with $(\cF, \cl,
% %   T)$ as input returns a non-empty function, $(\cF, \cl)$ is feasible.
% %   Now consider the case where $(\cF, \cl)$ is feasible. i.e. there
% %   exists a hypergraph isomorphism $\phi$ such that $\cl_\phi =
% %   \cl$. Lemma~\ref{lem:noexit1} and Lemma~\ref{lem:xnotempty} show us
% %   that filter 1 and filter 2 do not exit if input is feasible. Thus
% %   Algorithm~\ref{al:icppl-find-isomorph} returns a non-empty
% %   function.\qed
% % \end{proof}

% \subsection*{ICPPL when given tree is a path}
% \label{sec:icpplicpia}
% \vspace{\secfirstparatrim}  
% Consider a special case of ICPPL with the following properties when
% the tree $T$ is a path.  Hence, all path labels are can be viewed as
% intervals assigned to the sets in $\cF$.  It is shown, in
% \cite{nsnrs09}, that the filtering algorithms outlined above need only
% preserve pairwise intersection cardinalities, and higher level
% intersection cardinalities are preserved by the Helly Property of
% intervals.  Consequently, the filter algorithms do not need to ever
% evaluate the additional check to {\em \bf exit}.
% %\begin{enumerate}
% %\item Given tree $T$ is a path. Hence, all path labels are interval labels.
% %\item Only pairwise intersection cardinality
% %  preservation is sufficient. i.e. property (iii) in ICPPL is not enforced.
% %\item The filter algorithms do not have {\em \bf exit} statements.
% %\end{enumerate}
% %This is called an Intersection Cardinality Preservation Interval
% %Assignment (ICPIA) \cite{nsnrs09}. 
% This structure and its algorithm is
% used in the next section for finding tree path labeling from a
% $k$-subdivided star due to this graph's close relationship with
% intervals. 

% \subsection{Case of a Special Tree -- The $k$-subdivided star}
% \label{sec:ksubdivstar}
% \vspace{\secfirstparatrim}  
% In this section we consider the problem of assigning paths from a
% $k$-subdivided star $T$ to a given set system $\cF$ such that each set
% $X \in \cF$ is of cardinality at most $k+2$.  Secondly, we present our
% results only for the case when overlap graph $\bO(\cF)$ is connected.
% %The
% %overlap graph is well-known from the work of
% %\cite{kklv10,nsnrs09,wlh02}.  We use the notation in
% %\cite{kklv10}. Recall from Section~\ref{sec:prelims} that hyperedges
% %$S$ and $S'$ are said to overlap, denoted by $S \overlap S'$, if $S$ and $S'$
% %have a non-empty intersection but neither of them is contained in the
% %other. The overlap graph $\bO(\cF)$ is a graph in which the vertices
% %correspond to the sets in $\cF$, and the vertices corresponding to the
% %hyperedges $S$ and $S'$ are adjacent if and only if they overlap.  Note
% %that the intersection graph of $\cF$, $\bI(\cF)$ is different from
% %$\bO(\cF)$ and $\bO(\cF) \subseteq \bI(\cF)$.  
% A connected component of $\bO(\cF)$ is called an overlap component of
% $\cF$.  An interesting property of the overlap components is that any
% two distinct overlap components, say $\cO_1$ and $\cO_2$, are such
% that any two sets $S_1 \in \cO_1$ and $S_2 \in \cO_2$ are disjoint,
% or, w.l.o.g, all the sets in $\cO_1$ are contained within one set in
% $\cO_2$.  This containment relation naturally determines a
% decomposition of the overlap components into rooted containment trees.
% We consider the case when there is only one rooted containment tree,
% and we first present our algorithm when $\bO(\cF)$ is connected.  It
% is easy to see that once the path labeling to the overlap component in
% the root of the containment tree is achieved, the path labeling to the
% other overlap components in the rooted containment tree is essentially
% finding a path labeling when the target tree is a path: each target
% path is a path that is allocated to sets in the root overlap
% component.  Therefore, for the rest of this section, $\bO(\cF)$ is a
% connected graph. Recall that we also consider the special case when
% all hyperedges are of cardinality at most $k+2$.  By definition, a
% $k$-subdivided star has a central vertex which we call the {\em root},
% and each root to leaf path is called a {\em ray}.  First, we observe
% that by removing the root $r$ from $T$, we get a collection of $p$
% vertex disjoint paths of length $k+1$, $p$ being the number of leaves
% in $T$.  We denote the rays by $R_1, \ldots, R_p$, and the number of
% vertices in $R_i$, $i \in [p]$ is $k+2$.  Let
% $\seq{v_{i1},\ldots,v_{i(k+2)}=r}$ denote the sequence of vertices in
% $R_i$, where $v_{i1}$ is the leaf. Note that $r$ is a common vertex to
% all $R_i$.

% \subsubsection{Description of the Algorithm}
% \vspace{\secfirstparatrim}  
% In this section the given hypergraph $\cF$, the $k$-subdivided star
% and the root of the star are denoted by $\cO$, $T$ and vertex $r$,
% respectively.  In particular, note that the vertices of $\cO$
% correspond to the sets in $\cF$, and the edges correspond to the
% overlap relation.

% %\noindent
% For each hyperedge $X \in \cO$, we will maintain a 2-tuple of non-negative
%  numbers $\seq{p_1(X), p_2(X)}$.  The numbers satisfy the property that
%  $p_1(X) + p_2(X) \leq |X|$, and at the end of path labeling, for each
%  $X$, $p_1(X) + p_2(X) = |X|$.  This signifies the algorithm tracking
%  the lengths of subpaths of the path assigned to $X$ from at most two
%  rays. We also maintain another parameter called the {\em residue} of
%  $X$ denoted by $s(X)=|X| - p_1(X)$. This signifies the residue path
%  length that must be assigned to $X$ which must be from another
%  ray. For instance, if $X$ is labeled a path from only one ray, then
%  $p_1(X) = |X|$, $p_2(X) = 0$ and $s(X) = 0$.

%  The algorithm proceeds in iterations, and in the $i$-th
%  iteration, $i > 1$, a single hyperedge $X$ that overlaps with a
%  hyperedge that has been assigned a path is considered.  At the
%  beginning of each iteration hyperedges of $\cO$ are classifed into
%  the following disjoint sets.
%  \begin{enumerate}
%  \item [$\cL_1^i$] {\em Labeled without $r$.} Those that have been
%    labeled with a path which does not contain $r$ in one of the
%    previous iterations.\\  $\cL_1^i = \set{ X \mid p_1(X) = |X| \text{ and
%      } p_2(X) = 0 \text{ and } s(X) = 0, X \in \cO}$
%  \item [$\cL_2^i$] {\em Labeled with $r$.} Those that have been labeled
%    with two subpaths of $\cl(X)$ containing $r$ from two different rays
%    in two previous iterations.\\ $\cL_2^i = \set{X \mid 0 < p_1\left(X\right),
%      p_2\left(X\right) < |X|=p_1(X)+p_2(X) \text{ and } s(X) = 0, X \in \cO}$
%    \item [$\cT_1^i$] {\em Type 1 / partially labeled.} Those that have
%      been labeled with one path containing $r$ from a single ray in one
%      of the previous iterations. Here, $p_1(X)$ denotes the length of
%      the subpath of $\cl(X)$ that $X$ has been so far labeled
%      with. \\
%      $\cT_1^i = \set{ X \mid 0 < p_1(X) < |X| \text{ and } p_2(X) = 0
%        \text{ and } s(X) = |X|-p_1(X), X \in \cO}$
%    \item [$\cT_2^i$] {\em Type 2 / not labeled.} Those that have not been
%      labeled with a path in any previous iteration.\\
%      $\cT_2^i = \set{ X \mid p_1(X) = p_2(X) = 0 \text{ and } s(X) = |X|,
%        X \in \cO}$
%  \end{enumerate}
% % \vspace{-2mm}
% % \begin{align*}
% %   \cO &= \cL_1^i \cup \cL_2^i \cup \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]\\
% %   \cO_i &= \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]
% % \end{align*}

% %\noindent
% The set $\cO_i$ refers to the set of hyperedges $\cT_1^i \cup \cT_2^i$
% in the $i$th iteration.  Note that $\cO_1 = \cO$.  In the $i$th
% iteration, hyperedges from $\cO_i$ are assigned paths from $T$ using
% the following rules. Also the end of the iteration, $\cL_1^{i+1},
% \cL_2^{i+1}, \cT_1^{i+1}, \cT_2^{i+1}$ are set to $\cL_1^{i},
% \cL_2^{i}, \cT_1^{i}, \cT_2^{i}$ respectively, along with some
% case-specific changes mentioned in the rules below.

% %\noindent
% \begin{enumerate}[I.]
% \item {\bf Iteration 1:} Let $S=\{X_1,\ldots,X_s\}$ denote the
%   super-marginal hyperedges from $\cO_1$.  If $|S|=s \neq p$, then
%   exit reporting failure.  Else, assign to each $X_j \in S$, the path
%   from $R_j$ such that the path contains the leaf in $R_j$.  This path
%   is refered to as $\cl(X_j)$.  Set $p_1(X_j)=|X|, p_2(X_j)=s(X_j)=0$.
%   Hyperedges in $S$ are not added to $\cO_2$ but are added to
%   $\cL_1^2$ and all other hyperedges are added to
%   $\cO_2$.
% \item {\bf Iteration $i$:} Let $X$ be a hyperedge from $\cO_i$ such
%   that there exists $Y \in \cL_1^i \cup \cL_2^i$ and $X \overlap
%   Y$. Further let $Z \in \cL_1^i \cup L_2^i$ such that $Z \overlap Y$.
%   If $X \in \cT_2^i$, and if there are multiple $Y$ candidates then
%   any $Y$ is selected.  On the other hand, if $X \in \cT_1^i$, then
%   $X$ has a partial path assignment, $\cl'(X)$ from a previous
%   iteration, say from ray $R_j$. Then, $Y$ is
%   chosen such that $X \cap Y$ has a non-empty intersection with a ray
%   different from $R_j$.  The key things that are done in assigning a
%   path to $X$ are as follows. The {\em end} of path $\cl(Y)$ where
%   $\cl(X)$ would overlap is found, and then based on this the
%   existence of a feasible assignment is decided.  It is important to
%   note that since $X \overlap Y$, $\cl(X) \overlap \cl(Y)$ in any
%   feasible assignment.  Therefore, the notion of the {\em end} at
%   which $\cl(X)$ and $\cl(Y)$ overlap is unambiguous, since for any
%   path, there are two end points.
%   \begin{enumerate}
%   \item \label{iendpoint} {\em End point of $\cl(Y)$ where $\cl(X)$ overlaps
%       depends on $X \cap Z$:} If $X \cap Z
%     \neq \emptyset$, then $\cl(X)$ has an overlap of $|X \cap Y|$ at that
%     end of $\cl(Y)$ at which $\cl(Y)$ and $\cl(Z)$ overlap.  If $X
%     \cap Z = \emptyset$, then $\cl(X)$ has an overlap of $|X \cap Y|$ at
%     that end of $\cl(Y)$ where $\cl(Y)$ and $\cl(Z)$ do not intersect.
%   \item {\em Any path of length $s(X)$ at the appropriate end contains
%       $r$:} If $X \in \cT_1^i$ then after finding the appropriate end
%     as in step~\ref{iendpoint} this the unique path of length $s(X)$
%     should end at $r$.  If not, we exit reporting failure.  Else,
%     $\cl(X)$ is computed as union of $\cl'(X)$ and this path. If any
%     three-way intersection cardinality is violated with this new
%     assignment, then exit, reporting failure.  Otherwise, $X$ is added
%     to $\cL_2^{i+1}$.  On the other hand, if $X \in \cT_2^i$, then
%     after step~\ref{iendpoint}, $\cl(X)$ or $\cl'(X)$ is unique up to
%     the root and including it. Clearly, the vertices $\cl(X)$ or
%     $\cl'(X)$ contains depends on $|X|$ and $|X \cap Y|$.  If any
%     three way intersection cardinality is violated due to this
%     assignment, exit, reporting failure.  Otherwise,
%     $p_1(X)$ is updated as the length of the assigned path, and $s(X)
%     = |X|-p_1(X)$.  If $s(X) > 0$, then $X$ is added to $\cT_1^{i+1}$.
%     If $s(X)=0$, then $X$ is added to $\cL_1^{i+1}$.
%   \item {\em The unique path of length $s(X)$ overlapping at the
%       appropriate end of $Y$ does not contain $r$:} In this case,
%     $\cl(X)$ is updated to include this path.  If any three way
%     intersection cardinality is violated, exit, reporting failure.
%     Otherwise, update $p_1(X)$ and $p_2(X)$ are appropriate, $X$ is
%     added to $\cL_1^{i+1}$ or $\cL_2^{i+1}$, as appropriate.
%   \end{enumerate}
% \end{enumerate}

% %\noindent 
% \tnote[TH]{UNCOMMENT}
% % \subsection*{Proof of Correctness and Analysis of Running Time} 
% % It
% % is clear that the algorithm runs in polynomial time, as at each step,
% % at most three-way intersection cardinalities need to be checked.
% % Further, finding super-marginal hyperedges can also be done in
% % polynomial time, as it involves considering the overlap regions and
% % checking if the inclusion partial order contains a single minimal
% % element.  In particular, once the super-marginal edges are identified,
% % each iteration involes finding the next hyperedge to consider, and
% % testing for a path to that hyperedge.  To identify the next hyperedge
% % to consider, we consider the breadth first layering of the hyperedges
% % with the zeroeth layer consisting of the super-marginal hyperedges.
% % Since $\cO$ is connected, it follows that all hyperedges of $\cO$ will
% % be considered by the algorithm.  Once a hyperedge is considered, the
% % path to be assigned to it can also be computed in constant time.  In
% % particular, in the algorithm the path to be assigned to $X$ depends on
% % $\cl(Y), \cl(Z)$, $s(X)$ and the presence or absence of $r$ in the
% % candidate partial path $\cl'(X)$.  Therefore, once the super-marginal
% % edges are identified, the running time of the algorithm is linear in
% % the size of the input.  By the technique used for constructing prime
% % matrices \cite{wlh02}, the super-marginal edges can be found in linear
% % time in the input size.  Therefore, the algorithm can be implemented
% % to run in linear time in the input size.

% % %\noindent
% % The proof of correctness uses the following main properties:
% % \begin{enumerate}
% % \item The $k$-subdivided star has a very symmetric structure.  This
% %   symmetry is quantified based on the following observation -- either
% %   there are no feasible path labelings of $\cO$ using paths from $T$,
% %   or there are exactly $p!$ feasible path labelings.  In other words,
% %   there is either no feasible assignment, or effectively a unique
% %   assignment modulo symmetry.
% % \item The $p$ super-marginal hyperedges, if they exist, will each be
% %   assigned a path from distinct rays, and each such path contains the
% %   leaf.
% % \item For a candidate hyperedge $X$, the partial path assignment
% %   $\cl'(X)$ is decided by its overlap with $\cl(Y)$ and cardinality of
% %   intersection with $\cl(Z)$.
% % \end{enumerate}
% % These properties are formalized as follows:
% % \begin{lemma}
% %   \label{lem:sup-mar}
% %   If $X \in \cF$ is super-marginal and $\cl$ is a feasible tree path
% %   labeling to tree $T$, then $\cl(X)$ will contain a leaf in $T$.
% % \end{lemma}
% % \begin{proof}
% %   Suppose $X \in \cF$ is super-marginal and $(\cF, \cl)$ is a feasible
% %   path labeling from $T$.  Assume $\cl(X)$ does not have a leaf.  Let
% %   $R_i$ be one of the rays (or the only ray) $\cl(X)$ is part of.
% %   Since $X$ is in a connected overlap component, there exists $Y_1 \in
% %   \cF$ and $X \nsubseteq Y_1$ such that $Y_1 \overlap X$ and $Y_1$ has
% %   at least one vertex closer to the leaf in $R_i$ than any vertex in
% %   $X$. Similarly with the same argument there exists $Y_2 \in \cF$
% %   with same subset and overlap relation with $X$ except it has has at
% %   least one vertex farther away from the leaf in $R_i$ than any vertex
% %   in $X$. Clearly $Y_1 \cap X$ and $Y_2 \cap X$ cannot be part of same
% %   inclusion chain which contradicts that assumption $X$ is
% %   super-marginal. Thus the claim is proved.\qed
% % \end{proof}
% % \begin{lemma}
% %   If $\cO$ does not have any super-marginal edges, then in any
% %   feasible path labeling $\cl$ of $\cO$ with paths from $T$ is such
% %   that, for any hyperedge $X$ for which $\cl(X)$ contains a leaf, $|X|
% %   \geq k+3$.
% % \end{lemma}
% % \begin{proof}
% %   The proof of this lemma is by contradiction.  Let $X$ be a
% %   hyperedges such that $|X| \leq k+2$ and that $\cl(X)$ has a leaf.
% %   This implies that the overlap regions with $X$, which are captured by
% %   the overlap regions with $\cl(X)$, will form a single inclusion
% %   chain. This shows that $X$ is a marginal hyperedge which
% %   contradicts the assumption that $\cO$ does not have super-marginal
% %   hyperedges. \qed
% % \end{proof}
% % This lemma is used to prove the next lemma for the case when for all
% % $X \in \cO$, $|X| \leq k+2$.  The proof is left out as it just uses
% % the previous lemma and the fact that the hyperedges in $X$ have at
% % most $k+2$ elements.
% % \begin{lemma}
% %   If there is a feasible path labeling for $\cO$ in $T$, then there
% %   are exactly $p$ super-marginal hyperedges.
% % \end{lemma}
% % These lemmas now are used to prove the following theorem.
% % \begin{theorem}
% %   Given $\cO$ and a $k$-subdivided star $T$, the above algorithm
% %   decides correctly if there is a feasible path labeling $\cl$.
% % \end{theorem}
% % \begin{proof} {\em Outline.}
% % %   If the algorithm outputs a path labeling $\cl$, then it is clear
% % %   that it is an ICPPL. The reason is that the algorithm checks that
% % %   three-way intersection cardinalities are preserved in each iteration
% % %   which ensures \icpplpr~\ref{pr:iii}. Moreover, it is clear that
% % %   $\cl(X)$ for any $X \in \cO$ is computed by maintaining
% % %   \icpplpr~\ref{pr:i} and \icpplpr~\ref{pr:ii}. For such a labeling
% % %   $\cl$, the proof that it is feasible is by induction on $k$. What
% % %   needs to be shown is that Algorithm~\ref{al:icppl-find-isomorph}
% % %   successfully runs on input $(\cO, \cl)$. In base case $k=0$, $T$ is
% % %   a star. The claim is clear by observing that after Filter 1 and one
% % %   iteration of Filter 2, all the leaves have found their pre-images
% % %   from support $\cO$.  Therefore, in the induction step, it is clear
% % %   that after Filter 1 and one iteration of Filter 2, the leaves are
% % %   assigned pre-images.  Removing the leaves from $T$ and the
% % %   pre-images from support of $\cO$, results in an ICPPL to a
% % %   $(k-1)$-subdivided star.  Now we apply the induction hypothesis, and
% % %   we get a isomorphism between the hypergraph $\cO$ and $\cO^\cl$.
% %   If the algorithm outputs a path labeling $\cl$, then it is clear
% %   that it is an ICPPL. The reason is that the algorithm checks that
% %   three-way intersection cardinalities are preserved in each iteration
% %   which ensures ICPPL \icpplpr~\ref{pr:iii}. Moreover, it is clear that
% %   $\cl(X)$ for any $X \in \cO$ is computed by maintaining
% %   ICPPL \icpplpr~\ref{pr:i} and ICPPL \icpplpr~\ref{pr:ii}. For such a labeling
% %   $\cl$, the proof that it is feasible is by induction on $k$. What
% %   needs to be shown is that Algorithm~\ref{al:icppl-find-isomorph}
% %   successfully runs on input $(\cO, \cl)$. In base case $k=0$, $T$ is
% %   a star. Also every set is at most size 2 ($k+2$) size and thus
% %   overlaps are at most 1. If two paths share a leaf in {\tt filter\_1}
% %   one must be of length 2 and the other of length 1. Thus the exit
% %   condition is not met. Now it is trivial that the exit condition in
% %   {\tt filter\_2} is also not met. Thus claim proven for base case.
% %   Now assume the claim to be true when target tree is a
% %   $(k-1)$-subdivided star. Consider the case of a $k$-subdivided
% %   star. It is clear that after {\tt filter\_1} and one iteration of
% %   {\tt filter\_2}, the leaves are assigned pre-images.  Removing the
% %   leaves from $T$ and the pre-images from support of $\cO$, results in
% %   an ICPPL to a $(k-1)$-subdivided star.  Now we apply the induction
% %   hypothesis, and we get a isomorphism between the hypergraph $\cO$
% %   and $\cO^\cl$.

% %  \noindent
%   In the reverse direction if there is a feasible path labeling $\cl$,
%   then we know that $\cl$ is unique up to isomorphism.  Therefore,
%   again by induction on $k$ it follows that the algorithm finds $\cl$.
%   \qed
% \end{proof}

\section{Conclusion}
\label{sec:conclusion}
\vspace{\secfirstparatrim} 

We give a characterization for feasible tree path labeling of path
hypergraphs. The proof for this is constructive and computes a
feasibility bijection mapping vertices of the hypergraph to vertices
of the given target tree. This thesis also discovered an exponential algorithm
that computes a feasible TPL to a given hypergraph if it is a path hypergraph.

Our results have close connections to recognition of path graphs and
to path graph isomorphism.  Graphs which can be represented as the
intersection graph of paths in a tree are called {\em path
  graphs}\cite{mcg04}. Thus, a hypergraph $\cF$ can be interpreted as
paths in a tree, if and only if the intersection graph of $\cF$ is a
{\em path graph}. Path graphs are a subclass of chordal graphs since
chordal graphs are characterized as the intersection graphs of
subtrees of a tree\cite{mcg04}.  Path graphs are well studied in the
literature \cite{plr70}--\cite{mcg04}\tnote[TH]{Check if cite:bp93 is
  indeed for path graphs}.  Path graph recognition can be done in
polynomial time\cite{gav78,aas93}.  Clearly, this is a necessary
condition in terms of the intersection graph of the input hypergraph
$\cF$ in \FTPL. However, one can easily obtain a counterexample to
show the insufficiency of this condition\tnote[GTC]{Give a figure
  showing insuff.}.  Path graph isomorphism is known be
isomorphism-complete\cite{kklv10}. Therefore, \annote[GTC]{it is unlikely
  that we can solve the problem of finding feasible path labeling
  $\cl$ for a given $\cF$ and }{WHY?} tree $T$.  It is
  definitely interesting to classify the kinds of trees and
  hypergraphs for which feasible path labelings can be\tnote[TH]{ELABORATE.}
found efficiently.  \annote[TH]{These results would form a natural
  generalization of COP testing and interval graph isomorphism,
  culminating in Graph Isomorphism }{REWORD} itself.
 To this effect we consider TPL on {\kstar} and give a polynomial time
 solution for the same. 

Whether TPL on general trees is solvable in $P$ remains open. So do
optimization opportunities in TPL (possible extensions to optimization for COP in the
Section~\ref{sec:optcop}.\tnote[TH]{link to section}).



\tnote[TH]{ ||Complexity challenges:|| Canonization is an important tool in graph isomorphism. Invention of a
% deterministic method of canonization for any class of graphs naturally
% results in an algorithm for isomorphism. All that is required is to
% check if the canons of two graphs are the same. Thus complexity of
% graph isomorphism can be studied by studying canonization
% methods. While general graph ismorphism remains elusive in terms of
% hardness, canonization has been studied for smaller classes of graphs
% thus giving complexity/hardness results for them.

% In 1992, \cite{sl92} made an important discovery that tree isomorphism
% is in logspace. It was done by inventing a method of canonization of
% trees using a logspace depth first traversal
% algorithm. \tnote{confirm the statement of claim}.

% \cite{kklv10} proved that interval graph canonization is also in
% logspace thus drawing logspace conslusions about COT. 
% % This result is
% % built on the fact that 
% Interval graphs are FP+C (fixed point with
% counting) definable \tnote{elucidate} and \cite{l10} showed that
% this implies that it captures PTIME. \tnote{elucidate} This result
% along with that of undirected graph reachability being in logspace
% \cite{rei08}, \cite{kklv10} proved their logspace result.
}%
\tnote[TH]{ (1) the interesting survey in conclusion section of kklv10
  (2) [[[COP helping some problems with hardness]]] having COP in the
  input structure makes some problems less hard than in a general
  input. -- min set cover problem is known to be NP hard. so is min
  hitting
  set. these two problems are equivalent cite-adp80\\
  -- -- complexity results: log factor polynomial time approximable cite-f98, W[2]-complete with solution size as parameter cite-df99\\
  -- a couple of generalizations:\\
  -- -- min degree hypergraph (MDH) problem\\
  -- -- red blue covering (RBSC) problem\\
  ----- cite-d08phd Chapter 5.\\
  ----- what are cite-d08phd results\\
  ----- Rectangle stabbing \\
  ----- see cite-d08phd Chapter 6?  }



\tnote{ Some things to remember - have this somewhere.

  \begin{itemize}
  \item Examples: Illustration of the problem examples. both COP and
    extension
  \item Basic preliminaries: (definitions theorems etc) needed if any
    - graph theory
  \item Organization: Outline of document
  \end{itemize}
  
  Abstract must be a brief about what results we have and how it fits
  in the body of research.

  \begin{enumerate}
  \item \emph{Area:} - Broad to Specialized. i.e. Combinatorial
    algorithms -> Matrix reorganization -> general data reorganization
    (interval assignment) -> path assignment
  \item \emph{Class of problems:} say, data reorganization.
  \item \emph{Nature of results:} Is a generalization. We have a
    Polynomial algorithm for a subset of the generalization.
  \end{enumerate}

Introduction is a magnified version of Abstract with some brief
citations etc. mini survey. Here talk about canonization how it
connects these problems to graph isomorphism. Introduce our problem,
explain why it is important etc. How canonization is a
posisbility. Brief about results obtained.

Someone who doesn't want to go through the whole thesis must get the
gist of the whole document from the introduction chapter. that should
be the outlook. 


once this is done, the rest of the chapters will fall into place.

{\em Survey chapter} is the full fledged expansion of the survey in
introduction with details, observations, theorems etc.

  {\em The main themes} of the thesis that must not be left out:
  \begin{enumerate}
  \item connection of COP to {\bf set systems} and thus to general
    data bases. \cite{nsnrs09}
  \item {\bf graph isomorphism} by canonization \cite{kklv10}
  \item {\bf certificate for a problem} \cite{mcc04}
  \end{enumerate}

Also see purple book notes.
}

\section{to area}
\section{to problem}
\section{to your thesis}
\section{Organization of document}


   
\chapter{Consecutive Ones property}
\tnote{survey of cop includes mainly 
\begin{enumerate}
\item \cite{d08phd} (perhaps minus chap 4?)
\item \cite{nsnrs09}
\item \cite{mcc04}
\item \cite{kklv10}
\end{enumerate}
.. to name a few. 

sections will be as follows:}
\section{Characterization of COP}

\tnote{\cite{at72}, \cite{mcc04}, prime submatrix \cite{wlh02}?}
\section{Recognition of COP}
\subsection{\tnote{Polynomial time algorithms}}
\tnote{ (pq tree, pqr, icpia)}
\subsection{\tnote{Tucker's submatrices, Dom's algo to find them}}
\subsection{\tnote{McConnell's certificate}}


\section{Alteration to matrices to get COP}
\tnote{algorithms to make a matrix into one with COP
  (min/max-cos-r/c) \cite{d08phd} }
\section{brief analysis of hard problems with input having COP (chap
  5, 6 in dom)}
\label{sec:briefanal}
\tnote{Do I need this?}
\section{Complexity of certain COP variations}
\tnote{maybe combine with Section~\ref{sec:briefanal}\\
complexity - poly, logspace}


\chapter{Other problems related to COP }
\tnote{(see literature)}





\chapter{Research - Tree path labeling of path hypergraphs}
\tnote{Extension to trees. ( stuff in latin paper,)}

\tnote{UPDATE TO FINAL VERSION. BELOW IS OLDER VERSION WITH
  INCOMPLETE SEC 4.}
\section{Introduction}
Consecutive ones property (COP) of binary matrices is a widely studied
combinatorial problem. The problem is to rearrange rows (columns) of a
binary matrix in such a way that every column (row) has its $1$s occur
consecutively. If this is possible the matrix is said to have the COP.
This problem has several practical applications in diverse fields
including scheduling \cite{hl06}, information retrieval \cite{k77} and
computational biology \cite{abh98}.  Further, it is a tool in graph
theory \cite{mcg04} for interval graph recognition, characterization
of hamiltonian graphs, and in integer linear programming
\cite{ht02,hl06}.  Recognition of COP is polynomial time solvable by
several algorithms. PQ trees \cite{bl76}, variations of PQ trees
\cite{mm96,wlh01,wlh02,mcc04}, ICPIA \cite{nsnrs09} are the main ones.

%\noindent
The problem of COP testing can be easily seen as a simple constraint
satisfaction problem involving a system of sets from a universe. Every
column of the binary matrix can be converted into a set of integers
which are the indices of the rows with $1$s in that column. When
observed in this context, if the matrix has the COP, a reordering of
its rows will result in sets that have only consecutive integers. In
other words, the sets after reordering are intervals. Indeed the
problem now becomes finding interval assignments to the given set
system \cite{nsnrs09} with a single permutation of the universe (set
of row indices) which permutes each set to its interval. The result in
\cite{nsnrs09} characterizes interval assignments to the sets which
can be obtained from a single permutation of the rows.  They show that
for each set, the cardinality of the interval assigned to it must be
same as the cardinality of the set, and the intersection cardinality
of any two sets must be same as the interesction cardinality of the
corresponding intervals.  While this is naturally a necessary
condition, \cite{nsnrs09} shows this is indeed sufficient.  Such an
interval assignment is called an Intersection Cardinality Preserving
Interval Assignment (ICPIA).  Finally, the idea of decomposing a given
0-1 matrix into prime matrices to check for COP is adopted from
\cite{wlh02} to test if an ICPIA exists for a given set system.

\noindent 
{\bf Our Work.}  A natural generalization of the interval
assignment problem is feasible tree path labeling problem of a set
system. The problem is defined as follows -- given a set system $\cF$
from a universe $U$ and a tree $T$, does there exist a bijection from
$U$ to the vertices of $T$ such that each set in the system maps to a
path in $T$.  We refer to this as the {\em tree path labeling problem}
for an input set system, target tree pair -- $(\cF,T)$. As a special
case if the tree $T$ is a path, the problem becomes the interval
assignment problem.  We focus on the question of generalizing the
notion of an ICPIA \cite{nsnrs09} to characterize feasible path
assignments.  We show that for a given set system $\cF$, a tree $T$,
and an assignment of paths from $T$ to the sets, there is a feasible
bijection between $U$ and $V(T)$ if and only if all intersection
cardinalities among any three sets (not necessarily distinct) is same
as the intersection cardinality of the paths assigned to them and the
input runs a filtering algorithm (described in this paper)
successfully.  This characterization is proved constructively and it
gives a natural data structure that stores all the relevant feasible
bijections between $U$ and $V(T)$.  Further, the filtering algorithm
is also an efficient algorithm to test if a tree path labeling to the
set system is feasible.  This generalizes the result in
\cite{nsnrs09}.

%\noindent 
\tnote{the following text could be in Further Study/Conclusion}It
is an interesting fact that for a matrix with the COP, the
intersection graph of the corresponding set system is an interval
graph.  A similar connection to a subclass of chordal graphs and a
superclass of interval graphs exists for the generalization of COP.
In this case, the intersection graph of the corresponding set system
must be a {\em path graph}. Chordal graphs are of great significance,
extensively studied, and have several applications.  One of the well
known and interesting properties of a chordal graphs is its connection
with intersection graphs \cite{mcg04}. For every chordal graph, there
exists a tree and a family of subtrees of this tree such that the
intersection graph of this family is isomorphic to the chordal graph
\cite{plr70,gav78,bp93}.  These trees when in a certain format, are
called {\em clique trees} \cite{apy92} of the chordal graph. This is a
compact representation of the chordal graph. There has also been work
done on the generalization of clique trees to clique hypergraphs
\cite{km02}.  If the chordal graph can be represented as the
intersection graph of paths in a tree, then the graph is called path
graph \cite{mcg04}.  Therefore, it is clear that if there is a
bijection from $U$ to $V(T)$ such that for every set, the elements in
it map to vertices of a unique path in $T$, then the intersection
graph of the set system is indeed a path graph.  However, this is only
a necessary condition and can be checked efficiently because path
graph recognition is polynomial time
solvable\cite{gav78,aas93}. Indeed, it is possible to construct a set
system and tree, such that the intersection graph is a path graph, but
there is no bijection between $U$ and $V(T)$ such that the sets map to
paths. Path graph isomorphism is known be isomorphism-complete, see
for example \cite{kklv10}. An interesting area of research would be to
see what this result tells us about the complexity of the tree path
labeling problem (not covered in this paper).

%\noindent
In the later part of this paper, we focus on a new special case of the
tree path labeling problem. Here the set system is such that every set
is at most $k+2$ in size and for every pair of sets in it there exists
a sequence of sets between them with consecutive sets in this sequence
having a strict intersection -- i.e., non-empty intersection with
neither being contained in the other. Moreover, the given tree is a
{\em $k$-subdivided star}. We demonstrate a polynomial time algorithm
to find a feasible path labeling in this case.


% In the later part of this paper, we decompose our search for a
% bijection between $U$ and $V(T)$ into subproblems.  Each subproblem is
% on a set subsystem in which for each set, there is another set in the
% set subsystem with which the intersection is {\em strict}, i.e., there
% is a non-empty intersection, but neither is contained in the other.
% This is in the spirit of results in \cite{wlh02,nsnrs09} where to test
% for the COP in a given matrix, the COP problem is solved on an
% equivalent set of prime matrices.

\noindent {\bf Roadmap.} The necessary preliminaries with definitions
etc. are presented in
Section~\ref{sec:prelims}. Section~\ref{sec:feasible} documents the
characterization of a feasible path labeling and finally,
Section~\ref{sec:ksubdivstar} describes a polynomial time algorithm to
find the tree path labeling of a given set system from a given
$k$-subdivided tree.

\section{Preliminaries} 
\label{sec:prelims} 

This section states definitions and basic facts necessary in the scope
of this document.

\def\xnoindent {}

The set $\F \subseteq (2^{U} \setminus \emptyset)$ is a {\em set
  system} of a universe $U$ with $|U| = n$.  The {\em support} of a
set system $\F$ denoted by $supp(\cF)$ is the union of all the sets in
$\F$; $supp(\F) = \bigcup_{S \in \F}S$. For the purposes of this
paper, a set system is required to ``cover'' the universe; $
supp(\cF) = U$.
%\vspace{\prelimspace}

\xnoindent The graph $T$ represents a {\em target tree} with same
number of vertices as elements in $U$; $|V(T)| = n$.  A {\em path
  system}\, $\cP$ is a set system of paths from $T$; $\cP \subseteq \{P
\mid P \subseteq V, \text{ } T[P] \text{ is a path} \}$.
%\vspace{\prelimspace}

% \xnoindent
% A set system $\cF$ can be alternatively represented by a {\em
%   hypergraph} $\H_\cF$ whose vertex set is $supp(\cF)$ and hyperedges
% are the sets in $\cF$. This is a known representation for interval
% systems in literature \cite{bls99,kklv10}.  We extend this definition here to
% path systems.  
\xnoindent
A set system $\cF$ can be alternatively represented by a {\em
  hypergraph}\, $\cF_H$ whose vertex set is $supp(\cF)$ and hyperedges
are the sets in $\cF$. This is a known representation for interval
systems in literature \cite{bls99,kklv10}.  We extend this definition here to
path systems. Due to the equivalence of set system and hypergraph in
the scope of this paper, we drop the
subscript $_H$ in the notation and refer to both the structures by $\cF$.
%\vspace{\prelimspace}


\xnoindent Two hypergraphs $\cF'$, $\cF''$ are said to be {\em
  isomorphic} to each other, denoted by $\cF' \cong \cF''$, iff there
exists a bijection $\phi: supp(\cF') \rightarrow supp(\cF'')$ such
that for all sets $A \subseteq supp(\cF')$, $A$ is a hyperedge in
$\cF'$ iff $B$ is a hyperedge in $\cF''$ where $B = \{\phi(x) \mid x
\in A\}$ \cite{kklv10}. This is called {\em hypergraph
  isomorphism}. \tnote{also extend $\phi$ to hyperedges -- see if
  required }
%\vspace{\prelimspace}


\xnoindent The {\em intersection graph}\, $\bI(\cF)$ of a hypergraph
$\cF$ is a graph such that its vertex set has a bijection to $\cF$ and
there exists an edge between two vertices iff their corresponding
hyperedges have a non-empty intersection \cite{mcg04}.
%\vspace{\prelimspace}


%\noindent 
If the intersection graphs of two hypergraphs are isomorphic, $\bI(\cF)
\cong \bI(\cP)$ where $\cP$ is also a path system, then the bijection
$\cl: \cF \rightarrow \cP$ due to this isomorphism is called a {\em
  path labeling} of the hypergraph $\cF$. To illustrate further, let
$\cg: V(\cF) \rightarrow V(\cP)$ be the above mentioned isomorphism
where $V(\cF)$ and $V(\cP)$ are the vertex sets that represent the
hyperedges for each hypergraph respectively, $V(\cF) = \{ v_S \mid S
\in \cF\}$ and $V(\cP) = \{ v_P \mid P \in \cP\}$. Then the path
labeling $\cl$ is defined as follows: $\cl(S_1) = P_1$ iff $\cg
(v_{S_1}) = v_{P_1}$. The path system $\cP$ may be alternatively
denoted in terms of $\cF$ and $\cl$ as $\cF^\cl$. In most scenarios in
this paper, what is given are the pair $(\cF, \cl)$ and the target
tree $T$; hence this notation will be used more often.

\xnoindent If $\cF \cong \cP$ where $\cP$ is a path system, then $\cF$
is called a {\em path hypergraph} and $\cP$ is called {\em path
  representation} of $\cF$. If this isomorphism is $\phi: supp(\cF)
\rightarrow V(T)$, then it is clear that there is an {\em induced path
labeling} $\cl_\phi: \cF \rightarrow \cP$ to the set system;
$\cl_\phi(S) = \set{y \mid y = \phi(x), x \in S}$ for all $S \in \cF$. Recall that
$supp(\cP) = V(T)$.
%\vspace{\prelimspace}


% A graph $G$ is a {\em path graph} if it is isomorphic to the intersection graph
% $\bI(\cP)$ of a path system $\cP$. 
% This
% isomorphism gives a bijection $\cl': V(G) \rightarrow \cP$. Moreover,
% for the purposes of this paper, we require that in a path labeling,
% $supp(\cP) = V(T)$.  If graph $G$ is also isomorphic to $\bI(\cF)$ for some hypergraph
% $\cF$, then clearly there is a bijection $\cl: \cF \rightarrow \cP$
% such that $\cl(S) = \cl'(v_S)$ where $v_S$ is the vertex corresponding
% to set $S$ in $\bI(\cF)$ for any $S \in \cF$. This bijection $\cl$ is
% called the {\em path labeling} of the hypergraph $\cF$ and the path
% system $\cP$ may be alternatively denoted as $\cF^\cl$.
%\vspace{\prelimspace}

\xnoindent
A path labeling $(\cF, \cl)$ is defined to be {\em
  feasible} if
$\cF \cong \cF^\cl$ and this hypergraph isomorphism $\phi: supp(\cF)
\rightarrow supp(\cF^\cl)$ induces a path labeling $\cl_\phi: \cF
\rightarrow \cF^\cl$ such that $\cl_\phi = \cl$. 
%\vspace{\prelimspace}

\xnoindent An {\em overlap graph}\, $\bO(\cF)$ of a hypergraph $\cF$ is
a graph such that its vertex set has a bijection to $\cF$ and there
exists an edge between two of its vertices iff their corresponding
hyperedges overlap. Two hyperedges $S$ and $S'$ are said to {\em
  overlap}, denoted by $S \overlap S'$, if they have a non-empty
intersection and neither is contained in the other; $S \overlap S'
\text{ iff } S \cap S' \ne \emptyset, S \nsubseteq S', S' \nsubseteq
S$. Thus $\bO(\cF)$ is a spanning subgraph of $\bI(\cF)$ and not
necessarily connected. Each connected component of $\bO(\cF)$ is
called an {\em overlap component}.
% If there are $d$ overlap components
% in $\bO(\cF)$, the set subsystems are denoted by $\cO_1, \cO_2, \ldots
% \cO_d$. Clearly $\cO_i \subseteq \F, i \in [d]$. For any $i, j \in [d]$,
% it can be verified that one of the following is true.
% \begin{enumerate}[a) ]
% \item $supp(\cO_i)$ and $supp(\cO_j)$ are disjoint
% \item $supp(\cO_i)$ is a subset of a set in $\cO_j$
% \item $supp(\cO_j)$ is a subset of a set in $\cO_i$
% \end{enumerate}
%\vspace{\prelimspace}

\xnoindent
A hyperedge $S \in \cF$ is called {\em marginal} if for all $S'
\overlap S$, the overlaps $S \cap S'$ form a single inclusion chain
\cite{kklv10}. Additionally, if $S$ is such that it is contained in no
other hyperedge in $\cF$, i.e., it is inclusion maximal then it is called
{\em super-marginal}.

\xnoindent A {\em star} graph is a complete bipartite graph $K_{1,p}$
which is clearly a tree and $p$ is the number of leaves. The vertex
with maximum degree is called the {\em center} of the star and the
edges are called {\em rays} of the star. A {\em $k$-subdivided star}
is a star with all its rays subdivided exactly $k$ times. The
definition of a {\em ray of a $k$-subdivided star} is extended to the path
from the center to a leaf. It is clear that all rays are of length $k+2$.


\section{Characterization of Feasible Tree Path  Labeling} 
\label{sec:feasible} 

In this section we give an algorithmic characterization of a
feasibility of tree path labeling.
% Consider a path labeling $\cl: \cF \rightarrow \cP$ for set system $\cF$
% and path system $\cP$ on the given tree $T$. We
% call $\cl$ an {\em Intersection Cardinality Preserving Path Labeling
%   (ICPPL)} if it has the following properties.
Consider a path labeling $(\cF, \cl)$ on the
given tree $T$. We call $(\cF, \cl)$ an {\em Intersection Cardinality
  Preserving Path Labeling (ICPPL)} if it has the following
properties.

%\vspace{\topshrink}

\begin{enumerate}[{(\icpplpr\ }i) \ \ \ ]
\item \label{pr:i} $|S| = |\cl(S)|$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for all $S \in \cF$
%  \vspace{\topshrink}
\item \label{pr:ii}$|S_1 \cap S_2| = |\cl(S_1) \cap \cl(S_2)|$ \ \ \ \ \ \ \ \ \ \
  \ \ \ \ \ \ \ \ \ \ for all distinct
  $S_1, S_2 \in \cF$
%  \vspace{\topshrink}
\item \label{pr:iii}$|S_1 \cap S_2 \cap S_3| = |\cl(S_1) \cap \cl(S_2) \cap
  \cl(S_3)|$ \ \ \ for all distinct $S_1, S_2, S_3 \in
  \cF$
\end{enumerate}


\noindent
The following lemma is useful in subsequent arguments. 
\begin{lemma}
  \label{lem:setminuscard}
  If $\cl$ is an ICPPL, and $S_1, S_2, S_3 \in \cF$, then $|S_1 \cap
  (S_2 \setminus S_3)| = |\cl(S_1) \cap (\cl(S_2) \setminus
  \cl(S_3))|$.
\end{lemma}
\begin{proof}%[Proof of Lemma~\ref{lem:setminuscard}]
  Let $P_i = \cl(S_i)$, for all $1 \le i \le  3$.
  $|S_1 \cap (S_2 \setminus S_3)| = |(S_1 \cap S_2) \setminus S_3| =
  |S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3|$. Due to properties (ii)
  and (iii) of ICPPL, $|S_1 \cap S_2| - |S_1 \cap S_2 \cap S_3| = |P_1
  \cap P_2| - |P_1 \cap P_2 \cap P_3| = |(P_1 \cap P_2) \setminus P_3|
  = |P_1 \cap (P_2 \setminus P_3)|$. Thus lemma is proven. \qed
\end{proof}

\def \xnoindent  {}

\xnoindent In the remaining part of this section we show that $(\cF,
\cl)$ is feasible if and only if it is an ICPPL and
Algorithm~\ref{al:icppl-find-isomorph} returns a non-empty
function. Algorithm~\ref{al:icppl-find-isomorph} recursively does two levels of
filtering of $(\cF, \cl)$ to make it simpler while retaining the set
of isomorphisms, if any, between $\cF$ and $\cF^\cl$.
% One direction of this claim isclear: that if a path
% labeling is feasible, then all intersection cardinalities are
% preserved, i.e. the path labeling is an ICPPL. Algorithm~\ref{perms}
% \annote{has no premature exit condition hence any input will go
%   through it}{Prove that the filtered sets has ICPPL iff input PL
%   has ICPPL?}. Algorithm~\ref{leafasgn} has an exit condition at
% line~\ref{xempty}. It can be easily verified that $X$ cannot be
% empty if $\cl$ is a feasible path labeling. The reason is that a
% feasible path labeling has an associated bijection between
% $supp(\cF)$ and $V(T)$ \remove{i.e. $supp(\cF^{\cl})$} such that
% the sets map to paths, ``preserving'' the path labeling.  The rest
% of the section is devoted to constructively proving that it is
% sufficient for a path labeling to be an ICPPL and pass the two
% filtering algorithms.  To describe in brief, the constructive
% approaches refine an ICPPL iteratively, such that at the end of each
% iteration we have a ``filtered'' path labeling, and finally we have
% a path labeling that defines a family of bijections from $supp(\cF)$
% to $V(T)$\remove{ i.e. $supp(\cF^{\cl})$}.
First, we present Algorithm~\ref{perms} or {\tt filter\_1}, and prove
its correctness.  This algorithm refines the path labeling by
processing pairs of paths in $\cF^\cl$ that share a leaf until no two
paths in the new path labeling share any leaf.

\begin{algorithm}[h]
  \caption{Refine ICPPL {\tt filter\_1($\cF, \cl, T$)}}
  \label{perms}
  \begin{algorithmic}[\lndisplay]
    \STATE $\cF_0 \assign \cF$, $\cl_0(S) \assign \cl(S)$ for all $S \in \cF_0$\\
    \STATE $j \assign 1$\\
    \WHILE {there is $S_1, S_2 \in \cF_{j-1}$ such that
      $\cl_{j-1}(S_1)$ and $\cl_{j-1}(S_2)$ have a common leaf in
      $T$}\label{shareleaf} \STATE $\cF_j \assign (\cF_{j-1} \setminus
    \{S_1, S_2\})
    \cup \{S_1 \cap S_2, S_1 \setminus S_2, S_2 \setminus S_1 \}$ \label{setbreak} 
    \COMMENT {Remove $S_1$, $S_2$ and add the ``filtered'' sets}
    \STATE {\bf for} every $S \in \cF_{j-1}$ s.t. $S \ne S_1$ and $S \ne
    S_2$ {\bf do} $\cl_j(S) \assign \cl_{j-1}(S)$ {\bf end for}\\

    \STATE $\cl_j(S_1 \cap S_2) \assign \cl_{j-1}(S_1) \cap
    \cl_{j-1}(S_2)$
    \COMMENT {Carry forward the path labeling for all existing sets other than
      $S_1$, $S_2$}
    \STATE $\cl_j(S_1 \setminus S_2) \assign \cl_{j-1}(S_1) \setminus
    \cl_{j-1}(S_2)$ 
    \COMMENT {Define path labeling for new sets}
    \STATE $\cl_j(S_2 \setminus S_1) \assign \cl_{j-1}(S_2) \setminus
    \cl_{j-1}(S_1)$

    \IF{$(\cF_j, \cl_j)$ does not satisfy (\icpplpr~\ref{pr:iii}) of ICPPL}
    \label{ln:3waycheck}
    \STATE {\bf exit} \label{ln:exit1} \\
    \ENDIF

    \STATE $j \assign j+1$\\
    \ENDWHILE
    \STATE $\cF' \assign \cF_j$, $\cl' \assign \cl_j$\\
    \RETURN $(\cF', \cl')$
  \end{algorithmic}
\end{algorithm}

\begin{lemma} 
 \label{lem:feasible} 
 In Algorithm~\ref{perms}, if input $(\cF, \cl)$ is a feasible path
 assignment then at the end of $j$th iteration of the {\bf while}
 loop, $j \ge 0$, $(\cF_j, \cl_j)$ is a feasible path assignment.
\end{lemma}
\begin{proof}%[Proof of Lemma~\ref{lem:feasible}]
  We will prove this by mathematical induction on the number of
  iterations. The base case $(\cF_0, \cl_0)$ is feasible since it is
  the input itself which is given to be feasible. Assume the lemma is
  true till $j-1$th iteration. i.e. every hypergraph isomorphism
  $\phi: supp\left(\cF_{j-1}\right) \rightarrow V\left(T \right)$ that
  defines $(\cF, \cl)$'s feasibility, is such that the induced path
  labeling on $\cF_{j-1}$, $\cl_{\phi[{\cF_{j-1}}]}$ is equal to
  $\cl_{j-1}$. We will prove that $\phi$ is also the bijection that
  makes $(\cF_j, \cl_j)$ feasible. Note that $supp(\cF_{j-1}) =
  supp(\cF_{j})$ since the new sets in $\cF_j$ are created from basic
  set operations to the sets in $\cF_{j-1}$. For the same reason and
  $\phi$ being a bijection, it is clear that when applying the $\phi$
  induced path labeling on $\cF_j$, $ \cl_{\phi[{\cF_{j}}]}(S_1
  \setminus S_2) = \cl_{\phi[{\cF_{j-1}}]}(S_1) \setminus
  \cl_{\phi[{\cF_{j-1}}]}(S_2)$. Now observe that $ \cl_j(S_1
  \setminus S_2) = \cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2) =
  \cl_{\phi[{\cF_{j-1}}]}(S_1) \setminus
  \cl_{\phi[{\cF_{j-1}}]}(S_2)$. Thus the induced path labeling
  $\cl_{\phi[{\cF_{j}}]} = \cl_{j}$. Therefore lemma is proven.  \qed
\end{proof}

\begin{lemma}
  \label{lem:invar1} In Algorithm~\ref{perms}, at the end of $j$th
  iteration, $j \ge 0$, of the {\bf while} loop, the following
  invariants are maintained.
  \begin{enumerate}[I {\ }] %\vspace{\topshrink}
  \item $\cl_j(R)$ is a path in $T$, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \ \ \ for all $R \in \cF_j$%\vspace{\topshrink}
  \item $|R| = |\cl_j(R)|$, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for all $R \in
    \cF_j$%\vspace{\topshrink}
  \item $|R \cap R'| = |\cl_j(R) \cap \cl_j(R')|$, \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \ \ \ for all $R, R' \in \cF_j$%\vspace{\topshrink}
  \item $|R \cap R' \cap R''|=|\cl_j(R) \cap \cl_j(R') \cap
    \cl_j(R'')|$, \ \ \ for all $R, R', R'' \in \cF_j$
  \end{enumerate}
\end{lemma}

\begin{proof}
 Proof is by induction on the number of iterations, $j$. In this
  proof, the term ``new sets'' will refer to the sets added to $\cF_j$
  in $j$th iteration in line~\ref{setbreak} of Algorithm~\ref{perms},
  $S_1 \cap S_2, S_1 \setminus S_2, S_2 \setminus S_1$ and its
  images in $\cl_j$ where $\cl_{j-1}(S_1)$
  and $\cl_{j-1}(S_2)$ intersect and share a leaf.\\
  The invariants are true in the base case $(\cF_0, \cl_0)$, since it
  is the input ICPPL.  Assume the lemma is true till the $j-1$th
  iteration. Let us consider the possible cases for each of the above invariants for
  the $j$th iteration.

  \xnoindent
 \begin{enumerate}[\xbullet]
  \item {\em Invariant} I/II
    \begin{enumerate}[{I/II}a $|$] % \textbullet 
    \item {\em $R$ is not a new set.} It is in $\cF_{j-1}$. Thus
      trivially true by induction hypothesis.
    \item {\em $R$ is a new set.} If $R$ is in $\cF_{j}$ and not in
      $\cF_{j-1}$, then it must be one of the new sets added in
      $\cF_j$. In this case, it is clear that for each new set, the
      image under $\cl_j$ is a path since by definition the chosen
      sets $S_1$, $S_2$ are from $\cF_{j-1}$ and due to the while loop
      condition, $\cl_{j-1}(S_1)$, $\cl_{j-1}(S_2)$ have a
      common leaf. Thus invariant I is proven.\\
      Moreover, due to induction hypothesis of invariant III and the
      definition of $l_j$ in terms of $l_{j-1}$, invariant II is
      indeed true in the $j$th iteration for any of the new sets.  If
      $R = S_1 \cap S_2$, $|R| = |S_1 \cap S_2| = |\cl_{j-1}(S_1) \cap
      \cl_{j-1}(S_2)| = |\cl_j(S_1 \cap S_2)| = |\cl_j(R)|$.
      If $R = S_1 \setminus S_2$, $|R| = |S_1 \setminus S_2| = |S_1| -
      |S_1 \cap S_2| = |\cl_{j-1}(S_1)| - |\cl_{j-1}(S_1) \cap
      \cl_{j-1}(S_2)| = |\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)| =
      |\cl_j(S_1 \setminus S_2)|
      = |\cl_j(R)|$. Similarly if $R = S_2 \setminus S_1$.\\
    \end{enumerate}
  \item {\em Invariant} III
    \begin{enumerate}[{III}a $|$]
    \item {\em $R$ and $R'$ are not new sets.} It is in
      $\cF_{j-1}$. Thus trivially true by induction hypothesis.
    \item {\em Only one, say $R$, is a new set.} Due to invariant IV
      induction hypothesis, Lemma~\ref{lem:setminuscard} and
      definition of $\cl_j$, it follows that invariant III is true no
      matter which of the new sets $R$ is equal to. If $R = S_1 \cap
      S_2$, $|R \cap R'| = |S_1 \cap S_2 \cap R'| = |\cl_{j-1}(S_1)
      \cap \cl_{j-1}(S_2) \cap \cl_{j-1}(R')| = |\cl_j(S_1 \cap S_2)
      \cap \cl_j(R')| = |\cl_j(R) \cap \cl_j(R')|$.  If $R = S_1
      \setminus S_2$, $|R \cap R'| = |(S_1 \setminus S_2) \cap R'| =
      |(\cl_{j-1}(S_1) \setminus \cl_{j-1}(S_2)) \cap \cl_{j-1}(R')| =
      |\cl_{j}(S_1 \cap S_2) \cap \cl_{j}(R')| = |\cl_{j}(R) \cap
      \cl_{j}(R')|$. Similarly, if $R = S_2 \setminus
      S_1$. Note $R'$ is not a new set.\\

    \item {\em $R$ and $R'$ are new sets.} By definition, the new
      sets and their path images in path label $\cl_j$ are disjoint so
      $|R \cap R'| = |\cl_j(R) \cap \cl_j(R)| = 0$. Thus case proven.
    \end{enumerate}
  \item {\em Invariant} IV
    
    Due to the condition in line~\ref{ln:3waycheck}, this invariant is
    ensured at the end of every iteration.
%     \begin{enumerate} [{Case 3.}1:]
%     \item {\em $R$, $R'$ and $R''$ are not new sets.} Trivially
%       true by induction hypothesis.
%     \item {\em Only one, say $R$, is a new set.}
%       If $R = S_1 \cap S_2$,  from Lemma~\ref{lem:fourpaths} and
%       invariant III hypothesis,  this case is proven. Similarly if $R$
%       is any of the other new  sets, the case is proven by also using
%       Lemma ~\ref{lem:setminuscard}.
%     \item {\em At least two of $R, R', R''$ are new sets.}
%       The new sets are disjoint hence this case is vacuously true.
%     \end{enumerate}
  \end{enumerate} \qed
%\vspace{-6mm} 

\end{proof}

\begin{lemma}
  \label{lem:noexit1}
  If the input ICPPL $(\cF, \cl)$ to Algorithm~\ref{perms} is
  feasible, then the set of hypergraph isomorphism functions that
  defines $(\cF, \cl)$'s feasibility is the same as the set that
  defines $(\cF_j, \cl_j)$'s feasibility, if any.  Secondly, for any
  iteration $j > 0$ of the {\em \bf while} loop, the {\em \bf exit}
  statement in line~\ref{ln:exit1} will not execute.
\end{lemma}
\begin{proof}
  Since $(\cF,\cl)$ is feasible, by Lemma~\ref{lem:feasible}
  $(\cF_j,\cl_j)$ for every iteration $j > 0$ is feasible.  % Therefore,
%   every hypergraph isomorphism $\phi: supp(\cF) \rightarrow V(T)$ that
%   induces $\cl$ on $\cF$ also induces $\cl_{j-1}$ and $\cl_{j}$ on
%   $\cF_{j-1}$ and $\cF_{j}$ respectively, i.e., $\cl_{\phi[\cF_{j-1}]}
%   = \cl_{j-1}$ and $\cl_{\phi[\cF_j]} = \cl_j$. Thus it can be seen
%   that for all $x \in supp(\cF)$, for all $v \in V(T)$ the following
%   hold true.
  Also, every hypergraph isomorphism $\phi: supp(\cF) \rightarrow
  V(T)$ that induces $\cl$ on $\cF$ also induces $\cl_{j}$ on
  $\cF_{j}$, i.e., $\cl_{\phi[\cF_j]} = \cl_j$. Thus it can be seen
  that for all $x \in supp(\cF)$, for all $v \in V(T)$, if $(x,v) \in
  \phi$ then $v \in \cl_{j}(S)$ for all $S \in \cF_{j}$ such that $x
  \in S$.
% the following
%   hold true.
%   \begin{enumerate}[i. ]
%   \item If $(x,v) \in \phi$ then $v \in \cl_{j-1}(S)$ for all $S \in
%     \cF_{j-1}$ such that $x \in S$.
%   \item If $(x,v) \in \phi$ then $v \in \cl_{j}(S)$ for all $S \in
%     \cF_{j}$ such that $x \in S$
%   \end{enumerate}
  In other words, filter 1 outputs a filtered path labeling that
  ``preserves''
  hypergraph isomorphisms of the original path labeling.\\
  Secondly, line~\ref{ln:exit1} will execute iff the exit condition in
  line~\ref{ln:3waycheck}, i.e. failure of three way intersection
  preservation, becomes true in any iteration of the {\em \bf while}
  loop.  Due to Lemma~\ref{lem:invar1} Invariant IV, the exit
  condition does not occur if the input is a feasible ICPPL.\qed

%   such that $\phi(x) = v$ where $v$ is the leaf considered in the
%   first iterations of while. Clearly, $\phi$ is a renaming of
%   vertices in hypergraph $\cF$ to those in hypergraph $\cF^\cl$. Thus
%   the following facts can be observed in every iteration of the loop.

%   \begin{enumerate}[\hspace{2mm}i. ] \vspace{\topshrink}
%   \item all intersection cardinalities are preserved in this path
%     labeling \vspace{\topshrink}
%   \item element $x$ is exclusive in a hyperedge in $\cF$ since $v$ is
%     exclusive in a hyperedge in $\cF^\cl$.
%   \end{enumerate}

%   Thus the exit condition is never rendered true after $x$ and $v$ are
%   removed from their respective hyperedges. \qed

% \noindent
% This proof uses mathematical induction on the number
%   of iterations $j$, $j \ge 0$, of the loop that executed
%   without exiting. The base case, $j = 0$ is obviously true since the
%   input is an ICPPL and the exit condition cannot hold true due to
%   ICPPL property (iii).  Assume the algorithm executes till the end
%   of $j-1$th iteration without exiting at line
%  ~\ref{ln:3waycheck}. Consider the $j$th iteration. From Lemma
%  ~\ref{lem:feasible} we know that $(\cF_j, \cl_j)$ and $(\cF_{j-1},
%   \cl_{j-1})$ are feasible\remove[AS]{and from the proof in lemma
%     lem:invar1 we know that $(\cF_{j-1}, \cl_{j-1})$ satisfies all the
%     invariants defined in the lemma}.  Thus there exists a bijection
%   $\phi: supp(\cF) \rightarrow V(T)$ such that the induced path
%   % labeling on $\cF_{j-1}$ $\cl_{\phi[\cF_{j-1}]} = \cl_{j-1}$.
%   labeling on $\cF_{j}$, $\cl_{\phi[\cF_{j}]}$ and on $\cF_{j-1}$,
%   $\cl_{\phi[\cF_{j-1}]}$ are equal to $\cl_{j}$ and $\cl_{j-1}$
%   respectively.  We need to prove that for any $R, R', R'' \in
%   \cF_{j}$, $|R \cap R' \cap R''| = |\cl_j(R) \cap \cl_j(R') \cap
%   \cl_j(R'')|$.
%   The following are the possible cases that could arise. From argument
%   above, $|\cl_j(R) \cap \cl_j(R') \cap \cl_j(R'')| =
%   |\cl_{\phi[\cF_{j}]}(R) \cap \cl_{\phi[\cF_{j}]} (R') \cap
%   \cl_{\phi[\cF_{j}]} (R'')|$

%   \begin{enumerate}[a $|$]
%   \item {\em None of the sets are new. $R, R', R'' \in \cF_{j-1}$.}
%     We know $(\cF_{j-1}, \cl_{j-1})$ is feasible. Thus $|R \cap R'
%     \cap R''| = |\cl_{j-1}(R) \cap \cl_{j-1}(R') \cap \cl_{j-1}(R'')|
%     = |\cl_{j}(R) \cap \cl_{j}(R') \cap \cl_{j}(R'')|$.
%   \item {\em Only one, say $R$, is a new set.}  Let $R = S_1 \cap S_2$
%     ($S_1, S_2$ are defined in the proof of lemma
%    ~\ref{lem:invar1}). Now we have $|R \cap R' \cap R''| = |S_1 \cap
%     S_2 \cap R' \cap R''| = |\cl_{j-1}(S_1) \cap \cl_{j-1}(S_2) \cap
%     \cl_{j-1}(R') \cap \cl_{j-1}(R'')| = |\cl_{j}(R) \cap \cl_{j}(R')
%     \cap \cl_{j}(R'')|$. Thus proven. If $R$ is any of the other new
%     sets, the same claim can be verified using lemma
%    ~\ref{lem:setminuscard}.
%     % \item []{\bf Case 3:}
%   \item {\em At least two of $R, R', R''$ are new sets.}  The new sets
%     are disjoint hence this case is vacuously true.
%   \end{enumerate}
%   \qed
%   \tnote[E2]{remove the induction proof. just text saying x and v are
%     exclusive in these sets therefore the intersection cardinalities
%     don't change thus all invariants are still true} 
\end{proof}

\xnoindent As a result of Algorithm~\ref{perms} each leaf $v$ in $T$
is such that there is exactly one set in $\cF$ with $v$ as a vertex in
the path assigned to it.  In Algorithm~\ref{leafasgn} we identify
elements in $supp(\cF)$ whose images are leaves in a hypergraph
isomorphism if one exists.  Let $S \in \cF$ be such that $\cl(S)$ is a
path with leaf and $v \in V(T)$ is the unique leaf incident on it.  We
define a new path labeling $\cl_{new}$ such that $\cl_{new}(\set{x}) =
\set{v}$ where $x$ an arbitrary element from $S \setminus \bigcup_{\hS
  \ne S} \hS$. In other words, $x$ is an element present in no other
set in $\cF$ except $S$. This is intuitive since $v$ is present in no
other path image under $\cl$ other than $\cl(S)$.  The element $x$ and
leaf $v$ are then removed from the set $S$ and path $\cl(S)$
respectively. After doing this for all leaves in $T$, all path images
in the new path labeling $\cl_{new}$ except leaf labels (a path that
has only a leaf is called the {\em leaf label} for the corresponding
single element hyperedge or set) are paths from a new pruned tree $T_0
= T \setminus \{v \mid v \text{ is a leaf in }
T\}$. Algorithm~\ref{leafasgn} is now presented with details.


\begin{algorithm}[h]
  \caption{Leaf labeling from an ICPPL {\tt filter\_2($\cF, \cl, T$)}}
  \label{leafasgn}
  \begin{algorithmic}[\lndisplay]
    \STATE $\cF_0 \assign \cF$, $\cl_0(S) \assign \cl(S)$ for all $S \in \cF_0$
    \COMMENT {Path images are such that no two path images share a
      leaf.}
    \STATE $j \assign 1$\\
    \WHILE {there is a leaf $v$ in $T$ and a unique $S_1 \in
      \cF_{j-1}$ such that $v \in \cl_{j-1}(S_1)$ }\label{uniqueleaf}
    \STATE $\cF_j \assign \cF_{j-1} \setminus \{S_1\}$\\
    \STATE for all $S \in \cF_{j-1}$ such that $S \ne S_1$ set
    $\cl_j(S) \assign
    \cl_{j-1}(S)$\\
    \STATE $X \assign S_1 \setminus \bigcup_{S \in \cF_{j-1}, S \ne S_1}S$\\
    \IF{$X$ is empty} \label{xempty} \STATE {\bf exit} \label{ln:exit2} \ENDIF
    \STATE $x \assign $ arbitrary element from $X$\\
    \STATE $\cF_j \assign \cF_j \cup \{\{x\}, S_1 \setminus \{x\}\} $\\
    \STATE $\cl_j(\{x\}) \assign \{v\}$\\
    \STATE $\cl_j(S_1 \setminus \{x\}) \assign \cl_{j-1}(S_1) \setminus \{v\}$\\
    \STATE $j \assign j+1$\\
    \ENDWHILE
    \STATE $\cF' \assign \cF_j$, $\cl' \assign \cl_j$\\
    \RETURN $(\cF', \cl')$
  \end{algorithmic}
\end{algorithm}

\xnoindent
Suppose the input ICPPL $(\cF, \cl)$ is feasible, yet set $X$ in
Algorithm~\ref{leafasgn} is empty in some iteration of the {\bf while}
loop. This will abort our procedure of finding the hypergraph
isomorphism. The following lemma shows that this will not happen.

\begin{lemma}
  \label{lem:xnotempty}
  If the input ICPPL $(\cF, \cl)$ to Algorithm~\ref{leafasgn} is
  feasible, then for all iterations $j > 0$ of the {\em \bf while}
  loop, the {\em \bf exit} statement in line~\ref{ln:exit2} does not
  execute.
\end{lemma}
\begin{proof}
  Assume $X$ is empty for some iteration $j > 0$. We know that $v$ is
  an element of $\cl_{j-1}(S_1)$. Since it is uniquely present in
  $\cl_{j-1}(S_1)$, it is clear that $v \in \cl_{j-1}(S_1) \setminus
  \bigcup_{(S \in \cF_{j-1}) \wedge (S \ne S_1)}\cl_{j-1}(S)$.  Note
  that for any $x \in S_1$ it is contained in at least two sets due to
  our assumption about cardinality of $X$. Let $S_2 \in \cF_{j-1}$ be
  another set that contains $x$. From the above argument, we know $v
  \notin \cl_{j-1}(S_2)$. Therefore there cannot exist a hypergraph
  isomorphism bijection that maps elements in $S_2$ to those in
  $\cl_{j-1}(S_2)$. This contradicts our assumption that the input is
  feasible. Thus $X$ cannot be empty if input is ICPPL and feasible.
  \qed
\end{proof}

\begin{lemma}
  \label{lem:invar3}
  In Algorithm~\ref{leafasgn}, for all $j > 0$, at the end of the
  $j$th iteration of the {\bf while} loop the four invariants given in
  Lemma~\ref{lem:invar1} hold.
\end{lemma}
\begin{proof}
  By Lemma~\ref{lem:xnotempty} we know that set $X$ will not be empty
  in any iteration of the {\em \bf while} loop if input ICPPL $(\cF,
  \cl)$ is feasible and $\cl_j$ is always computed for all $j >
  0$. Also note that removing a leaf from any path keeps the new path
  connected. Thus invariant I is obviously true. In every iteration $j
  > 0$, we remove exactly one element $x$ from one set $S$ in $\cF$
  and exactly one vertex $v$ which is a leaf from one path
  $\cl_{j-1}(S)$ in $T$. This is because as seen in
  Lemma~\ref{lem:xnotempty}, $x$ is exclusive to $S$ and $v$ is
  exclusive to $\cl_{j-1}(S)$. Due to this fact, it is clear that the
  intersection cardinality equations do not change, i.e., invariants
  II, III, IV remain true. On the other hand, if the input ICPPL is
  not feasible the invariants are vacuously true. \qed
\end{proof}

% \textcolor{cyan}{
% \begin{lemma}
%   \label{lem:notfeasibleexit}
%   \tnote{IS THIS CORRECT?}  If input ICPPL $(\cF, \cl)$ is not
%   feasible, then in one of the recursive calls to Algorithm --3--, the
%   {\em \bf exit} statement in line x in Algorithm --1 or line y in
%   Algorithm --2 will get executed.
% \end{lemma}
% }


\xnoindent We have seen two filtering algorithms above, namely,
Algorithm~\ref{perms} {\tt filter\_1} and Algorithm~\ref{leafasgn}
{\tt filter\_2} which when executed serially repectively result in a
new ICPPL on the same universe $U$ and tree $T$. We also proved that
if the input is indeed feasible, these algorithms do indeed output the
filtered ICPPL. Now we present the algorithmic characterization of a
feasible tree path labeling by way of Algorithm~\ref{al:icppl-find-isomorph}.

\xnoindent Algorithm~\ref{al:icppl-find-isomorph} computes a
hypergraph isomorphism $\phi$ recursively using Algorithm~\ref{perms}
and Algorithm~\ref{leafasgn} and pruning the leaves of the input
tree. In brief, it is done as follows. Algorithm~\ref{leafasgn} gives
us the leaf labels in $\cF_2$, i.e., the elements in $supp(\cF)$ that
map to leaves in $T$, where $(\cF_2, \cl_2)$ is the output of
Algorithm~\ref{leafasgn}. All leaves in $T$ are then pruned away. The
leaf labels are removed from the path labeling $\cl_2$ and the
corresponding elements are removed from the corresponding sets in
$\cF_2$. This tree pruning algorithm is recursively called on the
altered hypergraph $\cF'$, path label $\cl'$ and tree $T'$. The
recursive call returns the bijection $\phi''$ for the rest of the
elements in $supp(\cF)$ which along with the leaf labels $\phi'$ gives
us the hypergraph isomorphism $\phi$.  The following lemma formalizes
the characeterization of feasible path labeling.

\begin{algorithm}[h]
  \caption{{\tt get-hypergraph-isomorphism($\cF, \cl, T$)}}
  \label{al:icppl-find-isomorph}
  \begin{algorithmic}[\lndisplay]

    \IF{$T$ is empty}
    \RETURN $\emptyset$\\
    \ENDIF
    \STATE $L \assign \{v \mid v \text{ is a leaf in }      T\}$\\
    \STATE $(\cF_1, \cl_1) \assign$ {\tt filter\_1($\cF, \cl,
      T$)}\\
    \STATE $(\cF_2, \cl_2) \assign$ {\tt filter\_2($\cF_1,
      \cl_1, T$)}\\

    \STATE $(\cF', \cl') \assign (\cF_2, \cl_2)$\\
    \STATE $\phi' \leftarrow \emptyset$

    \FOR {every $v \in L$}
    \STATE $\phi'(x) \assign v$ where $x \in \cl_2^{-1}(\{v\})$
    \COMMENT {Copy the leaf labels to a one to one function $\phi':
      supp(\cF) \rightarrow L$
      }\\
    \STATE Remove $\{x\}$ and $\{v\}$ from $\cF'$, $\cl'$  appropriately\\
    \ENDFOR

    \STATE $T' \assign T \setminus L$

    \STATE $\phi'' \assign$ {\tt
      get-hypergraph-isomorphism($\cF', \cl', T'$)}
    \STATE $\phi \assign \phi'' \cup \phi'$ \\
    \RETURN $\phi$
  \end{algorithmic}
\end{algorithm}

\begin{lemma}
  \label{lem:hyperiso}  %{lem:perm}
  If $(\cF, \cl)$ is an ICPPL from a tree $T$ and
  Algorithm~\ref{al:icppl-find-isomorph}, {\tt
    get-hypergraph-isomorphism ($\cF, \cl, T$)} returns a non-empty
  function, then there exists a hypergraph isomorphism $\phi :
  supp(\cF) \rightarrow V(T)$ such that the $\phi$-induced tree path
  labeling is equal to $\cl$ or $\cl_\phi = \cl$.
\end{lemma}
\begin{proof}
  It is clear that in the end of every recursive call to
  Algorithm~\ref{al:icppl-find-isomorph}, the function $\phi'$ is one
  to one involving all the leaves in the tree passed as input to that
  recursive call. Moreover, by Lemma~\ref{lem:noexit1} and
  Lemma~\ref{lem:xnotempty} it is consistent with the tree path
  labeling $\cl$ passed. The tree pruning is done by only removing
  leaves in each call to the function and is done till the tree
  becomes empty. Thus the returned function $\phi: supp(\cF)
  \rightarrow V(T)$ is a union of mutually exclusive one to one
  functions exhausting all vertices of the tree. In other words, it is
  a bijection from $supp(\cF)$ to $V(T)$ inducing the given path
  labeling $\cl$ and thus a hypergraph isomorphism. \qed
\end{proof}

\begin{theorem}
  \label{th:charac}
  A path labeling $(\cF, \cl)$ on tree $T$ is feasible iff it is an
  ICPPL and Algorithm~\ref{al:icppl-find-isomorph} with $(\cF, \cl,
  T)$ as input returns a non-empty function.
\end{theorem}
\begin{proof}
  From Lemma~\ref{lem:hyperiso}, we know that if $(\cF, \cl)$ is an
  ICPPL and Algorithm~\ref{al:icppl-find-isomorph} with $(\cF, \cl,
  T)$ as input returns a non-empty function, $(\cF, \cl)$ is feasible.
  Now consider the case where $(\cF, \cl)$ is feasible. i.e. there
  exists a hypergraph isomorphism $\phi$ such that $\cl_\phi =
  \cl$. Lemma~\ref{lem:noexit1} and Lemma~\ref{lem:xnotempty} show us
  that filter 1 and filter 2 do not exit if input is feasible. Thus
  Algorithm~\ref{al:icppl-find-isomorph} returns a non-empty function.\qed
\end{proof}


\subsection{ICPPL when given tree is a path}
\label{subsec:icpplicpia}
\xnoindent
Consider a special case of ICPPL with the following properties.
\begin{enumerate}
\item Given tree $T$ is a path. Hence, all path labels are interval labels.
\item Only pairwise intersection cardinality
  preservation is sufficient. i.e. property (iii) in ICPPL is not enforced.
\item The filter algorithms do not have {\em \bf exit} statements.
\end{enumerate}
This is called an Intersection Cardinality Preservation Interval
Assignment (ICPIA) \cite{nsnrs09}. This structure and its algorithm is
used in the next section for finding tree path labeling from a
$k$-subdivided star due to this graph's close relationship with
intervals. 


\section{Testing for feasible path assignments to $k$-subdivided star}
\label{sec:ksubdivstar}
In this section we consider the problem of assigning paths from a
$k$-subdivided star $T$ to a given set system $\cF$.  We consider
$\cF$ for which the overlap graph $\bO(\cF)$ is connected.  The
overlap graph is well-known from the work of
\cite{kklv10,nsnrs09,wlh02}.  We use the notation in
\cite{kklv10}. Recall from Section~\ref{sec:prelims} that hyperedges
$S$ and $S'$ are said to overlap, denoted by $S \overlap S'$, if $S$ and $S'$
have a non-empty intersection but neither of them is contained in the
other. The overlap graph $\bO(\cF)$ is a graph in which the vertices
correspond to the sets in $\cF$, and the vertices corresponding to the
hyperedges $S$ and $S'$ are adjacent if and only if they overlap.  Note
that the intersection graph of $\cF$, $\bI(\cF)$ is different from
$\bO(\cF)$ and $\bO(\cF) \subseteq \bI(\cF)$.  A connected component
of $\bO(\cF)$ is called an overlap component of $\cF$.  An interesting
property of the overlap components is that any two distinct overlap
components, say $\cO_1$ and $\cO_2$, are such that any two sets $S_1
\in \cO_1$ and $S_2 \in \cO_2$ are disjoint, or, w.l.o.g, all the sets
in $\cO_1$ are contained within one set in $\cO_2$.  This containment
relation naturally determines a decomposition of the overlap
components into rooted containment trees.  We consider the case when
there is only one rooted containment tree, and we first present our
algorithm when $\bO(\cF)$ is connected.  It is easy to see that once
the path labeling to the overlap component in the root of the
containment tree is achieved, the path labeling to the other overlap
components in the rooted containment tree is essentially finding a
path labeling when the target tree is a path: each target path is a
path that is allocated to sets in the root overlap component.
Therefore, for the rest of this section, $\bO(\cF)$ is a connected
graph. We also assume that all hyperedges are of cardinality at most
$k+2$.


\xnoindent
Recall from Section~\ref{sec:prelims} that a $k$-subdivided star is a
star with each edge subdivided $k$ times.  Therefore, a $k$-subdivided
star has a central vertex which we call the {\em root}, and each root
to leaf path is called a {\em ray}.  First, we observe that by
removing the root $r$ from $T$, we get a collection of $p$ vertex
disjoint paths of length $k+1$, $p$ being the number of leaves in $T$.
We denote the rays by $R_1, \ldots, R_p$, and the number of vertices in
$R_i$, $i \in [p]$ is $k+2$.  Let
$\seq{v_{i1},\ldots,v_{i(k+2)}=r}$ denote the sequence of vertices in
$R_i$, where $v_{i1}$ is the leaf. Note that $r$ is a common vertex to all $R_i$.
  

\xnoindent In this section the given hypergraph, the
$k$-subdivided star and the root of the star are denoted by $\cO$, $T$ and vertex
$r$, respectively.
% For each hyperedge $X \in \cO$, we will maintain a 2-tuple of non-negative
% numbers $\seq{p_1(X), p_2(X)}$.  The numbers satisfy the property that
% $p_1(X) + p_2(X) \leq |X|$, and at the end of path labeling, for each
% $X$, $p_1(X) + p_2(X) = |X|$.  This signifies the algorithm tracking
% the lengths of subpaths of the path assigned to $X$ from at most two
% rays. We also maintain another parameter called the {\em residue} of
% $X$ denoted by $s(X)=|X| - p_1(X)$. This signifies the residue path
% length that must be assigned to $X$ which must be from another
% ray. For instance, if $X$ is labeled a path from only one ray, then
% $p_1(X) = |X|$, $p_2(X) = 0$ and $s(X) = 0$.

% \xnoindent
% We iteratively consider each ray from which paths will be assigned to
% hyperedges. At the beginning of each iteration hyperedges of $\cO$ are
% classifed into the following disjoint sets.
% \begin{enumerate}
% \item [$\cL_1^i$] {\em Labeled without $r$.} Those that have been
%   labeled with a path which does not contain $r$ in one of the
%   previous iterations.\\  $\cL_1^i = \set{ X \mid p_1(X) = |X| \text{ and
%     } p_2(X) = 0 \text{ and } s(X) = 0, X \in \cO}$
% \item [$\cL_2^i$] {\em Labeled with $r$.} Those that have been labeled
%   with two subpaths of $\cl(X)$ containing $r$ from two different rays
%   in two previous iterations.\\ $\cL_2^i = \set{X \mid 0 < p_1\left(X\right),
%     p_2\left(X\right) < |X| \text{ and } s(X) = 0, X \in \cO}$
%   \item [$\cT_1^i$] {\em Type 1 / partially labeled.} Those that have
%     been labeled with one path containing $r$ from a single ray in one
%     of the previous iterations. Here, $p_1(X)$ denotes the length of
%     the subpath of $\cl(X)$ that $X$ has been so far labeled
%     with. Also, it is clear that such a path must start at $r$ and
%     must be in a ray different from the one corresponding to $p_1(X)$.\\
%     $\cT_1^i = \set{ X \mid 0 < p_1(X) < |X| \text{ and } p_2(X) = 0
%       \text{ and } s(X) > 0, X \in \cO}$
%   \item [$\cT_2^i$] {\em Type 2 / not labeled.} Those that have not been
%     labeled with a path in any previous iteration.\\
%     $\cT_2^i = \set{ X \mid p_1(X) = p_2(X) = 0 \text{ and } s(X) = |X|,
%       X \in \cO}$
% \end{enumerate}
% \vspace{-2mm}
% \begin{align*}
%   \cO &= \cL_1^i \cup \cL_2^i \cup \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]\\
%   \cO_i &= \cT_1^i \cup \cT_2^i, \text{    } \forall i \in [p]
% \end{align*}

\xnoindent
The set $\cO_i$ refers to the set of hyperedges $\cT_1^i \cup \cT_2^i$ in
the $i$th iteration.  Note that $\cO_1 = \cO$.  In the $i$th
iteration, hyperedges from $\cO_i$ are assigned paths from $R_i$ using
the following rules. Also the end of the iteration, $\cL_1^{i+1}, \cL_2^{i+1}, \cT_1^{i+1},
\cT_2^{i+1}$ are set to $\cL_1^{i}, \cL_2^{i}, \cT_1^{i},
\cT_2^{i}$ respectively, along with some case-specific changes mentioned in the
rules below.

\noindent
Suppose the given hypergraph has a feasible path labeling to the given
tree $T$. Let this labeling be $\cl$. Now we present an algorithm that
lists the sequence of edges that maintain a set of properties
necessary for them to have a feasible tree path labeling.
\begin{enumerate}[I.]
\item {\bf Step 1}
  \begin{enumerate}
  \item {\bf {There are type 1
        edges, $\mathbf{|\cT_1^i| > 0}$}:} 
% , and for each such $X$ assign the
%     path in $R_i$ of length $s(X)$ starting at $v_{i,k+2}=r$.  $X$ is
%     then removed from $\cO_i$, and $p_2(X)=s(X)$, and $s(X)=0$.If any
%     intersection cardinality is violated because of this assignment,
%     EXIT reporting the non-existence of a feasible assignment.
  {If there is only one $\cT_1^i$ hyperedge, label it to the unique
    path in $R_i$ of length $s(X)$ starting at $v_{i(k+2)}=r$. If
    there are more than one $\cT_1^i$ hyperedges, for any pair of
    hyperedges $S_1, S_2 \in \cT_1^i$, one of the following is
    true. Let $\cl'(X) \subseteq R_j$ denote the subpath of length
    $p_1(X)$ that has been assigned to $X$ from a previously
    considered ray $R_j$.}
  \begin{enumerate}[{\em Case }1. ]
  \item $|\cl'(S_1) \cap \cl'(S_2)| = 1$ and $|S_1 \cap S_2| > 1$
    i.e. they are in different rays and their residues must contain
    their intersection. Hence assign both to $R_i$.
  \item $|\cl'(S_1) \cap \cl'(S_2)| > 1$ and $|S_1 \cap S_2| >
    |\cl'(S_1) \cap \cl'(S_2)|$ i.e. they are in the same rays and
    their residues must contain their intersection. Hence assign both
    to $R_i$.
  \item $|\cl'(S_1) \cap \cl'(S_2)| > 1$ and $|S_1 \cap S_2| =
    |\cl'(S_1) \cap \cl'(S_2)|$. i.e. the intersection cardinality has
    been met. Hence assign only $S_1$ to $R_i$ and $S_2$ must be
    assigned to some $i \ge p$.
  \end{enumerate}
  Remove the labeled edge or edges from $\cO_i$ and add it to
  $\cO_{i+1}$. Also do not add it to $\cT_1^{i+1}$ and add to
  $\cL_2^{i+1}$.
\item {\bf {There are no type-1 edges nor} super-marginal type-2
    hyperedges:} If all type-2 edges of length at most $k+1$, EXIT by
  saying there is no ICPPL.  Otherwise, Find an $X$ of type-2 such
  that $|X| \geq k+2$, assign it the unique path starting at
  $v_{i(k+1)}=r$ of length $k+2$, and set $p_1(X)=k+2,
  s(X)=|X|-(k+2)$, assign it the unique path starting at
  $v_{i(k+1)}=r$ of length $k+2$, mark this as a type-1 hyperedge, and
  add it to $\cO_{i+1}$ after removing it from $\cO_i$.
  % \remove{Next, iteratively, consider each type-1 edge $X \in
  %   \cO_i$, and if it intersects a previously assigned $Y$ such that
  %   $\cl(Y) \subseteq R_i$, assign a path of length $s(X)$
  %   containing $v_{i(k+2)}=r$, set $p_2(X)=s(X), s(X)=0$, and remove
  %   $X$ from $\cO_i$.}\tnote{covered in step 2}

\item {\bf There are super-marginal type-2 hyperedges {and no type-1
      edges:}} Let $X$ be a super-marginal hyperedge. If $|X| \leq
  k+2$, then $X$ is assigned the path of length $|X|$ starting at
  $v_{i1}$, and $p_1(X) = |X|, p_2(X)=0$. $X$ is removed from $\cO_i$
  and not added to $\cO_{i+1}$.  If $|X| > k+2$, then $p_1(X)=k+2$,
  assign it the unique path starting at $v_{i(k+1)}=r$ of length $k+2$
  and $s(X) = |X| - (k+2)$.  In this case, $X$ is classified as a
  Type-1 edge, removed from $\cO_i$, and added to $\cO_{i+1}$.
\end{enumerate}
\item {\bf Step 2:} Iteratively, a hyperedge $X$ is selected from
  $\cO_i$ that has an overlap with one of the hyperedges $Y$ such that
  $\cl(Y) \subseteq R_i$, and a unique path is assigned to $X$.  The
  path, say $U(X) \subseteq R_i$, that is assigned can be decided
  unambiguously since the $X \overlap Y$, and all intersection
  cardinalities can be preserved only at one of the ends of $\cl(Y)$.
  
  \noindent
  Let $\cl(X)$ denote the unique path assigned to $X$.  If $X$ is a
  type-2 hyperedge and if the unique path of length $|X|$ does not
  contain $r$, then $p_1(X) = |X|, p_2(X)=0$, and $X$ is removed from
  $\cO_i$.  In the case when $\cl(X)$ has to contain $r$, then
  $p_1(X)$ is the length of the path, $p_2(X)=0$, and $s(X) =
  |X|-p_1(X)$. Further $X$ is classified as a type-1 hyperedge, added
  to $\cO_{i+1}$ and removed from $\cO_i$.  In the case when $X$ is a
  type-1 hyperedge, then we check if $U(X)$, which is of length $s(X)$
  contains $r$. If it does, then we assign $\cl(X) \leftarrow \cl(X)
  \cup U(X)$, remove $X$ from $\cO_i$ and do not add it to
  $\cO_{i+1}$.  If not, then we {\bf Exit} reporting that an
  assignment cannot be found.  The iteration ends when no hyperedge in
  $\cO_i$ has an overlap with a hyperedge assigned to $R_i$.
\end{enumerate}

\noindent
The order in which they are assigned is the sequence of hyperedges
with the following properties. Note that if such a sequence cannot be
computed, $\cO$ cannot have a feasible path labeling from $T$.

\noindent
\tnote{need to formalize the below properties} In the following
lemmas we identify a set of necessary conditions for $\cF$ to have an
ICPPL in the $k$-subdivided star $T$.  If during the execution of the
above algorithm, one of these necessary conditions is not satisfied,
the algorithm exits reporting the non-existence of an ICPPL.
\begin{lemma}
  Let all hyperedges in $\cO_i$ be type-1 edges.  Then there is a
  maximal subset $\ccT_i \subseteq \cO_i$ with the following
  properties:
  \begin{enumerate}
  \item $\ccT_i$ form an inclusion chain.
  \item For all $X \in \ccT_i$, $s(X) \leq k+2$, and There is a an $X
    \in \ccT_i$ such that $s(X)=k+2$.
  \end{enumerate}
\end{lemma}
\begin{lemma}
  If there are no \marginal type-2 edges in $\cO_i$, then there exists
  at least $p-i$ type-2 hyperedges $X \in \cO_i$ such that $|X| \geq
  k+2$.
  % is a exist type-2 hyperedges of length at least $k+2$, and there
  % must be at least $r-i$ such type-2 hyperedge, basically at least
  % one per ray.  Each hyperedge contained in such an hyperedges of
  % length at least $k+2$, is transitively related under the overlap
  % relation to one that gets assigned a path that contains
  % $r$. Basically, the proof will argue that otherwise, there will be
  % a \marginal type-2 hyperedge, or that it is infeasible.  Also, it
  % is here we assume that we assume that the size of the two
  % universes is the same.
\end{lemma}
\begin{lemma}
  At the end of Step-1 in the $i$-th iteration, if one hyperedge $X$
  of type-2 is such that $\cl(X) \subseteq R_i$, then all other
  hyperedges in $\cO_i$ are connected to $X$ in the overlap component.
\end{lemma}
\begin{lemma}
  At the end of Step-2, If control has exit at any time, there is no
  ICPPL. If control has not exit, then $R_i$ is saturated.  No
  hyperedge of $\cO_{i+1}$ will get a path from $R_i$ in the future
  iterations.  No type-2 hyperedge of $\cO_{i+1}$ will get a path from
  $R_i$.  Basically $R_i$ is done.
\end{lemma}
\begin{lemma}
  Finally, we need to prove that the assignment is an ICPPL. Secondly,
  if there is a permutation then maps sets to paths, then it is indeed
  an ICPPL, and our algorithm will basically find it.  It is a unique
  assignment upto permutation of the leaves.
\end{lemma}


\begin{lemma}
  \label{lem:sup-mar}
  If $X \in \cF$ is super-marginal and $(\cF, \cl)$ is a feasible
  tree path labeling to tree $T$, then $\cl(X)$ will
  contain a leaf in $T$.\\
  On the otherhand, if $\cl(X)$ has a leaf in
  $T$, $X$ is marginal but may not be super-marginal.
\end{lemma}
\begin{proof}
  Suppose $X \in \cF$ is super-marginal and $(\cF, \cl)$ is a feasible
  path labeling from $T$.  Assume $\cl(X)$ does not have a leaf.  Let
  $R_i$ be one of the rays (or the only ray) $\cl(X)$ is part of.
  Since $X$ is in a connected overlap component, there exists $Y_1 \in
  \cF$ and $X \nsubseteq Y_1$ such that $Y_1 \overlap X$ and $Y_1$ has
  at least one vertex closer to the leaf in $R_i$ than any vertex in
  $X$. Similarly with the same argument there exists $Y_2 \in \cF$
  with same subset and overlap relation with $X$ except it has has at
  least one vertex farther away from the leaf in $R_i$ than any vertex
  in $X$. Clearly $Y_1 \cap X$ and $Y_2 \cap X$ cannot be part of same
  inclusion chain which contradicts that assumption $X$ is
  super-marginal. Thus the claim is proven.\qed
\end{proof}

\noindent
Consider the overlap graph $\bO(\cF)$ of the given hypergraph
$\cF$. Let $S_{sm} \in \cF$ be such that it is a super-marginal
hyperedge.  Algorithm~\ref{al:ktree-label} uses $S_{sm}$ along with
the overlap graph $\bO(\cF)$ to calculate the feasible tree path
labeling to the $k$-subdivded tree $T$.

\begin{algorithm}[h]
  \caption{{\tt compute-ksubtree-path-labeling($X, \cF, T$)}}
  \label{al:ktree-label}
  \begin{algorithmic}[\lndisplay]
    \IF{$X = S_{sm}$}
    \STATE -- TBD --\\
    \ELSE 
    \STATE -- TBD --\\
    \ENDIF

 \end{algorithmic}
\end{algorithm}


% \subsection{temp section from nsnsr09}

% \begin{algorithm}
%   \caption{Basic step in an algorithm to find an ICPIA for a prime
%     matrix $M'$}
%   \label{ds-algo}
%   ICPIA(Set $S$, Integer $p > 0$)

% \noindent
% /* {\tt $S \cap S^i \not = \phi$ for some $i \in \{1,\ldots,p\}$, but
%   $S \not\subseteq S^i$, $S^i \not\subseteq S$.  \\ Assigns to $S$ an
%   interval $I$ such that $\{I^1,\ldots,I^p,I\}$ forms an ICPIA for
%   $\{S^1,\ldots,S^p,S\}$.} */
% \begin{algorithmic}
%   \STATE Let $|S \cap S^i| = z$. \\
%   \STATE Let $I_l$ be the interval such that $|I_l \cap I^i| = z$, $|I_l| = |S|$ and the $z$ common elements are the smallest elements of $I^i$. \\
%   \STATE Let $I_r$ be the interval such that $|I_r \cap I^i| = z$, $|I_r| = |S|$, and the $z$ common elements are the largest elements of $I^i$. \\
%   \IF {$p == 1$}
%   \STATE Assign $I_l$ to $S$ \\
%   \STATE /* {\tt In this case, $I_r$ could also be assigned to $S$.  This will yield the {\bf other} ICPIA} */\\
%   \ELSE \IF{$|I_l \cap I^q| = |S \cap S^q|$ for each $q \in
%     \{1,\ldots,p\}$}
%   \STATE Assign $I_l$ to $S$ and exit.\\
%   \ENDIF \IF{$|I_r \cap I^q| = |S \cap S^q|$ for each $q \in
%     \{1,\ldots,p\}$}
%   \STATE Assign $I_r$ to $S$ and exit.\\
%   \ENDIF \ENDIF \STATE Report no ICPIA and exit.
% \end{algorithmic}
% \end{algorithm}


% \begin{theorem}
%   Algorithm~\ref{ds-algo} outputs an ICPIA to a prime matrix $M'$ iff
%   there is an ICPIA for $M'$.
% \end{theorem}
% \begin{proof}
%   The only-if part of the theorem is straightforward.  We now show
%   that if there is an ICPIA for $M'$, then Algorithm~\ref{ds-algo}
%   will indeed discover it.  The key fact is that in $M'$ for each set
%   $S$, there is another set $T \in M'$ such that $S \cap T \not =
%   \phi$, and $S$ and $T$ are not contained in each other.  Due to this
%   fact, there are exactly two ICPIAs for $M'$.  The two distinct
%   ICPIAs differ based on the interval assigned to $S_1$, see Algorithm
%  ~\ref{ds-algo}.  If $I_l$ is assigned to $S_1$, then we get one, and
%   the other ICPIA is obtained by assigning $I_r$ to $S_1$.  For each
%   subsequent set, say $S^j$, the interval to be assigned is forced.
%   It is forced due to the fact that the interval assigned to $S^j$ is
%   based on the interval assigned to $S^i$, where $S^i \cap S^j \not =
%   \phi$, and $S^i \not\subseteq S^j$, and $S^j \not\subseteq S^i$.
%   Given the fact that the algorithm is an exact implementation of
%   these observations, it follows that Algorithm~\ref{ds-algo} finds an
%   ICPIA if there is one.
% \end{proof}

\chapter{ Research - [title TBD]} 
\tnote{the matrix theory submitted in walcom, any other work - need to see notes.}


\chapter{Conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Appendices.

\appendix

\chapter{Appendix A}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography.
\begin{singlespace}
%\begin{thebibliography}{10}
\addcontentsline{toc}{section}{Bibliography}

{\footnotesize
  \bibliographystyle{alpha} 
  \bibliography{../lib/cop-variants__thesis}
}
%\end{thebibliography}
\end{singlespace}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% List of papers

\listofpapers

\begin{enumerate}  
\item Authors....  \newblock
 Title...
  \newblock {\em Journal}, Volume,
  Page, (year).
\end{enumerate}  

\end{document}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENTATION ON THE THESIS CLASS FILE ETC.


% Before reading any further please note that you are strongly advised
% against changing any of the formatting options used in the class
% provided in this directory, unless you are absolutely sure that it
% does not violate the IITM formatting guidelines.  \emph{Please do not
%   change the margins or the spacing.}  If you do change the formatting
% you are on your own (don't blame me if you need to reprint your entire
% thesis).  In the case that you do change the formatting despite these
% warnings, the least I ask is that you do not redistribute your style
% files to your friends (or enemies).

% It is also a good idea to take a quick look at the formatting
% guidelines.  Your office or advisor should have a copy.  If they
% don't, pester them, they really should have the formatting guidelines
% readily available somewhere.


% To generate PDF's with the links from the \verb+hyperref+ package use
% the following command:
% \begin{verbatim}
% % dvipdfm -o thesis.pdf thesis.dvi
% \end{verbatim}

% \section{Package Options}

% Use this thesis as a basic template to format your thesis.  The
% \verb+iitmdiss+ class can be used by simply using something like this:
% \begin{verbatim}
% \documentclass[PhD]{iitmdiss}  
% \end{verbatim}

% To change the title page for different degrees just change the option
% from \verb+PhD+ to one of \verb+MS+, \verb+MTech+ or \verb+BTech+.
% The dual degree pages are not supported yet but should be quite easy
% to add.  The title page formatting really depends on how large or
% small your thesis title is.  Consequently it might require some hand
% tuning.  Edit your version of \verb+iitmdiss.cls+ suitably to do this.
% I recommend that this be done once your title is final.

% To write a synopsis simply use the \verb+synopsis.tex+ file as a
% simple template.  The synopsis option turns this on and can be used as
% shown below.
% \begin{verbatim}
% \documentclass[PhD,synopsis]{iitmdiss}                                
% \end{verbatim}

% Once again the title page may require some small amount of fine
% tuning.  This is again easily done by editing the class file.

% This sample file uses the \verb+hyperref+ package that makes all
% labels and references clickable in both the generated DVI and PDF
% files.  These are very useful when reading the document online and do
% not affect the output when the files are printed.


% \section{Example Figures and tables}

% Fig.~\ref{fig:iitm} shows a simple figure for illustration along with
% a long caption.  The formatting of the caption text is automatically
% single spaced and indented.  Table~\ref{tab:sample} shows a sample
% table with the caption placed correctly.  The caption for this should
% always be placed before the table as shown in the example.


% \begin{figure}[htpb]
%   \begin{center}
%     \resizebox{50mm}{!} {\includegraphics *{iitm.eps}}
%     \resizebox{50mm}{!} {\includegraphics *{iitm.eps}}
%     \caption {Two IITM logos in a row.  This is also an
%       illustration of a very long figure caption that wraps around two
%       two lines.  Notice that the caption is single-spaced.}
%   \label{fig:iitm}
%   \end{center}
% \end{figure}

% \begin{table}[htbp]
%   \caption{A sample table with a table caption placed
%     appropriately. This caption is also very long and is
%     single-spaced.  Also notice how the text is aligned.}
%   \begin{center}
%   \begin{tabular}[c]{|c|r|} \hline
%     $x$ & $x^2$ \\ \hline
%     1  &  1   \\
%     2  &  4  \\
%     3  &  9  \\
%     4  &  16  \\
%     5  &  25  \\
%     6  &  36  \\
%     7  &  49  \\
%     8  &  64  \\ \hline
%   \end{tabular}
%   \label{tab:sample}
%   \end{center}
% \end{table}

% \section{Bibliography with BIB\TeX}

% I strongly recommend that you use BIB\TeX\ to automatically generate
% your bibliography.  It makes managing your references much easier.  It
% is an excellent way to organize your references and reuse them.  You
% can use one set of entries for your references and cite them in your
% thesis, papers and reports.  If you haven't used it anytime before
% please invest some time learning how to use it.  

% I've included a simple example BIB\TeX\ file along in this directory
% called \verb+refs.bib+.  The \verb+iitmdiss.cls+ class package which
% is used in this thesis and for the synopsis uses the \verb+natbib+
% package to format the references along with a customized bibliography
% style provided as the \verb+iitm.bst+ file in the directory containing
% \verb+thesis.tex+.  Documentation for the \verb+natbib+ package should
% be available in your distribution of \LaTeX.  Basically, to cite the
% author along with the author name and year use \verb+\cite{key}+ where
% \verb+key+ is the citation key for your bibliography entry.  You can
% also use \verb+\citet{key}+ to get the same effect.  To make the
% citation without the author name in the main text but inside the
% parenthesis use \verb+\citep{key}+.  The following paragraph shows how
% citations can be used in text effectively.

% More information on BIB\TeX\ is available in the book by
% \cite{lamport:86}.  There are many
% references~\citep{lamport:86,prabhu:xx} that explain how to use
% BIB\TeX.  Read the \verb+natbib+ package documentation for more
% details on how to cite things differently.

% Here are other references for example.  \citet{viz:mayavi} presents a
% Python based visualization system called MayaVi in a conference paper.
% \citet{pan:pr:flat-fst} illustrates a journal article with multiple
% authors.  Python~\citep{py:python} is a programming language and is
% cited here to show how to cite something that is best identified with
% a URL.

% \section{Other useful \LaTeX\ packages}

% The following packages might be useful when writing your thesis.

% \begin{itemize}  
% \item It is very useful to include line numbers in your document.
%   That way, it is very easy for people to suggest corrections to your
%   text.  I recommend the use of the \texttt{lineno} package for this
%   purpose.  This is not a standard package but can be obtained on the
%   internet.  The directory containing this file should contain a
%   lineno directory that includes the package along with documentation
%   for it.

% \item The \texttt{listings} package should be available with your
%   distribution of \LaTeX.  This package is very useful when one needs
%   to list source code or pseudo-code.

% \item For special figure captions the \texttt{ccaption} package may be
%   useful.  This is specially useful if one has a figure that spans
%   more than two pages and you need to use the same figure number.

% \item The notation page can be entered manually or automatically
%   generated using the \texttt{nomencl} package.

% \end{itemize}

% More details on how to use these specific packages are available along
% with the documentation of the respective packages.

% END OF DOCUMENTATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

