\definecolor{gray}{rgb}{0.8,0.8,0.8}
\def\tblhcolor {gray}


\chapter{\CoP\,-- A Survey of Important Results}
\label{ch:copsurvey}

This chapter surveys several results that are significant to this
thesis or to \COP in general. These predominantly pertain to
characterizations of \COP, algorithmic tests to check for \COP (COT),
optimization problems on binary matrices that do not have \COP and
some applications of \COP.

\tnote[important]{ADD: have a few lines about organization of chapter}



\section{\COP in Graph Theory}

\COP is closely connected to several types of graphs by way of
describing certain combinatorial graph properties. There are also
certain graphs, like convex bipartite graphs, that are defined solely
by some of its associated matrix having \COP.  In this section we will
see the relevance of \cop to graphs.  To see this we introduce certain
binary matrices that are used to define graphs in different
ways. While adjacency matrix is perhaps the most commonly used such
matrix, Definition~\ref{def:graphmatrices} defines this and a few
more.

\begin{definition}
  {\em Matrices that define graphs. \cite[Def.~2.4]{d08phd}.}  
  \label{def:graphmatrices} 
  Let $G$ and $H$ be defined as follows. $G = (V,E_G)$ is a graph with
  vertex set $V = \{v_i \mid i \in [n]\}$ and edge set $E_G \subseteq
  \{(v_i,v_j) \mid i, j \in [n]\}$ such that $|E_G| = m$. $H = (A, B,
  E_H)$ is a bipartite graph with partitions $A = \{a_i \mid i \in
  [n_a]\}$ and $B = \{b_i \mid i \in [n_b]\}$.
  \begin{enumerate}[{\ref{def:graphmatrices}}--i.]
  \item \emph{Adjacency matrix} of $G$ is the symmetric $n \times n$
    binary matrix $M$ with $m_{i,j} = \un$ \iff $(v_i,v_j) \in E_G$
    for all $i,j \in [n]$.
  \item \emph{Augmented adjacency matrix} of $G$ is obtained from its
    adjacency matrix by setting all main diagonal elements to \un, \ie
    $m_{i,i} = \un$ for all $i \in [n]$.
  \item \emph{Maximal clique matrix} or \emph{vertex-clique incidence
      matrix} of $G$ is the $n \times k$ binary matrix $M$ with
    $m_{i,j} = \un$ \iff $v_i \in C_j$ for all $i \in [n], j \in [k]$
    where $\{C_j \mid j \in [k]\}$ is the set of maximal cliques of
    $G$.
    \label{def::maxcliquematrix}
  \item \emph{Half adjacency matrix} of $H$ is the $n_a \times n_b$
    binary matrix $M$ with $m_{i,j} = \un$ \iff $(a_i, b_j) \in E_H$.
  \end{enumerate}
\end{definition}

\figgraphmatrices

Now we will see in Definition~\ref{def:graphwithcop} certain graph
classes that is related to \COP or \CROP.\\

\begin{definition}{\emph{Graphs that relate to
      COP.\cite[Def.~2.5]{d08phd}}} %
  \label{def:graphwithcop} %
  Let $G$ be a graph and $H$ be a bipartite graph.
  \begin{enumerate}[\ref{def:graphwithcop}--i.]
  \item $G$ is \emph{convex-round} if its adjacency matrix has the
    \CROP.
  \item \label{def::concave-round} $G$ is \emph{concave-round} if its
    augmented adjacency matrix has \CROP. \tnote{cite BHY00}
    \tnote[minor]{add CROP to glossary}
  \item $G$ is an \emph{interval graph} if its vertices can be mapped
    to intervals on the real line \stt two vertices are adjacent \iff
    their corresponding intervals overlap \tnote{cite Ben59, Haj57}.
    $G$ is an interval graph \iff its maximal clique matrix has COP
    \cite{fg65}\footnote{This follows \cite{gh64} which states that the
      maximal cliques of interval graph $G$ can be linearly ordered
      \stt for all $v \in V(G)$, cliques containing $v$ are
      consecutive in the ordering \cite[Th. 8.1]{mcg04}.}
    \begin{enumerate}[a.]
    \item $G$ is a \emph{unit interval graph} if it is an interval
      graph \stt all intervals have the same length.\footnotemark[2]
    \item $G$ is a \emph{proper interval graph} if it is an interval
      graph \stt no interval properly contains another.\footnote{The
        set of unit interval graphs and the set of proper interval
        graphs are the same} \tnote{cite {rob69,gar07} in footnote. pg
        33 dom}
    \end{enumerate}
 \item $G$ is a \emph{circular-arc graph} if its vertices can be
    mapped to a set of arcs on a circle \stt two vertices are adjacent
    \iff their corresponding arcs overlap.\tnote[pressing]{how is
      CO/ROP related?}
  \item $H$ is \emph{convex bipartite on columns (rows)} if its half
    adjacency matrix has \COP on rows (columns).%
    \label{def::convexbi}
  \item $H$ is \emph{biconvex bipartite} or \emph{doubly
      convex}\cite{yc95} if its half adjacency matrix has \COP on both
    rows and columns.
  \item $H$ is \emph{circular convex} if its half adjacency matrix has
    \CROP.
  \end{enumerate}
\end{definition}

Interval graphs\footnote{\cite{mcc04} cites that the problem of
  recognizing interval graphs has significance in molecular
  biology. Interestingly, in the late 1950s, before the structure of
  DNA was well-understood, Seymour Benzer was able to show that the
  intersection graph of a large number of fragments of genetic
  material was an interval graph \cite{sb59}. This was regarded as
  compelling evidence that genetic information was somehow arranged
  inside a structure that had a linear topology which we now know to
  be true from the discovery of linear structure of DNA.}and
circular-arc graphs have a long history in research.  The interest
around them is due to their very desirable property that several
problems that are NP-hard \tnote[minor]{all NPC problems are NPH yes?}
on general graphs, like finding a maximum clique or minimum coloring
or independent set, are polynomial time solvable in these graph
classes \cite{clrs01}.  In a similar fashion, a lot of problems that
are hard on general matrices have efficient solutions on matrices with
\COP or \CROP \cite[more citations pg.\,33]{d08phd}.

Table~\ref{tab:graphmatrices} summarises the way these graphs are
characterized by their matrices having \COP or \CROP.
Our focus in this chapter (and thesis) is mainly \COP and 
having seen how useful \COP is in identifying or characterizing many
types of graphs\footnote{\COP has several other applications
  \temptext{fill up.}}, we will now see results that study recognition of \COP
in matrices in the following section.

\temptext{ tab~\ref{tab:graphmatrices} -  have an abridged version
  of table 2.1 in dom. see notes for the possibility of a
  ``circle diagram''.} 
\begin{table}[htbp]
  \centering
% \includegraphics[scale=0.1]{../img/circlediagram_domtab2.1__2.png} %
 \caption{\figtabsize Graph matrices \temptext{PLACEHOLDER}}
  \label{tab:graphmatrices}
\end{table}






\section{Matrices with COP}
\label{sec:surveycoptest}

The most important questions with respect to a particular 
property desired in a structure/object are perhaps the following.
\begin{itemize}%[]
\singlespacing
\item Does the desired property exist in the given input?
\item If the test is affirmative, what is a certificate of the affirmative?
\item If the test is negative, what are the optimization possibilities
  for the property in the input? In other words, how close to having the
  property can the input be?
\item If the test is negative, what is a certificate of the negative?
\end{itemize}

In this section and the rest of the chapter we see results that shaped the
correponding areas respectively for \cop in binary matrices.

\begin{enumerate}[a.]
\singlespacing
\item \label{q:testcop} Does a given binary matrix have \COP?
\item \label{q:copperm} What is the \COP permutation for the given matrix with \COP?
\item \label{q:copopt} What are the optimizations possible and practically useful on
  the given matrix without \COP?
\item \label{q:nocopcert} If algorithm for (\ref{q:testcop}) returns
  \textbf{false}, can a certificate for this be computed?
\end{enumerate}

Without doubt, besides computing answers to these questions, we are
interested in the efficiency of these computations in terms of
computational complexity theory. Results towards
questions~(\ref{q:testcop}) and (\ref{q:copperm}) are surveyed in this
section. Those for question~(\ref{q:copopt}) are discussed in
Section~\ref{sec:surveycopopt} and question~(\ref{q:nocopcert}) is discussed
in Section~\ref{sec:surveycertalgo}.

It may be noted that one way to design an algorithm to test for \COP
is by deriving one from any interval graph recognition algorithm using the
result {\sc hmpv00}\tnote{cite hmpv00} \tnote{in footnote put the theorem 2.7 - dom
  pg 43} \cite{d08phd} which demonstrates how such a derivation can be
done. However, this does not necessarily yield an efficient
algorithm. We will see results that directly solve the problem on
matrices since it is known that questions~(\ref{q:testcop}) and
(\ref{q:copperm}) stated above for \COP are efficiently solvable.
Table~\ref{tab:cophistory} gives a snapshot of these results.

\tnote[important]{1899 by petrie -- cite
         kendall 69 pacific journal of mathematics 1969 }

\def\tabparboxw{10cm}
\begin{table}[htbp]
  \centering
  {
    \fontencoding{OT1}\fontfamily{cmss}\selectfont%
    \footnotesize%

    \begin{tabular}{lll}
      \hline
      \hline

      1899 & \parbox[t]{\tabparboxw}{ First mention of \COP
        (archaeology)} &                  \\

      \rowcolor[gray]{0.8} %
      1951 & \parbox[t]{\tabparboxw}{ Heuristics for COT} & \cite{wsr51} \\

      1965 & \parbox[t]{\tabparboxw}{ First polynomial time algorithm
        for \COP testing} & \cite{fg65} \\ 

      \rowcolor[gray]{0.8} %
      1972 & \parbox[t]{\tabparboxw}{ Characterization for \COP -- forbidden
        submatrices} &
      \cite{at72} \\

      1976 & \parbox[t]{\tabparboxw}{ First linear time algorithm for COT --
        \PQtree} &
      \cite{bl76} \\

      \rowcolor[gray]{0.8} %
      1992 & \parbox[t]{\tabparboxw}{ Linear
        time algorithm COT without \PQtree} & \cite{wlh02}%\footnote{First
      % published in \cite{wlh02isaac92}}
      \\

      2001 & \parbox[t]{\tabparboxw}{\PCtree\ -- a simplification of
        \PQtree} & \cite{wlh01,hm03} \\  

      \rowcolor[gray]{0.8} %     
      1996 & \parbox[t]{\tabparboxw}{\PQRtree\ -- generalization of
        \PQtree for any binary matrix regardless of its \COP status} &
      \cite{mm96} \\ 

      1998 & \parbox[t]{\tabparboxw}{ Almost linear time to construct
        \PQRtree} & \cite{mpt98} \\ 

      \rowcolor[gray]{0.8} %
      2004 & \parbox[t]{\tabparboxw}{ A certifying algorithm for no
        \COP.\\ Generalized \PQtree.} & \cite{mcc04} \\ 

      2009 & \parbox[t]{\tabparboxw}{ Set theoretic, cardinality based
        characterization of \COP\ -- ICPIA} & \cite{nsnrs09} \\ 

      \rowcolor[gray]{0.8} %
      2010 & \parbox[t]{\tabparboxw}{ Logspace \COP testing} &
      \cite{kklv10}\\ 
      \hline
      \hline
    \end{tabular}
  }
\caption[\figtabsize A brief history of \COP research]{\figtabsize A
  brief history of \COP research }
\label{tab:cophistory}
\end{table}


The first polynomial time algorithm for \COP testing was by
\cite{fg65} which uses overlapping properties of columns with \un
s. Their result has close relations to the characterization of
interval graphs by \cite{gh64}. A graph $G$ is an interval graph \iff
all its maximal cliques can be linearly ordered \stt for any vertex
$v$ in $G$, all the cliques that $v$ is incident on are consecutive in
this order. Clearly, this means that the maximal clique incidence
matrix\footnote{
  Definition~\ref{def:graphmatrices}~\ref{def::maxcliquematrix}} must
have \COP on rows.

A few years later, a deeply significant result based on very different
ideas in understanding \COP came from Tucker which gave a
combinatorial (negative) characterization of matrices with COP
\cite{at72}. This result influenced most of the \COP results that
followed in the literature including linear time
algorithms\tnote[pressing]{linear? did it? which ones?} for \COP
recognition.


\subsection{Tucker's forbidden submatrices for \COP}

% \change{While it is remarkable that the first polynomial time
%   algorithm for \COP testing came in }{The first polynomial time
%   algorithm for \COP testing came in }\cite{fg65} \change{,}{.}
% \change{it is safe to say that the most}{A few years later, a very}
% significant result in understanding \COP came \remove{a few years
%   later} from Tucker which gave a combinatorial (negative)
% characterization of matrices with COP \cite{at72}.

\cite{at72} discovered certain forbidden structures for convex
bipartite graphs\footnote{The terminology in \cite{at72} differs. It
  uses the term {\em graphs with $V_1$-consecutive arragement} instead
  of {\em convex bipartite graphs}.} and by definition of this graph
class, this translates to a set of forbidden submatrices for matrices
with \cop.  The following are the theorems from \cite{at72} that
acheived this characterization.


Theorem~\ref{th:tuckeratfree} states that convex bipartite graphs
cannot have {\em asteroidal triples}\footnote{If $G = (V,E)$ is a
  graph, a set of three vertices from $V$ form an {\em asteroidal
    triple} if between any two of them there exists a path in $G$ that
  does not contain any vertex from the closed neighborhood of the
  third vertex.} contained in the corresponding vertex
partition\footnote{The partition corresponds to columns (rows) if its
  half adjacency matrix has \COP columns (rows).}.
Theorem~\ref{th:tuckerforbidden} lists the structures in a
bipartite graph that force one of its vertex partitions to have
asteriodal triples -- in other words, it identifies the subgraphs that
prevent the graph from being convex bipartite.


\begin{theorem}
  (\cite[Th.~6]{at72}, \cite[Th.~2.3]{d08phd})\\
  A bipartite graph $G = (V_1, V_2, E)$ is convex bipartite on
  columns\footnote{Abridged to match terminology adopted in this
    document. See previous note.} \iff $V_1$ contains no asteroidal
  triple of $G$.
  \label{th:tuckeratfree}
\end{theorem}

\begin{theorem}
  (\cite[Th.~7]{at72}, \cite[Th.~2.4]{d08phd})\\
  In a bipartite graph $G = (V_1, V_2, E)$ the vertex set $V_1$
  contains no asteroidal triple \iff $G$ contains none of the graphs
  $G_{I_k}$, $G_{II_k}$, $G_{III_k}$ (with $k \ge 1$), $G_{IV}$,
  $G_{V}$ as shown in Figure~\ref{fig:forbiddensubgraphs} as subgraphs.
  \label{th:tuckerforbidden}
\end{theorem}


\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.35]{../img/tuckersforbiddensubgraphs.png}  
  \caption[\figtabsize Tucker's forbidden subgraphs]{\figtabsize Tucker's
    forbidden subgraphs for convex bipartite graphs. \temptext{ PLACEHOLDER
    IMG }} 
  \label{fig:forbiddensubgraphs}
\end{figure}

Theorem~\ref{th:tuckeratfree} and Theorem~\ref{th:tuckerforbidden}
result in the following Theorem~\ref{th:tuckercop} which characterizes
matrices with \COP.

\begin{theorem}
  (\cite[Th.~9]{at72}, \cite[Th.~2.5]{d08phd})\\
  A matrix $M$ has \COP \iff it contains none of the matrices 
$M_{I_k}$, $M_{II_k}$, $M_{III_k}$ (with $k \ge 1$), $M_{IV}$,
  $M_{V}$ as shown in Figure~\ref{fig:forbiddensubmatrices} as submatrices.
  \label{th:tuckercop}
\end{theorem}

\begin{figure}[htbp]
  \centering
%  \includegraphics[scale=0.35]{../img/tuckersforbiddensubmatrices.png}  
  \setlength\dashlinedash{1pt} %
  \setlength\dashlinegap{0pt}  %  Make non zero if cline can be done
                               %   with dashed lines.
  \singlespacing
  \begin{tabular}[h]{ll}
%   \small 
   \begin{tabular}[t]{|lll ll l|l} %                   MATRIX 1
      \multicolumn{7}{l}{\normalsize \hspace{-0.5in} $M_{I_k}, k \ge 1$}              \\   
      \multicolumn{6}{c}{\matrixbracetop{3.25}{$k+2$}}   \\
      \cline{1-6} % \firsthline %      Begin matrix  %%%%%%
      \un & \un & 0   & \multicolumn{2}{c}{\dots}  & 0    &
        \hspace{-0.1in}\multirow{5}{*}{\matrixbraceright{2.5}{$k+2$}}   \\    
      0   & \un & \un & 0 & ...& 0   \\
      \multicolumn{6}{|c|}{\dots}                        \\
      0   & \multicolumn{2}{c}{\dots}  & 0   & \un & \un \\
      \cline{1-6} % \hdashline %%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \un & 0   & \multicolumn{2}{c}{\dots}  & 0   & \un \\
      \cline{1-6} % \lasthline %      End matrix  %%%%%%%%%
    \end{tabular}
    &%
%    \small
    \begin{tabular}[t]{|lll ll ll|l} %                   MATRIX 2
      \multicolumn{8}{l}{\normalsize \hspace{-0.5in}$M_{II_k}, k \ge 1$}                   \\
      \multicolumn{7}{c}{\matrixbracetop{3.8}{$k+3$}}            \\ 
      \cline{1-7}%  \firsthline %      Begin matrix  %%%%%%%%%%%%
      \un & \un & 0   & \multicolumn{3}{c:}{\dots}       & 0    &
        \hspace{-0.1in}\multirow{6}{*}{\matrixbraceright{3}{$k+3$}}         \\
      0   & \un & \un & 0 & \multicolumn{2}{c:}{\dots}   & 0   \\ 
      \multicolumn{6}{|c:}{\dots}                        &     \\
      0   & \multicolumn{2}{c}{\dots}  & 0   & \un              &
        \multicolumn{1}{l:}{\un} & 0                           \\
      \cline{1-6}    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      0   & \un & \multicolumn{4}{c}{\dots}              & \un \\
      \un & \multicolumn{3}{c}{\dots}        & \un & 0   & \un \\
      \cline{1-7}% \lasthline %      End matrix  %%%%%%%%%%%%%%%%
    \end{tabular}
    \\\\%
%    \small
    \begin{tabular}[t]{|lll ll l l|l} %                  MATRIX 3 
      \multicolumn{8}{l}{\normalsize \hspace{-0.5in}$M_{III_k}, k \ge 1$}                  \\
      \multicolumn{7}{c}{\matrixbracetop{3.8}{$k+3$}}            \\
      \cline{1-7}%      \firsthline %      Begin matrix %%%%%%%%%
      \un & \un & 0   & \multicolumn{3}{c:}{\dots}       & 0    &
        \hspace{-0.1in}\multirow{5}{*}{\matrixbraceright{2.5}{$k+2$}}         \\
      0   & \un & \un & 0 & \multicolumn{2}{c:}{\dots}   & 0   \\ 
      \multicolumn{6}{|c:}{\dots}                        &     \\
      0   & \multicolumn{2}{c}{\dots}  & 0   & \un              &
        \multicolumn{1}{l:}{\un}                         & 0   \\
      \cline{1-6}    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      0   & \un & \multicolumn{2}{c}{\dots}  & \un & 0   & \un \\
      \cline{1-7}%      \lasthline %      End matrix %%%%%%%%%%%%
    \end{tabular}
    &%
%    \small
    \begin{tabular}[t]{|llllll|}  %                     MATRIX 4
      \multicolumn{6}{l}{\normalsize \hspace{-0.5in}$M_{IV}$} \\
      \multicolumn{6}{l}{} \\
      \firsthline
      \un & \un & 0 & 0 & 0 & 0   \\
      0 & 0 & \un & \un & 0 & 0   \\
      0 & 0 & 0 & 0 & \un & \un   \\
      \un & 0 & \un & 0 & \un & 0 \\
      \lasthline
    \end{tabular}
    \\\\%
%    \small
    \begin{tabular}[t]{|lllll|}  %                     MATRIX 5
      \multicolumn{5}{l}{\normalsize \hspace{-0.5in}$M_{V}$} \\
      \multicolumn{5}{l}{} \\
      \firsthline
      \un & \un & 0   & 0   & 0   \\
      0   & 0   & \un & \un & 0   \\
      \un & \un & \un & \un & 0   \\
      \un & 0   & \un & 0   & \un \\
      \lasthline
    \end{tabular}
  \end{tabular}

    



  \caption[\figtabsize Tucker's forbidden submatrices]{\figtabsize Tucker's
    forbidden submatrices for convex bipartite graphs. \cite{at72}} 
  \label{fig:forbiddensubmatrices}
\end{figure}
 












It can be verified that the matrices in
Figure~\ref{fig:forbiddensubmatrices} are the half adjacency matrices
of the graphs in Figure~\ref{fig:forbiddensubgraphs} respectively
which is not surprising due to
Definition~\ref{def:graphwithcop}~\ref{def::convexbi}.

\subsection{Booth and Lueker's $PQ$ tree -- a linear COT algorithm}

Booth and Lueker in their paper \cite{bl76} gave the first linear
algorithm\footnote{Time complexity is $O\left(m+n+f\right)$ where $m
  \times n$ is the order of the input matrix and $f$ is the number of
  $\un$s in it.} for \cop testing while given a linear time interval
graph recognition algorithm by a simplification of \tnote{cite -
  A. Lempel, S. Even and I. Cederbaum, An Algorithm for Planarity
  Testing of Graphs, Theory of Graphs, ed., P. Rosenstiehl, Gordon and
  Breach, New York, (1967), 215-232.  }'s planarity test algorithm.
% Hsu in wlh01 said BL76 gave a planarity test - "the induced PQ-tree
% algorithm can considerably simplify Booth and Lueker’s modification
% of Lempel, Even and Cederbaum’s planarity test. " 
%
% McConnell in hm03 said the first linear algo for interval graph
% recog was by BL76 - "Benzer’s work and other applications of
% interval graphs motivated a search for eﬃcient algorithms for
% recognizing interval graphs, and for constructing a set of intervals
% to represent the graph when it is one [8]. A linear-time algorithm
% was given in 1976 by Booth and Lueker [2]." 
\cite{bl76} introduces a data structure called \PQtree and their \COP
testing algorithm is a constructive one that outputs a \PQtree if the
input has \COP. A \PQtree represents all the \COP orderings of the
matrix it is associated with. \cite{bl76}'s algorithm uses the fact
that if a matrix has \COP, a \PQtree for it can be constructed. It is
interesting to note that aside from interval graph recognition and
\COP testing, \PQtree is also useful in other applications like
finding planar embeddings of planar graphs \cite{lec67,mcc04} and
recognizing \CROP in a matrix.

%\begin{minipage}[h]{5.5in}
\begin{definition}[\PQtree \cite{bl76, mcc04}]
  A \PQtree of matrix $M$ with \COP on columns (rows), is a tree with
  the following properties.
  \begin{enumerate}[i.]
    \singlespacing
  \item Each leaf uniquely represents a row (column) of $M$. The leaf
    order of the tree gives a \COP order for column (row)\footnote{Note
      that \COP order for column requires permutation of rows and vice
      versa.} for $M$.
  \item Every non-leaf node in the tree is labeled $P$ or $Q$.
  \item \label{def::nodep} The children of $P$ nodes are
    unordered. They can be permuted in any fashion to obtain a new
    \COP order for $M$.
  \item \label{def::nodeq} The children of $Q$ nodes are linearly
    ordered. Their order can be reversed to obtain a new \COP
    order for $M$.
  \end{enumerate}
  \label{def:pqtree}
\end{definition}
%\end{minipage}

See Figure~\ref{fig:pqtree} for an example of \PQtree. It may be noted
that there is no way an empty set of \COP orderings can be represented
in this data structure. For this reason, \PQtree is undefined for
matrices that do not have \COP.  Thus effectively, there exists a
bijection between set of matrices with \COP and the set of \PQtrees
(accurately speaking, each matrix with \COP bijectively maps to an
equivalence class of \PQtrees resulting from properties (\ref{def::nodep}) and
(\ref{def::nodeq})).


\figpqtree

The \cite{bl76} algorithm with input $n \times m$ matrix $M$ starts
with a \PQtree for a vacuous $n \times 0$ matrix $M'$ (submatrix
induced by 0 columns). This is known as a {\em universal} \PQtree
which is one with its root as a $P$ node and only leaves as its
children -- each leaf representative of a row of input (by definition
of \COP for columns). This induced submatrix $M'$ vacuously has \COP.
Each column is then added iteratively to $M'$ to check if the new $M'$
has \COP.  By a complicated, but linear, procedure the algorithm does
one of the following actions in each iteration: (a) declare that $M$
has no \COP, or (b) modify the current \PQtree to represent the new
$M'$ (which clearly, must have \COP, since if not, option (a) would
have been executed).


Judging from notes in literature, this algorithm is apparently
notoriously difficult to program. In the procedure to modify the
\PQtree at each iteration, nodes are considered from leaves to
tree. At each node considered, it uses one of nine templates to
determine how the tree must be altered in the vicinity of this
node. Recognition of this template poses a difficult challenge in
terms of implementing it. Each template is actually a representative
of a larger class of similar templates, which must be dealt with
explicitly by a program\cite{mcc04}.


After the invention of \PQtrees, presumably due to the implementation
challenge it posed, there has been several variants of the same in the
literature, like \PCtree \cite{sh99,wlh01,hm03}, generalized \PQtree
\cite{km89,mcc04}, \PQRtree \cite{mm96,mpt98} etc. Most of these are
generalizations of \PQtree -- for instance, \PCtree is generalized to
matrices with \CROP, \PQRtree and generalized \PQtree are generalized
to matrices and set systems with or without \COP. \cite{km89} invented
a modified form of \PQtree a simpler incremental update of the tree
only for recognizing interval graphs.  \cite{kr88} constructed
efficient parallel algorithms for manipulating PQ trees. \temptext{dom
  chapter 2 pg 40 Variations of PQTrees first para - summarize.}

In the next few following sections we will see some of these
variations.
%Their algorithm was improved by \cite{tm05}
%\tnote{improved in terms of what?}. 
% describes an improved algorithm to
% build PQR trees.




\subsection{\PQRtree\ --  COP for set systems}
\label{sec:surveycertalgo}

Section~\ref{sec:motive} mentions how a binary matrix naturally maps
to a system of sets.  A set can be constructed for each column of
matrix with its elements being those row indices at which the column
has \un s. Thus the collection of sets corresponding each column of
the matrix forms a set system with universe as the set of all row
indices of the matrix.  This simple construction is formally described
in Definition~\ref{def:matrixsetsystem} along with the idea of \cop
for set systems\footnote{As seen in Section~\ref{sec:courseschedule}}.

\begin{definition}[{\em \Cop for set systems}]%
  \label{def:matrixsetsystem}%
  % [\emph{Set system of a binary matrix}.]
  Let $M$ be a binary matrix of order $n \times m$ and $\{c_i \mid i
  \in [m]\}$ be the columns in $M$.  A set system $\cF_{M} = \{S_i
  \mid S_i \subseteq [n], i \in [m]\}$ is defined such that for every
  column $c_i$ of $M$, set $S_i = \{j \mid m_{ji} = \un \}$. The
  collection $\cF_M$ is the {\em set system of binary matrix} $M$. The
  {\em binary matrix for set system} $\cF$ is conversely constructed
  and denoted by $M^\cF$. Thus, $M^{\cF_M} = M$.
  
  A set system $\cF$ from universe $U$, $|U| = n$ has the
  {\em \cop} if there exists a linear order or 
  permutation $\sigma = w_1w_2\ldots w_n$ that can be applied to $U$ \stt each set $S \in
  \cF$ becomes a consecutive subsequence\footnote{Also termed an {\em interval}} $w_{i}w_{i+1}\ldots
  w_{i+k-1}$ on $\sigma$ for some positive integer $i \le n+1-k$ where  $k = |S|$.

  The set $\valid{U,\cF}$ respresents all \COP orders of $\cF$ in $U$.
  \defnstop
\end{definition}

It is easy to see the equivalence of this definition to \COP for
matrices in Definition~\ref{def:copmatrix}.

Before proceeding to describe \PQRtree per se, we will see a few more
terminologies that will make the subsequent discussion in this section
simpler.

\begin{definition}[\em Orthogonal sets \cite{n89, mm96,
    mcc04}\footnote{\cite{mcc04} does not use the term ``mutually
    orthogonal'' but refers to the same idea as ``sets that do not
    overlap''. This terminology is also used in other literature like
    \cite{nsnrs09,wlh02}.} ]
  \label{def:orthosets}%
  Let $\cF$ be a set system with universe $U$ and sets $A, B \in \cF$.
  \begin{enumerate}
  \item $A$ and $B$ are said to have a {\em trivial intersection} if
    $A \cap B$ is one of the following.
    \begin{enumerate}[i.]
    \singlespacing
    \item $\emptyset$
    \item $A$
    \item $B$\footnote{In other words, $A$ and $B$ are either disjoint
        or one is the subset of the other.}
    \end{enumerate}
    % \vspace{-5mm}%

  \item $A$ and $B$ are called {\em mutually orthogonal} or $A$ is {\em
      orthogonal to} $B$ and vice versa, if they have a trivial
    intersection.

  \item {\em Trivial subsets} of a universe $U$, denoted by $\cT(U)$,
    are sets that have trivial intersections with any set in
    $\power{U}$. These sets are $U$, singleton sets in
    $\power{U}$ and $\emptyset$ \cite{n89, mm96}.
    Thus, $\cT(U) = \{U\} \  \bigcup \  \{ \{v\} \mid v \in U \} \  \bigcup \
    \{\emptyset\}$.

  \item {\em Orthogonal sets of a set system} $\cF$ with universe $U$
    are subsets of $U$ that are orthogonal to all sets in $\cF$. The
    set of all orthogonal sets to $\cF$ is denoted by
    $\cF^{\bot}$\footnote{\cite[Def.~3.1]{mcc04} uses the term {\em non-overlapping
    family} of $\cF$ and denotes it by $\cN(\cF)$. \label{mcc1}}.

  \item $\cF$ is called {\em complete}\footnote{\cite{mcc04} calls
      this a {\em weakly partative family}. \label{mcc2}} if the following hold
    true for every pair of non-orthogonal\footnote{Or overlapping.} sets
    $A, B$ in $\cF$.
    \begin{enumerate}[i.]
    \item $\cT(U) \subset \cF$
    \item $A \cup B \in \cF$
    \item $A \cap B \in \cF$
    \item $A \setminus B \in \cF$
    \item $B \setminus A \in \cF$
    \end{enumerate}
    In other words, $\cF$ contains all the trivial
    subsets of $U$, $A \cup B$ and the partitions of $A \cup B$
    defined by intersection and set difference.

  \item $\overline{\cF}$ represents the smallest super set system of
    $\cF$ that is complete\footnote{\cite[Def.~3.2]{mcc04} calls
      this the {\em weak closure} of $\cF$ denoted by $\cW(\cF)$. \label{mcc3}}

  \end{enumerate}
  \defnstop
\end{definition}

Generalized \PQtree or \gPQtree is a data structure defined in
\cite{n89} to represent all orthogonal sets of a set system $\cF$. A
data structure with the same name was later defined in \cite{mcc04} as
part of a {\em substitution decomposition} for a set system $\cF$
\tnote{define substitutio decomp.} and subsequently \cite{mcc04} gives
a new characterization of $\cF$ using a so-called incompatibility
graph. \PQRtree is defined in \cite{mm96} as a data
structure to represent any set system $\cF$ with additional
information in their $R$-nodes if $\cF$ has no \COP.  All three of
these data structures are proposed as generalizations of \cite{bl76}'s
\PQtree and hence produce the \PQtree if $\cF$ has \COP. As a whole,
all these three data strutures are largely identical with their
differences being notional.  In this section, we will discuss the
basic theory that they all hold. We will predominantly use the
terminology from \cite{mm96} and refer to the data structure as
\PQRtree.

An important observation made by \cite{mm96} is presented now along
with a few theorems that help in decomposing the \COP problem on $\cF$
into subproblems.

\begin{observation}[{\cite[Sec.~3]{mm96}}]
  If $\cF$ is a set system with \COP then, after applying the \COP
  order, not only must every set in $\cF$ be consecutive but the
  following sets must also be consecutive for any $A, B \in \cF$.
\begin{enumerate}
  \item The intersection $A \cap B$ 
  \item The union $A \cup B$ if $A \cap B \ne \emptyset$
  \item The relative complements $A \setminus B$ and $B \setminus A$
    if $B \nsubseteq A$ and $A \nsubseteq B$ respectively.
  \item Also note that trivially, sets in $\cT(U)$ are consecutive in
    any permutation of $U$\footnote{$\emptyset$ is considered
      consecutive by convention.}.
\end{enumerate}
\end{observation}


\begin{theorem}[{\cite[Th.~3,6]{mm96}}]
  \label{th:validcop}
  For any set system $\cF$ we have the following. \par
  \centering
    $\valid{\cF} = \valid{\overline{\cF}}$ \\
    $\cF^{\bot} = \overline{\cF^{\bot}} = (\overline{\cF})^{\bot}$
\end{theorem}

\begin{proposition}
  \label{pr:validcop}
  Any set that is consecutive on all the \COP permutations of $\cF$ is
  present in $\overline{\cF}$.
\end{proposition}

Proposition~\ref{pr:validcop} is owing to the following theorem by
which \cite{mm96} describes a way to decompose the problem of finding
all \COP orders of $\cF$ into two subproblems using sets in
$\overline{\cF} \cap \cF^{\bot}$.

\begin{theorem}[{\cite[Th.~7]{mm96}}]
  \label{th:mmdecomp}
  For any set system $\cF$, and $\emptyset \ne H \in \overline{\cF}
  \cap \cF^{\bot}$ we have the following.\par
  \centering
  $\valid{U,\cF} = \valid{U/H,\cF/H} * \valid{H,\cF \cap 2^H}$
\end{theorem}

\def \ff {\overline{\cF} \cap \cF^{\bot}}

The idea behind Theorem~\ref{th:mmdecomp} is as follows. A permutation $\alpha$
of $U$ is a composition of two permutations with respect to $H$ - i) a
permutation $\gamma$ of $H$ and (ii) a permutation $\beta$ of $U/H$.

For two mutually orthogonal sets $A, B$ such that $A \nsubseteq B$,
$A/B$ is defined as the set obtained by removing all elements of $B$
from $A$ and adding a representative element for $B$ in $A$. Being orthogonal,
results in only the following three possibilities.
\begin{enumerate}
\item $A$ and $ B$ are disjoint: $A/B  = A$
\item $A$ is a subset of $B$: $A/B$ is not defined
\item $B$ is a subset of $A$: $A/B = A \setminus B \cup \{b\}$, where $b$
is a new element not in $U$ added to represent $B$.
\end{enumerate}

We observe that this idea of decomposing the \COP problem into two
subproblems in \cite{mm96} is very similar to the substitution
decomposition of a set system given in \cite{mcc04}.\footnote{Using
  the theory cited in footnotes~\ref{mcc1},\ref{mcc2},\ref{mcc3}.}

The following corollary states how \PQRtree elegantly fits into this
whole theory and help in computing all \COP orders of $\cF$.

\begin{corollary}[{\cite[Cor.~8]{mm96}}]
  Let $\cF$ be a set system with universe $U$ and $H$ is a non-empty
  orthogonal set $H \in
  \ff$. If there is a \PQRtree $T_1$ that encodes all permutations in
  $\valid{U/H, \cF/H}$ and also a \PQRtree $T_2'$ that encodes all
  permutations $\valid{H,\cF \cap \power{H}}$, then a \PQRtree $T$ for
  $\cF$ can be obtained by replacing the leaf $h$ in $T_1$ by $T_2$.
\end{corollary}

%Finding elements in $\ff$ is done using \PQRtree.

Thus we have a recursive algorithm that can compute the \PQRtree for
$\cF$ provided we find an element from $\ff$ in each iteration. The
non-empty sets in $\ff$ are called {\em node sets} since they form the
nodes in the \PQRtree. They are calculated as follows.  One is by
computing the overlap components of $\cF$. The overlap components is
the partition that results from the {overlap} equivalence relation
which is nothing but non-orthogonal equivalence relation\footnote{It
  is easy to verify that this relation is indeed an equivalence
  relation.}. Overlap components are linearly
computable\cite{mm95,wlh92}. Once these elements are factored
out, the rest of the node sets are obtained by identifying {\em twin}
elements\footnote{\cite[Sec.~3]{kklv10} calls this {indistinguishable}
  elements. The equivalence class is called a {\em slot}.}. Two
elements $a, b \in U$ are twins if their membership in every set of
$\cF$ is in tandem with each other, \ie $\{a,b\} \bot \cF$. This is
clearly an equivalence relation and their equivalence classes is known
to be computable in linear time\cite{wlh01,mm96-ref11} and even in
logspace\cite{kklv10}.

The recursion end condition is when one cannot find any more sets from
$\ff$ that are non-trivial. This is when $\ff = \cT(U)$. This is the
point where the parents of the leaves of the \PQRtree are created. The
following theorem helps the algorithm decide whether a $P$, $Q$ or
$R$ node must be created.

\begin{theorem}[{\cite[Th.~9]{mm96},\cite[Th.~2.1]{mcc04}}]
\label{th:pqrfinalmm}
If $\cF$ is a set system with universe $U$ and $|U| \ge 3$ then one of
the following statements hold.
\begin{enumerate}
\item \label{th::it1} $\overline{\cF} = \cT(U)$ 
\item \label{th::it2}$\overline{\cF} = consec(\alpha)$\tnote{what is consec?} for
  some permutation $\alpha$ on $U$ 
\item \label{th::it3}$\overline{\cF} = \power{U}$ 
\end{enumerate}
\end{theorem}

In case (\ref{th::it1}) all elements in $U$ are made children of a
$P$ node. In case (\ref{th::it2}) all elements in $U$ are made
children of a $Q$ node in the order given by $\alpha$. Finally case
(\ref{th::it3}) is the one when no permutation of $U$ gives \COP. All
elements of $U$ are in this case made children in an $R$ node. 

Theorem~\ref{th:pqrfinalmm} and the theory leading to it is very
similar to \cite[Th.~2.1, 3.5. Also Th.~3.2, 3.3, 3.4]{mcc04} which categorizes
the nodes in the above the three cases as {\em prime}, {\em linear}
and {\em degenerate} respectively. Their generalized \PQtree is
created in similar ways as \PQRtree above. This tree is in essense the
Hasse diagram of what they call {\em strong elements} of
$\overline{\cF}$. Strong elements of a set family are elements that do
not overlap with any other elements in the family, \ie it is
orthogonal to all other sets\cite[Def.~3.3]{mcc04}.


\begin{theorem}[{\cite{mm96}, \cite[Th.~3.6]{mcc04}}]
The set system $\cF$ has \COP \iff its \PQRtree has no $R$ nodes.  
\end{theorem}




% The generalized \PQtree of $\cF$ is defined as the {\em decomposition
%   tree} of its weak closure $\cW(\cF)$. Decomposition tree is the
% inclusion tree (inclusion p.o. Hasse diagram) of the strong elements
% of $\cW(\cF)$ with labels {\em prime, linear} and {\em degenerate}.\cite{mcc04}



% Overlap components are computable in linear time \cite{mm95,wlh92}.

----- Cert algo

------ ICPIA 








\temptext{ Certifying algorithm (Generalized PQ trees) [McC04] -- 

Set theoretic characterizations [Hsu02, NS09]\\
    \cite{wlh02} describes the simpler algorithm for
    COT.\tnote[pressing]{in terms of what?}\\
    \cite{nsnrs09} describes a characterization of consecutive-ones
    property solely based on the cardinality properties of the set
    representations of the columns (rows); every column (row) is
    equivalent to a set that has the row (column) indices of the rows
    (columns) that have one entries in this column (row). This is
    interesting and relevant, especially to this thesis because it
    simplifies COT to a great degree by reducing the solution search
    space owing to the a simple set theoretic characterization.\\


\cite{mcc04} describes a different approach to COT. While all previous
COT algorithms gave the COP order if the matrix has the property but
exited stating negative if otherwise, this algorithm gives an evidence
by way of a certificate of matrix even when it has no COP. This
enables a user to verify the algorithm's result even when the answer
is negative. This is significant from an implementation perspective
because automated program verification is hard and manual verification
is more viable. Hence having a certificate reinforces an
implementation's credibility. Note that when the matrix {\em has} COP,
the COP order is the certificate.  The internal machinery of this
algorithm is related to the weighted betweenness problem
addressed\tnote{in what way??} in \cite{co98}.  \tnote{expand
  on the COP order graph creation and it having to be bipartite for M
  to have COP. and thus an odd cycle being an evidence of no COP.}

}



    
\subsection{\PCtree -- a generalization of \PQtree}

\PCtree is a generalization of \PQtree. It is a data structure that is
analogous to \PQtree but for matrices with \crop. \PCtree was
introduced by \cite{sh99} for the purpose of planarity testing where
this data structure represents partial embeddings of planar
graphs. % noted from wlh01 abstract.
In \cite{wlh01}, Hsu reintroduces \PCtree as a generalization of
\PQtree and shows how it simplifies \cite{bl76}'s planarity test by
making the \PQtree construction much less complicated. Later
\cite{hm03}, discovers that \PCtree is a representation of all \crop
orders of a matrix when it is unrooted. \PCtree presented in
\cite{wlh01} is rooted; however the construction of \PCtree is the
same in both results. The property of being unrooted is necessary in
order to use \PCtree as a data structure for encoding circular
ordering. Definition~\ref{def:pctree} defines \PCtree.

\begin{definition}
  \label{def:pctree}
  [\emph{\PCtree} \cite{wlh01,d08phd}.]  A \PCtree of matrix $M$ with
  \CROP on columns (rows), is a tree with the following properties.
  \begin{enumerate}[i.]
    \singlespacing
  \item Is unrooted -- thus it has (a) no parent child relationship
    between nodes (b) there is no left to right (or vice versa)
    ordering.
  \item Each leaf uniquely represents a row (column) of $M$. The leaf
    order of the tree gives a \CROP order for column (row) for
    $M$. Moreover, any sequence obtained by considering the leaves in
    clockwise or counter-clockwise order describes a \CROP order for
    $M$.
  \item Every non-leaf node in the tree is labeled $P$ or $C$.
  \item The neighbors of $P$ nodes can be permuted in any fashion to
    obtain a new \CROP order for $M$.
  \item \label{def::pcmirror} The tree can be changed by applying the following
    ``mirroring'' operation to obtain a new \CROP order for $M$. Root
    the \PCtree at a neighbor of a $C$-node, $v$ and mirror the
    subtree whose root is $v$ and finally unrooting the
    tree. Mirroring a subtree is done by putting the children of every
    node of the subtree in reverse order.
  \end{enumerate}
\end{definition}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{../img/pctree_hm03.png}

  \centering
  \includegraphics[scale=0.4]{../img/pctree_dom.png}
  \caption{\figtabsize \PCtree \temptext{ PLACEHOLDER 
IMGS \cite{hm03, d08phd}}}
  \label{fig:pctree}
\end{figure}

As a data structure when \PCtree is compared with \PQtree, the
differences are, (i) it is unrooted, (ii) it represents all \CROP order of a
matrix (iii) it has $C$ nodes instead of $Q$ nodes which can be
``mirrored'' (operation defined in Definition~\ref{def:pctree}~\ref{def::pcmirror}).
The algorithms of construction of \PQtree in \cite{bl76} and that of
\PCtree in \cite{wlh01, hm03} starkly differ since the latter is a
much simplified procedure.



% WLH01 abstract:
% [..] The original implementation of the PQ-tree algorithms by Booth and
% Lueker using nine templates in each bottom-up iteration is rather
% complicated. Also the complexity analysis is rather intricate. We give
% a very simple linear time PC-tree algorithm with the following
% advantages: (1) it does not use any template; (2) at each iteration,
% it does all necessary tree-modification operations in one batch and
% does not involve the node-by-node bottom-up matching; (3) it can be
% used naturally to test the circular ones property in matrices; (4) the
% induced PQ-tree algorithm can considerably simplify Booth and Lueker’s
% modification of Lempel, Even and Cederbaum’s planarity test.

% \tnote[FYI]{ The results in cite~{bl76} on COT are based on the
%    result that interval graphs are AT-free chordal graphs cite~{lb62}?
%  No they don't seem related. this is the stupid bl lb confusion.}%


\section{Optimization problems in COP}
\label{sec:surveycopopt}
\tnote{Expand on ref:sec:optcop}

\temptext{ So far we have been concerned about matrices that have the
  consecutive ones property. However in real life applications, it is
  rare that data sets represented by binary matrices have COP,
  primarily due to the noisy nature of data available. At the same
  time, COP is not arbitrary and is a desirable property in practical
  data representation \cite{co98,jkckv04,k77}. In this context, there
  are several interesting problems when a matrix does not have COP but
  is ``close'' to having COP or is allowed to be altered to have
  COP. These are the optimization problems related to a matrix which
  does not have COP. Some of the significant problems are surveyed in
  this section.

\tnote{ -- sect 4.1 in cite:d08phd has many results surveyed. hardness
  results, approx. results. results are usually for a class of
  matrices $(a,b)$ where number {\un}s in columns and rows are
  restriced to $a$ and $b$ . -- problem of flipping at most $k$
  entries of $M$ to make it attain COP. this is NP complete
  cite:b75-phd}%
\tnote{(1) scite:lb62 showed that interval graphs are chordal and
  AT-free.} %
\temptext{couple of lines refering to tucker's submatrices. refer
  earlier section.}

Once a matrix has been detected to not have COP (using any of the COT
algorithms mentioned earlier), it is naturally of interest 

\begin{enumerate}
\item  to find out
the smallest forbidden substructure (in terms of number of rows and/or
columns and/or number of entries that are {\un}s). \cite{d08phd}
discusses a couple of algorithms which are efficient if the number of
{\un}s in a row is small. This is of significance in the case of
sparse matrices where this number is much lesser than the number of
columns. 

\item $(*,\Delta)${\em -matrices} are matrices with no restriction
on number of {\un}s in any column but has at most $\Delta$ {\un}s in
any row. 
{\sc Min COS-R (Min COS-C), Max COS-R (Max COS-C)} are
similar problems which deals with {\em inducing COP} on a matrix.

\begin{enumerate}
\item In the dual problem {\sc Max COS-R (Max COS-C)} the search is for the
maximum number of rows (columns) that induces a submatrix with
COP.
\item In {\sc
  Min COS-R (Min COS-C)} the question is to find the minimum number of
rows (columns) that must be deleted to result in a matrix with COP.
\end{enumerate}

Given a matrix $M$ with no COP, \cite{b75-phd} shows that finding
a submatrix $M'$ with all columns\tnote{check if b75 deals with
  COP col or COP row. also is it any submatrix with k less than r rows
  or submatrix must have all columns?} but a maximum cardinality
subset of rows such that $M'$ has COP is NP complete. \cite{hg02}
corrects an error of the abridged proof of this reduction as given in
\cite{gj79}.  \cite{d08phd} discusses all these problems in detail
giving an extensive survey of the previously existing results which
are almost exhaustively all approximation results and hardness
results. Taking this further, \cite{d08phd} presents new results in
the area of parameterized algorithms for this
problem\tnote{elaborate - what are the results?}.

\item Another problem is to find the minimum number of entries in the matrix
that can be toggled to result in a matrix with COP.  \cite{v85}
discusses approximation of {\sc COP Augmentation} which is the problem
of changing of the minimum number of zero entries to {\un}s so that
the resulting matrix has COP. As mentioned earlier, this problem is
known to be NP complete due to \cite{b75-phd}. \cite{v85} also proves,
using a reduction to the longest path problem, \tnote{or is it a
  survey of another result?  check.} that finding a Tucker's forbidden
submatrix of at least $k$ rows is NP complete. \tnote{how is this
  different from booth's 75 result??}  \tnote{where should this go?
  cite|tz04 (approx submatrix with COP sparse matrices)}

\item \cite{jkckv04} discusses the use of matrices with almost-COP (instead
of one block of consecutive {\un}s, they have $x$ blocks, or {\em
  runs}, of consecutive {\un}s and $x$ is not too large) in the
storage of very large databases.  The problem is that of reordering of
a binary matrix such that the resulting matrix has at most $k$ runs of
{\un}s. This is proved to be NP hard using a reduction from the
Hamiltonian path problem.\tnote{Theorem 2.1 in jkckv} \tnote{(1) A
  connection of COP problem to the travelling salesman problem is also
  introduced. what does this mean? -- COP can be used as a tool to
  reorder $0.5T \le runs(M) \le T$. (2) The optimization version of
  the $k$-run problem, i.e. minimization of number of blocks of ones
  is proven to be NP complete by cite:k77}\tnote{are these two the
  same?} \tnote{what is the reduction?} \tnote{other problems similar
  to COP -- cite:ckl96 (ILP, circ ones, one drop) -- cite:th98
  (generalization of COP - minimax, biotonic column) Tucker} 

\end{enumerate}

}


\section{COP in Graph Isomorphism}
\label{sec:surveygraphiso}
\tnote{Expand on sec:appgraphiso} \tnote{(canonization theme)}

\tnote[pressing]{ADD: peo exists iff chordal. lexicographic BFS
  [tag:chordalGraph]} %

\temptext{
The survey from kklv10 conclusion.
}

















% \section{Other applications}
% {\tt If any. \tnote{ where should this go?}: (1) cite|jlm97 (application of PQ
%   trees in graphics). (2) helly's theorem citation
%   19XXdgk-Hellystheorem-Danzer-Gruenbaum-Klee}}




%\theendnotes\tnote{remove if none.} 




%%%%%%%%%%%%% listing package for pretty formatting BEGIN
% \lstloadlanguages{C}
% \lstset{language=C, commentstyle=\scriptsize,
%   numberstyle=\tiny, numbers=left,               % Line numbers
%   stepnumber=2,numbersep=5pt,firstnumber=10, 
%   showstringspaces=false,                    % No explicit spaces
%   emph={printf},emphstyle=\underbar,      % Specific formatting
%   emph=[2]{sum},emphstyle=[2]\color{blue},      % Sp format (multiple)
%   emph=[3]{i},emphstyle=[3]\color{red}      % Sp format (multiple)
%   } 

%   \begin{singlespacing}
%     % Text inside "lstlisting" env is verbatim.
%     \begin{lstlisting}[keywordstyle=\textbf]      
% int sum;
% int i; /* for loop variable */ 
% sum = 0; 
% for (i=0, i<n; i++) { 
%   sum += a[i]; 
% } 
% printf{"This is stupid."}
%     \end{lstlisting}
%   \end{singlespacing}

%%%%%%%%%%%%% listing package for pretty formatting END

