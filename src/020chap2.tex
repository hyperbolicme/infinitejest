\definecolor{gray}{rgb}{0.8,0.8,0.8}
\def\tblhcolor {gray}


\chapter{\CoP\,-- A Survey of Important Results}
\label{ch:copsurvey}

This chapter surveys several results that are significant to this
thesis or to \COP in general. These predominantly pertain to
characterizations of \COP, algorithmic tests to check for \COP (COT),
optimization problems on binary matrices that do not have \COP and
some applications of \COP.

\tnote[important]{ADD: have a few lines about organization of chapter}

\section{\COP in Graph Theory}

\COP is closely connected to several types of graphs by way of
describing certain combinatorial graph properties. There are also
certain graphs, like convex bipartite graphs, that are defined solely
by some of its associated matrix having \COP.  In this section we will
see the relevance of \cop to graphs.  To see this we introduce certain
binary matrices that are used to define graphs in different
ways. While adjacency matrix is perhaps the most commonly used such
matrix, Definition~\ref{def:graphmatrices} defines this and a few
more.



% \begin{definition}{\emph{Matrices that define
%       graphs.\cite[Def.~2.4]{d08phd}}} %
\begin{definition}
  {\em Matrices that define graphs. \cite[Def.~2.4]{d08phd}.}  
  \label{def:graphmatrices} 
  Let $G$ and $H$ be defined as follows. $G = (V,E_G)$ is a graph with
  vertex set $V = \{v_i \mid i \in [n]\}$ and edge set $E_G \subseteq
  \{(v_i,v_j) \mid i, j \in [n]\}$ such that $|E_G| = m$. $H = (A, B,
  E_H)$ is a bipartite graph with partitions $A = \{a_i \mid i \in
  [n_a]\}$ and $B = \{b_i \mid i \in [n_b]\}$.
  \begin{enumerate}[{\ref{def:graphmatrices}}--i.]
  \item \emph{Adjacency matrix} of $G$ is the symmetric $n \times n$
    binary matrix $M$ with $m_{i,j} = \un$ \iff $(v_i,v_j) \in E_G$
    for all $i,j \in [n]$.
  \item \emph{Augmented adjacency matrix} of $G$ is obtained from its
    adjacency matrix by setting all main diagonal elements to \un, \ie
    $m_{i,i} = \un$ for all $i \in [n]$.
  \item \emph{Maximal clique matrix} or \emph{vertex-clique incidence
      matrix} of $G$ is the $n \times k$ binary matrix $M$ with
    $m_{i,j} = \un$ \iff $v_i \in C_j$ for all $i \in [n], j \in [k]$
    where $\{C_j \mid j \in [k]\}$ is the set of maximal cliques of
    $G$.
    \label{def::maxcliquematrix}
  \item \emph{Half adjacency matrix} of $H$ is the $n_a \times n_b$
    binary matrix $M$ with $m_{i,j} = \un$ \iff $(a_i, b_j) \in E_H$.
  \end{enumerate}
\end{definition}

\figgraphmatrices

Now we will see in Definition~\ref{def:graphwithcop} certain graph
classes that is related to \COP or \CROP.\\

\begin{definition}{\emph{Graphs that relate to
      COP.\cite[Def.~2.5]{d08phd}}} %
  \label{def:graphwithcop} %
  Let $G$ be a graph and $H$ be a bipartite graph.
  \begin{enumerate}[\ref{def:graphwithcop}--i.]
  \item $G$ is \emph{convex-round} if its adjacency matrix has the
    \CROP.
  \item \label{def::concave-round} $G$ is \emph{concave-round} if its
    augmented adjacency matrix has \CROP. \tnote{cite BHY00}
    \tnote[minor]{add CROP to glossary}
  \item $G$ is an \emph{interval graph} if its vertices can be mapped
    to intervals on the real line \stt two vertices are adjacent \iff
    their corresponding intervals overlap \tnote{cite Ben59, Haj57}.
    $G$ is an interval graph \iff its maximal clique matrix has COP
    \cite{fg65}\endnote{This follows \cite{gh64} which states that the
      maximal cliques of interval graph $G$ can be linearly ordered
      \stt for all $v \in V(G)$, cliques containing $v$ are
      consecutive in the ordering \cite[Th. 8.1]{mcg04}.}
    \begin{enumerate}[a.]
    \item $G$ is a \emph{unit interval graph} if it is an interval
      graph \stt all intervals have the same length.\endnotemark[2]
    \item $G$ is a \emph{proper interval graph} if it is an interval
      graph \stt no interval properly contains another.\endnote{The
        set of unit interval graphs and the set of proper interval
        graphs are the same} \tnote{cite {rob69,gar07} in endnote. pg
        33 dom}
    \end{enumerate}
 \item $G$ is a \emph{circular-arc graph} if its vertices can be
    mapped to a set of arcs on a circle \stt two vertices are adjacent
    \iff their corresponding arcs overlap.\tnote[pressing]{how is
      CO/ROP related?}
  \item $H$ is \emph{convex bipartite on columns (rows)} if its half
    adjacency matrix has \COP on rows (columns).%
    \label{def::convexbi}
  \item $H$ is \emph{biconvex bipartite} or \emph{doubly
      convex}\cite{yc95} if its half adjacency matrix has \COP on both
    rows and columns.
  \item $H$ is \emph{circular convex} if its half adjacency matrix has
    \CROP.
  \end{enumerate}
\end{definition}

Interval graphs\endnote { \cite{mcc04} cites that the problem of
  recognizing interval graphs has significance in molecular
  biology. Interestingly, in the late 1950s, before the structure of
  DNA was well-understood, Seymour Benzer was able to show that the
  intersection graph of a large number of fragments of genetic
  material was an interval graph \cite{sb59}. This was regarded as
  compelling evidence that genetic information was somehow arranged
  inside a structure that had a linear topology which we now know to
  be true\tnote{linear arrangement of DNA/genes?}.} and circular-arc
graphs have a long history in research.  The interest around them is
due to their very desirable property that several problems that are
NP-hard \tnote[minor]{all NPC problems are NPH yes?} on general
graphs, like finding a maximum clique or minimum coloring or
independent set, are polynomial time solvable in these graph classes
\cite{clrs01}.
In a similar fashion, a lot of problems that are hard on general
matrices have efficient solutions on matrices with \COP or \CROP
\cite[more citations pg.\,33]{d08phd}.

Table~\ref{tab:graphmatrices} summarises the way these graphs are
characterized by their matrices having \COP or \CROP.
Our focus in this chapter (and thesis) is mainly \COP and 
having seen how useful \COP is in identifying or characterizing many
types of graphs\endnote{\COP has several other applications
  \tnote{fill up.}}, we will now see results that study recognition of \COP
in matrices in the following section.



\temptext{ tab~\ref{tab:graphmatrices} -  have an abridged version
  of table 2.1 in dom. see notes for the possibility of a
  ``circle diagram''.} 
\begin{table}[htbp]
  \centering
 \caption{\figtabsize Graph matrices \temptext{PLACEHOLDER}}
  \label{tab:graphmatrices}
\end{table}

%\clearpage      % Print pending floats

\section{Matrices with COP}
\label{sec:surveycoptest}

The most important questions with respect to a particular 
property desired in a structure/object are perhaps the following.
\begin{itemize}%[]
\singlespacing
\item Does the desired property exist in the given input?
\item If the test is affirmative, what is a certificate of the affirmative?
\item If the test is negative, what are the optimization possibilities
  for the property in the input? In other words, how close to having the
  property can the input be?
\item If the test is negative, what is a certificate of the negative?
\end{itemize}

In this section and the rest of the chapter we see results that shaped the
correponding areas respectively for \cop in binary matrices.

\begin{enumerate}[a.]
\singlespacing
\item \label{q:testcop} Does a given binary matrix have \COP?
\item \label{q:copperm} What is the \COP permutation for the given matrix with \COP?
\item \label{q:copopt} What are the optimizations possible and practically useful on
  the given matrix without \COP?
\item \label{q:nocopcert} If algorithm for (\ref{q:testcop}) returns
  \textbf{false}, can a certificate for this be computed?
\end{enumerate}

Without doubt, besides computing answers to these questions, we are
interested in the efficiency of these computations in terms of
computational complexity theory. Results towards
questions~(\ref{q:testcop}) and (\ref{q:copperm}) are surveyed in this
section. Those for question~(\ref{q:copopt}) are discussed in
Section~\ref{sec:surveycopopt} and question~(\ref{q:nocopcert}) is discussed
in Section~\ref{sec:surveycertalgo}.

It may be noted that one way to design an algorithm to test for \COP
is by deriving one from any interval graph recognition algorithm using the
result {\sc hmpv00}\tnote{cite hmpv00} \tnote{in endnote put the theorem 2.7 - dom
  pg 43} \cite{d08phd} which demonstrates how such a derivation can be
done. However, this does not necessarily yield an efficient
algorithm. We will see results that directly solve the problem on
matrices since it is known that questions~(\ref{q:testcop}) and
(\ref{q:copperm}) stated above for \COP are efficiently solvable.
Table~\ref{tab:cophistory} gives a snapshot of these results.


\def\tabparboxw{10cm}
\begin{table}[htbp]
  \centering
  {
    \fontencoding{OT1}\fontfamily     {cmss}\selectfont
    % \sffamily
    \footnotesize
    % \includegraphics[scale=0.5]{../img/cophistory.png} % TEMPORARY

   \begin{tabular}[h]{lll}
     \hline
     \hline
     % 
     1899 & \parbox[t]{\tabparboxw}{ First mention of \COP
       (archaeology)} & \parbox[t]{2cm}{\temptext{by petrie -- cite
         kendall 69 pacific journal of mathematics 1969 }}  \\ 

     \rowcolor[gray]{0.8} %
     1951 & \parbox[t]{\tabparboxw}{ Heuristics for COT} & \cite{wsr51} \\

     1965 & \parbox[t]{\tabparboxw}{ First polynomial time algorithm
       for \COP testing} & \cite{fg65} \\ 

     \rowcolor[gray]{0.8} %
     1972 & \parbox[t]{\tabparboxw}{ Characterization for \COP -- forbidden
       submatrices} &
     \cite{at72} \\

     1976 & \parbox[t]{\tabparboxw}{ First linear time algorithm for COT --
       \PQtree} &
     \cite{bl76} \\

     \rowcolor[gray]{0.8} %
     1992 & \parbox[t]{\tabparboxw}{ Linear
       time algorithm COT without \PQtree} & \cite{wlh02}\endnote{First
       published in \cite{wlh02isaac92}} \\

     2001 & \parbox[t]{\tabparboxw}{\PCtree\ -- a simplification of
       \PQtree} & \cite{wlh01,hm03} \\  

     \rowcolor[gray]{0.8} %     
     1996 & \parbox[t]{\tabparboxw}{\PQRtree\ -- generalization of
       \PQtree for any binary matrix regardless of its \COP status} &
     \cite{mm96} \\ 

     1998 & \parbox[t]{\tabparboxw}{ Almost linear time to construct
       \PQRtree} & \cite{mpt98} \\ 

     \rowcolor[gray]{0.8} %
     2004 & \parbox[t]{\tabparboxw}{ A certifying algorithm for no
       \COP.\\ Generalized \PQtree.} & \cite{mcc04} \\ 

     2009 & \parbox[t]{\tabparboxw}{ Set theoretic, cardinality based
       characterization of \COP\ -- ICPIA} & \cite{nsnrs09} \\ 

     \rowcolor[gray]{0.8} %
     2010 & \parbox[t]{\tabparboxw}{ Logspace \COP testing} &
     \cite{kklv10}\\ 
     \hline
     \hline
   \end{tabular}
 }
 \caption[\figtabsize A brief history of \COP research]{\figtabsize A
   brief history of \COP research }
 \label{tab:cophistory}
\end{table}


The first polynomial time algorithm for \COP testing was by
\cite{fg65} which uses overlapping properties of columns with \un
s. Their result has close relations to the characterization of
interval graphs by \cite{gh64}. A graph $G$ is an interval graph \iff
all its maximal cliques can be linearly ordered \stt for any vertex
$v$ in $G$, all the cliques that $v$ is incident on are consecutive in
this order. Clearly, this means that the maximal clique incidence
matrix\endnote{
  Definition~\ref{def:graphmatrices}~\ref{def::maxcliquematrix}} must
have \COP on rows.

A few years later, a deeply significant result based on very
different ideas in understanding \COP came from Tucker which gave a
combinatorial (negative) characterization of matrices with COP
\cite{at72}. This result influenced most of the \COP results that
followed in the literature \annote[pressing]{including linear time
  algorithms}{did it? which ones?} for \COP recognition.


%\clearpage
\subsection{Tucker's forbidden submatrices for \COP}

% \change{While it is remarkable that the first polynomial time
%   algorithm for \COP testing came in }{The first polynomial time
%   algorithm for \COP testing came in }\cite{fg65} \change{,}{.}
% \change{it is safe to say that the most}{A few years later, a very}
% significant result in understanding \COP came \remove{a few years
%   later} from Tucker which gave a combinatorial (negative)
% characterization of matrices with COP \cite{at72}.

\cite{at72} discovered certain forbidden structures for convex
bipartite graphs\endnote{The terminology in \cite{at72} differs. It
  uses the term {\em graphs with $V_1$-consecutive arragement} instead
  of {\em convex bipartite graphs}.} and by definition of this graph
class, this translates to a set of forbidden submatrices for matrices
with \cop.  The following are the theorems from \cite{at72} that
acheived this characterization.


Theorem~\ref{th:tuckeratfree} states that convex bipartite graphs
cannot have {\em asteroidal triples}\endnote{If $G = (V,E)$ is a
  graph, a set of three vertices from $V$ form an {\em asteroidal
    triple} if between any two of them there exists a path in $G$ that
  does not contain any vertex from the closed neighborhood of the
  third vertex.} contained in the corresponding vertex
partition\endnote{The partition corresponds to columns (rows) if its
  half adjacency matrix has \COP columns (rows).}.
Theorem~\ref{th:tuckerforbidden} lists the structures in a
bipartite graph that force one of its vertex partitions to have
asteriodal triples -- in other words, it identifies the subgraphs that
prevent the graph from being convex bipartite.


\begin{theorem}
  (\cite[Th.~6]{at72}, \cite[Th.~2.3]{d08phd})\\
  A bipartite graph $G = (V_1, V_2, E)$ is convex bipartite on
  columns\endnote{Abridged to match terminology adopted in this
    document. See previous note.} \iff $V_1$ contains no asteroidal
  triple of $G$.
  \label{th:tuckeratfree}
\end{theorem}

\begin{theorem}
  (\cite[Th.~7]{at72}, \cite[Th.~2.4]{d08phd})\\
  In a bipartite graph $G = (V_1, V_2, E)$ the vertex set $V_1$
  contains no asteroidal triple \iff $G$ contains none of the graphs
  $G_{I_k}$, $G_{II_k}$, $G_{III_k}$ (with $k \ge 1$), $G_{IV}$,
  $G_{V}$ as shown in Figure~\ref{fig:forbiddensubgraphs} as subgraphs.
  \label{th:tuckerforbidden}
\end{theorem}


\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.35]{../img/tuckersforbiddensubgraphs.png}  
  \caption[\figtabsize Tucker's forbidden subgraphs]{\figtabsize Tucker's
    forbidden subgraphs for convex bipartite graphs. \temptext{ PLACEHOLDER
    IMG }} 
  \label{fig:forbiddensubgraphs}
\end{figure}

Theorem~\ref{th:tuckeratfree} and Theorem~\ref{th:tuckerforbidden}
result in the following Theorem~\ref{th:tuckercop} which characterizes
matrices with \COP.

\begin{theorem}
  (\cite[Th.~9]{at72}, \cite[Th.~2.5]{d08phd})\\
  A matrix $M$ has \COP \iff it contains none of the matrices 
$M_{I_k}$, $M_{II_k}$, $M_{III_k}$ (with $k \ge 1$), $M_{IV}$,
  $M_{V}$ as shown in Figure~\ref{fig:forbiddensubmatrices} as submatrices.
  \label{th:tuckercop}
\end{theorem}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.35]{../img/tuckersforbiddensubmatrices.png}  
  \caption[\figtabsize Tucker's forbidden submatrices]{\figtabsize Tucker's
    forbidden submatrices for convex bipartite graphs. \temptext{ PLACEHOLDER
    IMG }} 
  \label{fig:forbiddensubmatrices}
\end{figure}

It can be verified that the matrices in
Figure~\ref{fig:forbiddensubmatrices} are the half adjacency matrices
of the graphs in Figure~\ref{fig:forbiddensubgraphs} respectively
which is not surprising due to
Definition~\ref{def:graphwithcop}~\ref{def::convexbi}.

%\clearpage
\subsection{Booth and Lueker's $PQ$ tree -- a linear COT algorithm}

Booth and Lueker in their paper \cite{bl76} gave the first linear
algorithm\endnote{Time complexity is $O\left(m+n+f\right)$ where $m
  \times n$ is the order of the input matrix and $f$ is the number of $\un$s in it.} for \cop testing while given a linear time interval graph
recognition algorithm by a simplification of \tnote{cite - A. Lempel,
  S. Even and I. Cederbaum, An Algorithm for Planarity Testing of
  Graphs, Theory of Graphs, ed., P. Rosenstiehl, Gordon and Breach,
  New York, (1967), 215-232.  }'s planarity test algorithm.
% Hsu in wlh01 said BL76 gave a planarity test - "the induced PQ-tree
% algorithm can considerably simplify Booth and Lueker’s modification
% of Lempel, Even and Cederbaum’s planarity test. " 
%
% McConnell in hm03 said the first linear algo for interval graph
% recog was by BL76 - "Benzer’s work and other applications of
% interval graphs motivated a search for eﬃcient algorithms for
% recognizing interval graphs, and for constructing a set of intervals
% to represent the graph when it is one [8]. A linear-time algorithm
% was given in 1976 by Booth and Lueker [2]." 
\cite{bl76} introduces a data structure called \PQtree and their \COP
testing algorithm is a constructive one that outputs a \PQtree if the
input has \COP. A \PQtree represents all the \COP orderings of the
matrix it is associated with. \cite{bl76}'s algorithm uses the fact
that if a matrix has \COP, a \PQtree for it can be constructed. It is
interesting to note that aside from interval graph recognition and
\COP testing, \PQtree is also useful in other applications like
finding planar embeddings of planar graphs \cite{lec67,mcc04} and
recognizing \CROP in a matrix.

\begin{definition}[\emph{\PQtree \cite{bl76, mcc04}}]\\
  A \PQtree of matrix $M$ with \COP on columns (rows), is a tree with the following properties.
  \begin{enumerate}[i.]
    \singlespacing
  \item Each leaf uniquely represents a row (column) of $M$. The leaf
    order of the tree gives a \COP order for column (row)\endnote{Note
      that \COP order for column requires permutation of rows and vice
      versa.} for $M$.
  \item Every non-leaf node in the tree is labeled $P$ or $Q$.
  \item \label{def::nodep} The children of $P$ nodes are
    unordered. They can be permuted in any fashion to obtain a new
    \COP order for $M$.
  \item \label{def::nodeq} The children of $Q$ nodes are linearly
    ordered. Their order can be reversed to obtain a new \COP
    order for $M$.
  \end{enumerate}
  \label{def:pqtree}
\end{definition}

See Figure~\ref{fig:pqtree} for an example of \PQtree. It may be noted
that there is no way an empty set of \COP orderings can be represented
in this data structure. For this reason, \PQtree is undefined for
matrices that do not have \COP.  Thus effectively, there exists a
bijection between set of matrices with \COP and the set of \PQtrees
(accurately speaking, each matrix with \COP bijectively maps to an
equivalence class of \PQtrees resulting from properties (\ref{def::nodep}) and
(\ref{def::nodeq})).


\figpqtree

The \cite{bl76} algorithm with input $n \times m$ matrix $M$ starts
with a \PQtree for a vacuous $n \times 0$ matrix $M'$ (submatrix
induced by 0 columns). This is known as a {\em universal} \PQtree
which is one with its root as a $P$ node and only leaves as its
children -- each leaf representative of a row of input (by definition
of \COP for columns). This induced submatrix $M'$ vacuously has \COP.
Each column is then added iteratively to $M'$ to check if the new $M'$
has \COP.  By a complicated, but linear, procedure the algorithm does
one of the following actions in each iteration: (a) declare that $M$
has no \COP, or (b) modify the current \PQtree to represent the new
$M'$ (which clearly, must have \COP, since if not, option (a) would
have been executed).


Judging from notes in literature, this algorithm is apparently
notoriously difficult to program. In the procedure to modify the
\PQtree at each iteration, nodes are considered from leaves to
tree. At each node considered, it uses one of nine templates to
determine how the tree must be altered in the vicinity of this
node. Recognition of this template poses a difficult challenge in
terms of implementing it. Each template is actually a representative
of a larger class of similar templates, which must be dealt with
explicitly by a program\cite{mcc04}.


After the invention of \PQtrees, presumably due to the implementation
challenge it posed, there has been several variants of the same in the
literature, like \PCtree \cite{sh99,wlh01,hm03}, generalized \PQtree
\cite{km89,mcc04}, \PQRtree \cite{mm96,mpt98} etc. Most of these are
generalizations of \PQtree -- for instance, \PCtree is generalized to
matrices with \CROP, \PQRtree and generalized \PQtree are generalized
to matrices and set systems with or without \COP. \cite{km89} invented
a modified form of \PQtree a simpler incremental update of the tree
only for recognizing interval graphs.  \cite{kr88} constructed
efficient parallel algorithms for manipulating PQ trees. \temptext{dom
  chapter 2 pg 40 Variations of PQTrees first para - summarize.}

In the next few following sections we will see some of these
variations.
%Their algorithm was improved by \cite{tm05}
%\tnote{improved in terms of what?}. 
% describes an improved algorithm to
% build PQR trees.


%\section{Certifying Algorithms}
\subsection{\PQRtree\ --  COP for set systems}
\label{sec:surveycertalgo}

Section~\ref{sec:motive} mentions how a binary matrix naturally maps
to a system of sets.  A set can be constructed for each column of
matrix with its elements being those row indices at which the column
has \un s. Thus the collection of sets corresponding each column of
the matrix forms a set system with universe as the set of all row
indices of the matrix.  This simple construction is formally described
in Definition~\ref{def:matrixsetsystem} along with the idea of \cop
for set systems\endnote{As seen in Section~\ref{sec:courseschedule}}.

\begin{definition}%
  \label{def:matrixsetsystem}%
  % [\emph{Set system of a binary matrix}.]
  [\emph{\Cop for set systems}.]  Let $M$ be a binary matrix of order
  $n \times m$ % , $r_i, i \in [n]$ be the rows in $M$
  and $\{c_i \mid i \in [m]\}$ be the columns in $M$. A set system
  $\cF_{M} = \{S_i \mid S_i \subseteq [n], i \in [m]\}$ is defined
  such that for every column $c_i$ of $M$, set $S_i = \{j \mid m_{ji}
  = \un \}$. The collection $\cF_M$ is the {\em set system of binary
    matrix} $M$.\\
  A set system $\cF$ from universe $U = \{1, 2, \ldots, n\}$ has the
  \cop if it is possible to assign a linear order $\lambda$ to $U$
  where each set $S \in \cF$ appears as a consecutive subsequence of
  $\lambda$ (an interval) in the linear order.
\end{definition}

It is easy to see the equivalence of this definition to \COP for
matrices in Definition~\ref{def:copmatrix}.

Generalized \PQtree is a data structure defined in \cite{n89, mcc04} for
arbitrary set systems. If the set system has \COP, the generalized
\PQtree is identical to its \PQtree. We will use the notation from
\cite{n89} and call generalized \PQtrees as \gPQtrees. 

A \gPQtree of a given set system $\cF$ from universe $U$ represents
all the sets from $\power{U}$ that have trivial intersections with
every set in $\cF$. 

Two sets $A$ and $B$ are said to have a trivial intersection if $A
\cap B$ is one of the following -- $\emptyset$, $A$ or $B$. In other
words, $A$ and $B$ are either disjoint or one is the subset of the
other. {\em Trivial sets} are sets that have trivial intersections
with any set in $\power{U}$. These are namely, $U$, singleton sets in
$\power{U}$ and $\emptyset$\cite{n89, mm96}.

An important observation made by \cite{mm96} is that if $\cF$ is a set
system with \COP then, aside from every set in $\cF$ being consecutive
(after applying the \COP order) the following sets must also be
consecutive for any $A, B \in \cF$.
\begin{enumerate}
  \item The intersection $A \cap B$ 
  \item The union $A \cup B$ if $A \cap B \ne \emptyset$
  \item The relative complements $A \setminus B$ and $B \setminus A$
    if $B \nsubseteq A$ and $A \nsubseteq B$ respectively.
\end{enumerate}

Additionally the {\em trivial sets} of universe $U$ denoted by
$\cT(U)$, are namely -- $U$, singleton sets and the empty set
$\emptyset$. Clearly, $\cT(U)$ are consecutive
in all orderings of $U$. $\emptyset$ is considered consecutive by
convention.



Overlap components are computable in linear time \cite{mm95,wlh92}.



For any set system $\cF$, the smallest super set system containing
$\cF$ and the trivial sets that is closed under the above operations
is called the {\em weak closure} of $\cF$, denoted $\cW(\cF)$
\cite[Def.~3.2]{mcc04} \cite[Def.~2]{mm96}.

What is interesting is that the set of \COP permutations of $\cF$ is
the same as that of $\cW(\cF)$. \cite[Th.~3]{mm96}

The generalized \PQtree of $\cF$ is defined as the {\em decomposition
  tree} of its weak closure $\cW(\cF)$. Decomposition tree is the
inclusion tree (inclusion p.o. Hasse diagram) of the strong elements
of $\cW(\cF)$ with labels {\em prime, linear} and {\em degenerate}.\cite{mcc04}


\temptext{ Certifying algorithm (Generalized PQ trees) [McC04] -- 

Set theoretic characterizations [Hsu02, NS09]\\
    \cite{wlh02} describes the simpler algorithm for
    COT.\tnote[pressing]{in terms of what?}\\
    \cite{nsnrs09} describes a characterization of consecutive-ones
    property solely based on the cardinality properties of the set
    representations of the columns (rows); every column (row) is
    equivalent to a set that has the row (column) indices of the rows
    (columns) that have one entries in this column (row). This is
    interesting and relevant, especially to this thesis because it
    simplifies COT to a great degree by reducing the solution search
    space owing to the a simple set theoretic characterization.\\


\cite{mcc04} describes a different approach to COT. While all previous
COT algorithms gave the COP order if the matrix has the property but
exited stating negative if otherwise, this algorithm gives an evidence
by way of a certificate of matrix even when it has no COP. This
enables a user to verify the algorithm's result even when the answer
is negative. This is significant from an implementation perspective
because automated program verification is hard and manual verification
is more viable. Hence having a certificate reinforces an
implementation's credibility. Note that when the matrix {\em has} COP,
the COP order is the certificate.  The internal machinery of this
algorithm is related to the weighted betweenness problem
addressed\tnote{in what way??} in \cite{co98}.  \tnote{expand
  on the COP order graph creation and it having to be bipartite for M
  to have COP. and thus an odd cycle being an evidence of no COP.}

}



    
\subsection{\PCtree -- a generalization of \PQtree}

\PCtree is a generalization of \PQtree. It is a data structure that is
analogous to \PQtree but for matrices with \crop. \PCtree was
introduced by \cite{sh99} for the purpose of planarity testing where
this data structure represents partial embeddings of planar
graphs. % noted from wlh01 abstract.
In \cite{wlh01}, Hsu reintroduces \PCtree as a generalization of
\PQtree and shows how it simplifies \cite{bl76}'s planarity test by
making the \PQtree construction much less complicated. Later
\cite{hm03}, discovers that \PCtree is a representation of all \crop
orders of a matrix when it is unrooted. \PCtree presented in
\cite{wlh01} is rooted; however the construction of \PCtree is the
same in both results. The property of being unrooted is necessary in
order to use \PCtree as a data structure for encoding circular
ordering. Definition~\ref{def:pctree} defines \PCtree.

\begin{definition}
  \label{def:pctree}
  [\emph{\PCtree} \cite{wlh01,d08phd}.]  A \PCtree of matrix $M$ with
  \CROP on columns (rows), is a tree with the following properties.
  \begin{enumerate}[i.]
    \singlespacing
  \item Is unrooted -- thus it has (a) no parent child relationship
    between nodes (b) there is no left to right (or vice versa)
    ordering.
  \item Each leaf uniquely represents a row (column) of $M$. The leaf
    order of the tree gives a \CROP order for column (row) for
    $M$. Moreover, any sequence obtained by considering the leaves in
    clockwise or counter-clockwise order describes a \CROP order for
    $M$.
  \item Every non-leaf node in the tree is labeled $P$ or $C$.
  \item The neighbors of $P$ nodes can be permuted in any fashion to
    obtain a new \CROP order for $M$.
  \item \label{def::pcmirror} The tree can be changed by applying the following
    ``mirroring'' operation to obtain a new \CROP order for $M$. Root
    the \PCtree at a neighbor of a $C$-node, $v$ and mirror the
    subtree whose root is $v$ and finally unrooting the
    tree. Mirroring a subtree is done by putting the children of every
    node of the subtree in reverse order.
  \end{enumerate}
\end{definition}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{../img/pctree_hm03.png}

  \centering
  \includegraphics[scale=0.4]{../img/pctree_dom.png}
  \caption{\figtabsize \PCtree \temptext{ PLACEHOLDER 
IMGS \cite{hm03, d08phd}}}
  \label{fig:pctree}
\end{figure}

As a data structure when \PCtree is compared with \PQtree, the
differences are, (i) it is unrooted, (ii) it represents all \CROP order of a
matrix (iii) it has $C$ nodes instead of $Q$ nodes which can be
``mirrored'' (operation defined in Definition~\ref{def:pctree}~\ref{def::pcmirror}).
The algorithms of construction of \PQtree in \cite{bl76} and that of
\PCtree in \cite{wlh01, hm03} starkly differ since the latter is a
much simplified procedure.



% WLH01 abstract:
% [..] The original implementation of the PQ-tree algorithms by Booth and
% Lueker using nine templates in each bottom-up iteration is rather
% complicated. Also the complexity analysis is rather intricate. We give
% a very simple linear time PC-tree algorithm with the following
% advantages: (1) it does not use any template; (2) at each iteration,
% it does all necessary tree-modification operations in one batch and
% does not involve the node-by-node bottom-up matching; (3) it can be
% used naturally to test the circular ones property in matrices; (4) the
% induced PQ-tree algorithm can considerably simplify Booth and Lueker’s
% modification of Lempel, Even and Cederbaum’s planarity test.



\tnote[FYI]{ The results in cite~{bl76} on COT are based on the
   result that interval graphs are AT-free chordal graphs cite~{lb62}?
 No they don't seem related. this is the stupid bl lb confusion.}%


%\clearpage      % Print pending floats
% \section{COP in Relational Database Model}
% \label{sec:surveyrdbm}
% \tnote{Expand on sec:apprdbm} \tnote{(set systems theme)}
\section{Optimization problems in COP}
\label{sec:surveycopopt}
\tnote{Expand on ref:sec:optcop}

\temptext{ So far we have been concerned about matrices that have the
  consecutive ones property. However in real life applications, it is
  rare that data sets represented by binary matrices have COP,
  primarily due to the noisy nature of data available. At the same
  time, COP is not arbitrary and is a desirable property in practical
  data representation \cite{co98,jkckv04,k77}. In this context, there
  are several interesting problems when a matrix does not have COP but
  is ``close'' to having COP or is allowed to be altered to have
  COP. These are the optimization problems related to a matrix which
  does not have COP. Some of the significant problems are surveyed in
  this section.

\tnote{ -- sect 4.1 in cite:d08phd has many results surveyed. hardness
  results, approx. results. results are usually for a class of
  matrices $(a,b)$ where number {\un}s in columns and rows are
  restriced to $a$ and $b$ . -- problem of flipping at most $k$
  entries of $M$ to make it attain COP. this is NP complete
  cite:b75-phd}%
\tnote{(1) scite:lb62 showed that interval graphs are chordal and
  AT-free.} %
\temptext{couple of lines refering to tucker's submatrices. refer
  earlier section.}

Once a matrix has been detected to not have COP (using any of the COT
algorithms mentioned earlier), it is naturally of interest 

\begin{enumerate}
\item  to find out
the smallest forbidden substructure (in terms of number of rows and/or
columns and/or number of entries that are {\un}s). \cite{d08phd}
discusses a couple of algorithms which are efficient if the number of
{\un}s in a row is small. This is of significance in the case of
sparse matrices where this number is much lesser than the number of
columns. 

\item $(*,\Delta)${\em -matrices} are matrices with no restriction
on number of {\un}s in any column but has at most $\Delta$ {\un}s in
any row. 
{\sc Min COS-R (Min COS-C), Max COS-R (Max COS-C)} are
similar problems which deals with {\em inducing COP} on a matrix.

\begin{enumerate}
\item In the dual problem {\sc Max COS-R (Max COS-C)} the search is for the
maximum number of rows (columns) that induces a submatrix with
COP.
\item In {\sc
  Min COS-R (Min COS-C)} the question is to find the minimum number of
rows (columns) that must be deleted to result in a matrix with COP.
\end{enumerate}

Given a matrix $M$ with no COP, \cite{b75-phd} shows that finding
a submatrix $M'$ with all columns\tnote{check if b75 deals with
  COP col or COP row. also is it any submatrix with k less than r rows
  or submatrix must have all columns?} but a maximum cardinality
subset of rows such that $M'$ has COP is NP complete. \cite{hg02}
corrects an error of the abridged proof of this reduction as given in
\cite{gj79}.  \cite{d08phd} discusses all these problems in detail
giving an extensive survey of the previously existing results which
are almost exhaustively all approximation results and hardness
results. Taking this further, \cite{d08phd} presents new results in
the area of parameterized algorithms for this
problem\tnote{elaborate - what are the results?}.

\item Another problem is to find the minimum number of entries in the matrix
that can be toggled to result in a matrix with COP.  \cite{v85}
discusses approximation of {\sc COP Augmentation} which is the problem
of changing of the minimum number of zero entries to {\un}s so that
the resulting matrix has COP. As mentioned earlier, this problem is
known to be NP complete due to \cite{b75-phd}. \cite{v85} also proves,
using a reduction to the longest path problem, \tnote{or is it a
  survey of another result?  check.} that finding a Tucker's forbidden
submatrix of at least $k$ rows is NP complete. \tnote{how is this
  different from booth's 75 result??}  \tnote{where should this go?
  cite|tz04 (approx submatrix with COP sparse matrices)}

\item \cite{jkckv04} discusses the use of matrices with almost-COP (instead
of one block of consecutive {\un}s, they have $x$ blocks, or {\em
  runs}, of consecutive {\un}s and $x$ is not too large) in the
storage of very large databases.  The problem is that of reordering of
a binary matrix such that the resulting matrix has at most $k$ runs of
{\un}s. This is proved to be NP hard using a reduction from the
Hamiltonian path problem.\tnote{Theorem 2.1 in jkckv} \tnote{(1) A
  connection of COP problem to the travelling salesman problem is also
  introduced. what does this mean? -- COP can be used as a tool to
  reorder $0.5T \le runs(M) \le T$. (2) The optimization version of
  the $k$-run problem, i.e. minimization of number of blocks of ones
  is proven to be NP complete by cite:k77}\tnote{are these two the
  same?} \tnote{what is the reduction?} \tnote{other problems similar
  to COP -- cite:ckl96 (ILP, circ ones, one drop) -- cite:th98
  (generalization of COP - minimax, biotonic column) Tucker} 

\end{enumerate}

}


\section{COP in Graph Isomorphism}
\label{sec:surveygraphiso}
\tnote{Expand on sec:appgraphiso} \tnote{(canonization theme)}

\tnote[pressing]{ADD: peo exists iff chordal. lexicographic BFS
  [tag:chordalGraph]} %

\temptext{
The survey from kklv10 conclusion.
}

% \section{Other applications}
% {\tt If any. \tnote{ where should this go?}: (1) cite|jlm97 (application of PQ
%   trees in graphics). (2) helly's theorem citation
%   19XXdgk-Hellystheorem-Danzer-Gruenbaum-Klee}}




\theendnotes\tnote{remove if none.} 




%%%%%%%%%%%%% listing package for pretty formatting BEGIN
% \lstloadlanguages{C}
% \lstset{language=C, commentstyle=\scriptsize,
%   numberstyle=\tiny, numbers=left,               % Line numbers
%   stepnumber=2,numbersep=5pt,firstnumber=10, 
%   showstringspaces=false,                    % No explicit spaces
%   emph={printf},emphstyle=\underbar,      % Specific formatting
%   emph=[2]{sum},emphstyle=[2]\color{blue},      % Sp format (multiple)
%   emph=[3]{i},emphstyle=[3]\color{red}      % Sp format (multiple)
%   } 

%   \begin{singlespacing}
%     % Text inside "lstlisting" env is verbatim.
%     \begin{lstlisting}[keywordstyle=\textbf]      
% int sum;
% int i; /* for loop variable */ 
% sum = 0; 
% for (i=0, i<n; i++) { 
%   sum += a[i]; 
% } 
% printf{"This is stupid."}
%     \end{lstlisting}
%   \end{singlespacing}

%%%%%%%%%%%%% listing package for pretty formatting END

